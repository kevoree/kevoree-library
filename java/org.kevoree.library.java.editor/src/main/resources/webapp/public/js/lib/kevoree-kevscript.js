!function(e){"object"==typeof exports?module.exports=e():"function"==typeof define&&define.amd?define(e):"undefined"!=typeof window?window.kevoreeKevscript=e():"undefined"!=typeof global?global.kevoreeKevscript=e():"undefined"!=typeof self&&(self.kevoreeKevscript=e())}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = require('./lib/KevScript');
},{"./lib/KevScript":2}],2:[function(require,module,exports){
var Class       = require('pseudoclass'),
    kevs        = require('./parser'),
    interpreter = require('./interpreter');

var KevScript = Class({
  toString: 'KevScript',

  construct: function (options) {
    this.options = options || {};
  },

  /**
   * Parses given KevScript source-code in parameter 'data' and returns a ContainerRoot.
   * @param data string
   * @param callback function (Error, ContainerRoot)
   * @throws Error on SyntaxError and on source code validity and such
   */
  parse: function (data, ctxModel, callback) {
    if (typeof(callback) == 'undefined') {
      callback = ctxModel;
      ctxModel = null;

    }

    var parser = new kevs.Parser();
    var ast = parser.parse(data);
    if (ast.type != 'kevScript') {
      return callback(new Error(ast.toString()));
    } else {
      interpreter(ast, ctxModel, this.options.resolvers, function (err, model) {
        if (err) return callback(err);

        return callback(null, model);
      });
    }
  }
});

module.exports = KevScript;
},{"./interpreter":3,"./parser":5,"pseudoclass":36}],3:[function(require,module,exports){
var kevoree = require('kevoree-library').org.kevoree,
    async   = require('async'),
    path    = require('path');

var factory = new kevoree.impl.DefaultKevoreeFactory();
var cloner  = new kevoree.cloner.DefaultModelCloner();

// retrieve statements processors
var statements = {
  addRepo:      require('./statements/addRepo'),
  include:      require('./statements/include'),
  add:          require('./statements/add'),
  move:         require('./statements/move'),
  attach:       require('./statements/attach'),
  addBinding:   require('./statements/addBinding'),
  delBinding:   require('./statements/delBinding'),
  set:          require('./statements/set'),
  network:      require('./statements/network'),
  remove:       require('./statements/remove'),
  detach:       require('./statements/detach'),
  typeDef:      require('./statements/typeDef'),
  nameList:     require('./statements/nameList'),
  instancePath: require('./statements/instancePath'),
  namespace:    require('./statements/namespace'),
  wildcard:     require('./statements/wildcard'),
  string:       require('./statements/string'),
  string2:      require('./statements/string2'),
  repoString:   require('./statements/repoString'),
  version:      require('./statements/version'),
  anything:     require('./statements/anything')
};

/**
 *
 * @param ast
 * @param ctxModel
 * @param resolvers
 * @param callback
 */
var interpreter = function interpreter(ast, ctxModel, resolvers, callback) {
  // output model
  var model = null;
  // if we have a context model, clone it and use it has a base
  if (ctxModel) model = cloner.clone(ctxModel, false);
  // otherwise start from a brand new model
  else model = factory.createContainerRoot();

  var options = {
    resolvers: resolvers,
    namespaces: {}
  };

  // process statements
  var tasks = [];
  for (var i in ast.children) {
    for (var j in ast.children[i].children) {
      (function (stmt) {
        tasks.push(function (cb) {
          statements[stmt.type](model, statements, stmt, options, cb);
        });
      })(ast.children[i].children[j]);
    }
  }

  // execute tasks
  async.series(tasks, function (err) {
    if (err) return callback(err);

    return callback(null, model);
  });
}

module.exports = interpreter;
},{"./statements/add":6,"./statements/addBinding":7,"./statements/addRepo":8,"./statements/anything":9,"./statements/attach":10,"./statements/delBinding":11,"./statements/detach":12,"./statements/include":13,"./statements/instancePath":14,"./statements/move":15,"./statements/nameList":16,"./statements/namespace":17,"./statements/network":18,"./statements/remove":19,"./statements/repoString":20,"./statements/set":21,"./statements/string":22,"./statements/string2":23,"./statements/typeDef":24,"./statements/version":25,"./statements/wildcard":26,"async":28,"kevoree-library":35,"path":30}],4:[function(require,module,exports){
function findChanNodeGroupByName(model, name) {
  function findByName(elem) {
    var elems = (model[elem]) ? model[elem].iterator() : null;
    if (elems != null) {
      while (elems.hasNext()) {
        var entity = elems.next();
        if (entity.name === name) return entity;
      }
    }
    return null;
  }

  return findByName('nodes') || findByName('groups') || findByName('hubs') || null;
}

function findComponent(model, nodeName, compName) {
  var node = model.findNodesByID(nodeName);
  if (node) {
    var comps = node.components.iterator();
    while (comps.hasNext()) {
      var comp = comps.next();
      if (comp.name === compName) return comp;
    }

  } else return null;
}

module.exports = {
  findEntityByName: findChanNodeGroupByName,
  findComponentByName: findComponent
}
},{}],5:[function(require,module,exports){
/*
 * Generated by the Waxeye Parser Generator - version 0.8.0
 * www.waxeye.org
 */

var waxeye = waxeye;
if (typeof module !== 'undefined') {
    // require from module system
    waxeye = require('./waxeye');
}

var Parser = (function() {

    var parser = function() { return this; };
    parser.prototype = new waxeye.WaxeyeParser(0, true, [new waxeye.FA("kevScript", [new waxeye.State([new waxeye.Edge(1, 1, false),
                new waxeye.Edge(35, 5, true)], false),
            new waxeye.State([new waxeye.Edge(37, 2, false)], false),
            new waxeye.State([new waxeye.Edge(1, 3, false),
                new waxeye.Edge(35, 4, true)], true),
            new waxeye.State([new waxeye.Edge(37, 2, false)], false),
            new waxeye.State([new waxeye.Edge(36, 3, false)], true),
            new waxeye.State([new waxeye.Edge(36, 1, false)], false)], waxeye.FA.LEFT),
        new waxeye.FA("statement", [new waxeye.State([new waxeye.Edge(2, 1, false),
                new waxeye.Edge(3, 1, false),
                new waxeye.Edge(4, 1, false),
                new waxeye.Edge(5, 1, false),
                new waxeye.Edge(6, 1, false),
                new waxeye.Edge(7, 1, false),
                new waxeye.Edge(9, 1, false),
                new waxeye.Edge(10, 1, false),
                new waxeye.Edge(12, 1, false),
                new waxeye.Edge(8, 1, false),
                new waxeye.Edge(11, 1, false),
                new waxeye.Edge(15, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("add", [new waxeye.State([new waxeye.Edge(25, 1, false)], false),
            new waxeye.State([new waxeye.Edge(37, 2, false)], false),
            new waxeye.State([new waxeye.Edge(13, 3, false)], false),
            new waxeye.State([new waxeye.Edge(37, 4, false)], false),
            new waxeye.State([new waxeye.Edge(":", 5, true)], false),
            new waxeye.State([new waxeye.Edge(37, 6, false)], false),
            new waxeye.State([new waxeye.Edge(14, 7, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("remove", [new waxeye.State([new waxeye.Edge(26, 1, false)], false),
            new waxeye.State([new waxeye.Edge(37, 2, false)], false),
            new waxeye.State([new waxeye.Edge(13, 3, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("move", [new waxeye.State([new waxeye.Edge(27, 1, false)], false),
            new waxeye.State([new waxeye.Edge(37, 2, false)], false),
            new waxeye.State([new waxeye.Edge(13, 3, false)], false),
            new waxeye.State([new waxeye.Edge(37, 4, false)], false),
            new waxeye.State([new waxeye.Edge(16, 5, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("attach", [new waxeye.State([new waxeye.Edge(29, 1, false)], false),
            new waxeye.State([new waxeye.Edge(37, 2, false)], false),
            new waxeye.State([new waxeye.Edge(13, 3, false)], false),
            new waxeye.State([new waxeye.Edge(37, 4, false)], false),
            new waxeye.State([new waxeye.Edge(16, 5, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("detach", [new waxeye.State([new waxeye.Edge(30, 1, false)], false),
            new waxeye.State([new waxeye.Edge(37, 2, false)], false),
            new waxeye.State([new waxeye.Edge(13, 3, false)], false),
            new waxeye.State([new waxeye.Edge(37, 4, false)], false),
            new waxeye.State([new waxeye.Edge(16, 5, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("set", [new waxeye.State([new waxeye.Edge(28, 1, false)], false),
            new waxeye.State([new waxeye.Edge(37, 2, false)], false),
            new waxeye.State([new waxeye.Edge(16, 3, false)], false),
            new waxeye.State([new waxeye.Edge("/", 4, true),
                new waxeye.Edge(37, 6, false),
                new waxeye.Edge("/", 14, true),
                new waxeye.Edge(37, 16, false)], false),
            new waxeye.State([new waxeye.Edge(16, 5, false)], false),
            new waxeye.State([new waxeye.Edge(37, 6, false)], false),
            new waxeye.State([new waxeye.Edge("=", 7, true)], false),
            new waxeye.State([new waxeye.Edge(37, 8, false)], false),
            new waxeye.State([new waxeye.Edge(["\'"], 9, true)], false),
            new waxeye.State([new waxeye.Edge(37, 10, false)], false),
            new waxeye.State([new waxeye.Edge(19, 11, false)], false),
            new waxeye.State([new waxeye.Edge(37, 12, false)], false),
            new waxeye.State([new waxeye.Edge(["\'"], 13, true)], false),
            new waxeye.State([], true),
            new waxeye.State([new waxeye.Edge(16, 15, false)], false),
            new waxeye.State([new waxeye.Edge(37, 16, false)], false),
            new waxeye.State([new waxeye.Edge("=", 17, true)], false),
            new waxeye.State([new waxeye.Edge(37, 18, false)], false),
            new waxeye.State([new waxeye.Edge(["\""], 19, true)], false),
            new waxeye.State([new waxeye.Edge(37, 20, false)], false),
            new waxeye.State([new waxeye.Edge(19, 21, false)], false),
            new waxeye.State([new waxeye.Edge(37, 22, false)], false),
            new waxeye.State([new waxeye.Edge(["\""], 13, true)], false)], waxeye.FA.LEFT),
        new waxeye.FA("network", [new waxeye.State([new waxeye.Edge(31, 1, false)], false),
            new waxeye.State([new waxeye.Edge(37, 2, false)], false),
            new waxeye.State([new waxeye.Edge(16, 3, false)], false),
            new waxeye.State([new waxeye.Edge(37, 4, false)], false),
            new waxeye.State([new waxeye.Edge(19, 5, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("addBinding", [new waxeye.State([new waxeye.Edge(32, 1, false)], false),
            new waxeye.State([new waxeye.Edge(37, 2, false)], false),
            new waxeye.State([new waxeye.Edge(16, 3, false)], false),
            new waxeye.State([new waxeye.Edge(37, 4, false)], false),
            new waxeye.State([new waxeye.Edge(16, 5, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("delBinding", [new waxeye.State([new waxeye.Edge(33, 1, false)], false),
            new waxeye.State([new waxeye.Edge(37, 2, false)], false),
            new waxeye.State([new waxeye.Edge(16, 3, false)], false),
            new waxeye.State([new waxeye.Edge(37, 4, false)], false),
            new waxeye.State([new waxeye.Edge(16, 5, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("addRepo", [new waxeye.State([new waxeye.Edge(23, 1, false)], false),
            new waxeye.State([new waxeye.Edge(37, 2, false)], false),
            new waxeye.State([new waxeye.Edge(21, 3, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("include", [new waxeye.State([new waxeye.Edge(24, 1, false)], false),
            new waxeye.State([new waxeye.Edge(37, 2, false)], false),
            new waxeye.State([new waxeye.Edge(18, 3, false)], false),
            new waxeye.State([new waxeye.Edge(":", 4, true)], false),
            new waxeye.State([new waxeye.Edge(19, 5, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("nameList", [new waxeye.State([new waxeye.Edge(16, 1, false)], false),
            new waxeye.State([new waxeye.Edge(37, 2, false)], false),
            new waxeye.State([new waxeye.Edge([","], 3, true)], true),
            new waxeye.State([new waxeye.Edge(37, 4, false)], false),
            new waxeye.State([new waxeye.Edge(16, 2, false)], false)], waxeye.FA.LEFT),
        new waxeye.FA("typeDef", [new waxeye.State([new waxeye.Edge(18, 1, false)], false),
            new waxeye.State([new waxeye.Edge("/", 2, true)], true),
            new waxeye.State([new waxeye.Edge(20, 3, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("namespace", [new waxeye.State([new waxeye.Edge(34, 1, false)], false),
            new waxeye.State([new waxeye.Edge(37, 2, false)], false),
            new waxeye.State([new waxeye.Edge(18, 3, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("instancePath", [new waxeye.State([new waxeye.Edge(17, 1, false),
                new waxeye.Edge(18, 1, false)], false),
            new waxeye.State([new waxeye.Edge(["."], 2, true)], true),
            new waxeye.State([new waxeye.Edge(17, 1, false),
                new waxeye.Edge(18, 1, false)], false)], waxeye.FA.LEFT),
        new waxeye.FA("wildcard", [new waxeye.State([new waxeye.Edge("*", 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("string", [new waxeye.State([new waxeye.Edge(["-", [48, 57], [65, 90], "_", [97, 122]], 1, false)], false),
            new waxeye.State([new waxeye.Edge(["-", [48, 57], [65, 90], "_", [97, 122]], 1, false)], true)], waxeye.FA.LEFT),
        new waxeye.FA("string2", [new waxeye.State([new waxeye.Edge([[45, 46], [48, 58], [64, 90], "_", [97, 122]], 1, false)], false),
            new waxeye.State([new waxeye.Edge([[45, 46], [48, 58], [64, 90], "_", [97, 122]], 1, false)], true)], waxeye.FA.LEFT),
        new waxeye.FA("version", [new waxeye.State([new waxeye.Edge([[45, 46], [48, 57], [65, 90], "_", [97, 122]], 1, false)], false),
            new waxeye.State([new waxeye.Edge([[45, 46], [48, 57], [65, 90], "_", [97, 122]], 1, false)], true)], waxeye.FA.LEFT),
        new waxeye.FA("repoString", [new waxeye.State([new waxeye.Edge(41, 1, false)], false),
            new waxeye.State([new waxeye.Edge(40, 2, true)], false),
            new waxeye.State([new waxeye.Edge(-1, 3, false)], false),
            new waxeye.State([new waxeye.Edge(39, 4, false)], true),
            new waxeye.State([new waxeye.Edge(38, 5, true)], false),
            new waxeye.State([new waxeye.Edge(-1, 3, false)], false)], waxeye.FA.LEFT),
        new waxeye.FA("anything", [new waxeye.State([new waxeye.Edge(43, 1, false)], false),
            new waxeye.State([new waxeye.Edge(-1, 2, false)], false),
            new waxeye.State([new waxeye.Edge(42, 3, false)], true),
            new waxeye.State([new waxeye.Edge(-1, 2, false)], false)], waxeye.FA.LEFT),
        new waxeye.FA("repoToken", [new waxeye.State([new waxeye.Edge("r", 1, false)], false),
            new waxeye.State([new waxeye.Edge("e", 2, false)], false),
            new waxeye.State([new waxeye.Edge("p", 3, false)], false),
            new waxeye.State([new waxeye.Edge("o", 4, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("includeToken", [new waxeye.State([new waxeye.Edge("i", 1, false)], false),
            new waxeye.State([new waxeye.Edge("n", 2, false)], false),
            new waxeye.State([new waxeye.Edge("c", 3, false)], false),
            new waxeye.State([new waxeye.Edge("l", 4, false)], false),
            new waxeye.State([new waxeye.Edge("u", 5, false)], false),
            new waxeye.State([new waxeye.Edge("d", 6, false)], false),
            new waxeye.State([new waxeye.Edge("e", 7, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("addToken", [new waxeye.State([new waxeye.Edge("a", 1, false)], false),
            new waxeye.State([new waxeye.Edge("d", 2, false)], false),
            new waxeye.State([new waxeye.Edge("d", 3, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("removeToken", [new waxeye.State([new waxeye.Edge("r", 1, false)], false),
            new waxeye.State([new waxeye.Edge("e", 2, false)], false),
            new waxeye.State([new waxeye.Edge("m", 3, false)], false),
            new waxeye.State([new waxeye.Edge("o", 4, false)], false),
            new waxeye.State([new waxeye.Edge("v", 5, false)], false),
            new waxeye.State([new waxeye.Edge("e", 6, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("moveToken", [new waxeye.State([new waxeye.Edge("m", 1, false)], false),
            new waxeye.State([new waxeye.Edge("o", 2, false)], false),
            new waxeye.State([new waxeye.Edge("v", 3, false)], false),
            new waxeye.State([new waxeye.Edge("e", 4, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("setToken", [new waxeye.State([new waxeye.Edge("s", 1, false)], false),
            new waxeye.State([new waxeye.Edge("e", 2, false)], false),
            new waxeye.State([new waxeye.Edge("t", 3, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("attachToken", [new waxeye.State([new waxeye.Edge("a", 1, false)], false),
            new waxeye.State([new waxeye.Edge("t", 2, false)], false),
            new waxeye.State([new waxeye.Edge("t", 3, false)], false),
            new waxeye.State([new waxeye.Edge("a", 4, false)], false),
            new waxeye.State([new waxeye.Edge("c", 5, false)], false),
            new waxeye.State([new waxeye.Edge("h", 6, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("detachToken", [new waxeye.State([new waxeye.Edge("d", 1, false)], false),
            new waxeye.State([new waxeye.Edge("e", 2, false)], false),
            new waxeye.State([new waxeye.Edge("t", 3, false)], false),
            new waxeye.State([new waxeye.Edge("a", 4, false)], false),
            new waxeye.State([new waxeye.Edge("c", 5, false)], false),
            new waxeye.State([new waxeye.Edge("h", 6, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("networkToken", [new waxeye.State([new waxeye.Edge("n", 1, false)], false),
            new waxeye.State([new waxeye.Edge("e", 2, false)], false),
            new waxeye.State([new waxeye.Edge("t", 3, false)], false),
            new waxeye.State([new waxeye.Edge("w", 4, false)], false),
            new waxeye.State([new waxeye.Edge("o", 5, false)], false),
            new waxeye.State([new waxeye.Edge("r", 6, false)], false),
            new waxeye.State([new waxeye.Edge("k", 7, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("bindToken", [new waxeye.State([new waxeye.Edge("b", 1, false)], false),
            new waxeye.State([new waxeye.Edge("i", 2, false)], false),
            new waxeye.State([new waxeye.Edge("n", 3, false)], false),
            new waxeye.State([new waxeye.Edge("d", 4, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("unbindToken", [new waxeye.State([new waxeye.Edge("u", 1, false)], false),
            new waxeye.State([new waxeye.Edge("n", 2, false)], false),
            new waxeye.State([new waxeye.Edge("b", 3, false)], false),
            new waxeye.State([new waxeye.Edge("i", 4, false)], false),
            new waxeye.State([new waxeye.Edge("n", 5, false)], false),
            new waxeye.State([new waxeye.Edge("d", 6, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("namespaceToken", [new waxeye.State([new waxeye.Edge("n", 1, false)], false),
            new waxeye.State([new waxeye.Edge("a", 2, false)], false),
            new waxeye.State([new waxeye.Edge("m", 3, false)], false),
            new waxeye.State([new waxeye.Edge("e", 4, false)], false),
            new waxeye.State([new waxeye.Edge("s", 5, false)], false),
            new waxeye.State([new waxeye.Edge("p", 6, false)], false),
            new waxeye.State([new waxeye.Edge("a", 7, false)], false),
            new waxeye.State([new waxeye.Edge("c", 8, false)], false),
            new waxeye.State([new waxeye.Edge("e", 9, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("comment", [new waxeye.State([new waxeye.Edge("/", 1, false)], false),
            new waxeye.State([new waxeye.Edge("/", 2, false)], false),
            new waxeye.State([new waxeye.Edge(22, 3, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("eol", [new waxeye.State([new waxeye.Edge("\r", 1, false),
                new waxeye.Edge("\n", 2, false),
                new waxeye.Edge("\r", 2, false)], false),
            new waxeye.State([new waxeye.Edge("\n", 2, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("ws", [new waxeye.State([new waxeye.Edge(["\t", " "], 0, false),
                new waxeye.Edge(36, 0, false)], true)], waxeye.FA.VOID),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge([" "], 1, true)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(36, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge([" "], 1, true)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(36, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(36, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(36, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG)]);
    return parser;
 
})();

// Add to module system
if (typeof module !== 'undefined') {
    module.exports.Parser = Parser;
}

},{"./waxeye":27}],6:[function(require,module,exports){
var kevoree    = require('kevoree-library').org.kevoree;
var factory    = new kevoree.impl.DefaultKevoreeFactory();
var Kotlin     = require('kevoree-kotlin');

module.exports = function (model, statements, stmt, opts, cb) {
  var nameList = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
  var typeDef  = statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);

  // try to find TypeDefinition in model
  var tDef = model.findTypeDefinitionsByID(typeDef);

  // create proper entity according to the type
  if (Kotlin.isType(tDef, kevoree.impl.NodeTypeImpl)) {
    for (var i in nameList) {
      nameList[i].expect(1, 2, function (err, namespace, instanceName) {
        if (err) {
          err.message += ' (add '+nameList[i].toString()+' : '+typeDef.toString()+')';
          return cb(err);
        }

        if (instanceName !== '*') {
          var node = factory.createContainerNode();
          node.name = instanceName;
          node.typeDefinition = tDef;
          model.addNodes(node);

          if (namespace) {
            if (opts.namespaces[namespace]) {
              opts.namespaces[namespace][instanceName] = node;
            } else {
              return cb(new Error('Unable to find "'+namespace+'" namespace. Did you create it? (add '+nameList[i].toString()+' : '+typeDef.toString()+')'));
            }
          }
        } else {
          return cb(new Error('You cannot name a node instance "*" (add '+nameList[i].toString()+' : '+typeDef.toString()+')'));
        }
      });
    }

  } else if (Kotlin.isType(tDef, kevoree.impl.GroupTypeImpl)) {
    for (var i in nameList) {
      nameList[i].expect(1, 2, function (err, namespace, instanceName) {
        if (err) {
          err.message += ' (add '+nameList[i].toString()+' : '+typeDef.toString()+')';
          return cb(err);
        }

        if (instanceName !== '*') {
          var group = factory.createGroup();
          group.name = instanceName;
          group.typeDefinition = tDef;
          model.addGroups(group);

          if (namespace) {
            if (opts.namespaces[namespace]) {
              opts.namespaces[namespace][instanceName] = group;
            } else {
              return cb(new Error('Unable to find "'+namespace+'" namespace. Did you create it? (add '+nameList[i].toString()+' : '+typeDef.toString()+')'));
            }
          }
        } else {
          return cb(new Error('You cannot name a node instance "*" (add '+nameList[i].toString()+' : '+typeDef.toString()+')'));
        }
      });
    }

  } else if (Kotlin.isType(tDef, kevoree.impl.ChannelTypeImpl)) {
    for (var i in nameList) {
      nameList[i].expect(1, 2, function (err, namespace, instanceName) {
        if (err) {
          err.message += ' (add '+nameList[i].toString()+' : '+typeDef.toString()+')';
          return cb(err);
        }

        if (instanceName !== '*') {
          var chan = factory.createChannel();
          chan.name = instanceName;
          chan.typeDefinition = tDef;
          model.addHubs(chan);

          if (namespace) {
            if (opts.namespaces[namespace]) {
              opts.namespaces[namespace][instanceName] = chan;
            } else {
              return cb(new Error('Unable to find "'+namespace+'" namespace. Did you create it? (add '+nameList[i].toString()+' : '+typeDef.toString()+')'));
            }
          }
        } else {
          return cb(new Error('You cannot name a node instance "*" (add '+nameList[i].toString()+' : '+typeDef.toString()+')'));
        }
      });
    }

  } else if (Kotlin.isType(tDef, kevoree.impl.ComponentTypeImpl)) {
    for (var i in nameList) {
      nameList[i].expect(2, 3, function (err, namespace, nodeName, compName) {
        if (err) {
          err.message += ' (add '+nameList[i].toString()+' : '+typeDef.toString()+')';
          return cb(err);
        }

        if (namespace) {
          // TODO handle namespace
          return cb(new Error('Namespaces are not handled yet :/ Sorry'));

        } else if (compName === '*') {
          return cb(new Error('You cannot name a component instance "*" (add '+nameList[i].toString()+' : '+typeDef.toString()+')'));

        } else {
          if (nodeName === '*') {
            // add compName instance to all nodes in the model
            var nodes = model.nodes.iterator();
            while (nodes.hasNext()) {
              var comp = factory.createComponentInstance();
              comp.name = compName;
              comp.typeDefinition = tDef;
              nodes.next().addComponents(comp);
            }

          } else {
            var node = model.findNodesByID(nodeName);
            if (node) {
              var comp = factory.createComponentInstance();
              comp.name = compName;
              comp.typeDefinition = tDef;
              node.addComponents(comp);

            } else {
              return cb(new Error('Unable to find container node "'+nodeName+'" in current model (add '+nameList[i].toString()+' : '+typeDef.toString()+')'));
            }
          }
        }
      });
    }

  } else {
    return cb(new Error('TypeDefinition "'+typeDef+'" doesn\'t exist in current model. (Maybe you should add an "include" for it?)'));
  }
  cb();
}
},{"kevoree-kotlin":33,"kevoree-library":35}],7:[function(require,module,exports){
var kevoree = require('kevoree-library').org.kevoree;
var factory = new kevoree.impl.DefaultKevoreeFactory();

module.exports = function (model, statements, stmt, opts, cb) {
  var port = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
  var chan = statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);

  function addBinding2(portName, comp, node, chanInst) {
    // start with a undefined portInst
    var portInst;

    // now lets try to find a Port instance in this component provided ports
    var inputs = comp.provided.iterator();
    while (inputs.hasNext()) {
      var input = inputs.next();
      if (input.portTypeRef.name == portName) {
        portInst = input;
        break;
      }
    }
    if (!portInst) {
      // if we can't find it in provided ports, lets try in required
      var outputs = comp.required.iterator();
      while (outputs.hasNext()) {
        var output = outputs.next();
        if (output.portTypeRef.name == portName) {
          portInst = output;
          break;
        }
      }
    }
    if (!portInst) {
      // reaching this point means that we were not able to find any port instance
      // matching this portName, so we have to create a brand new port instance
      portInst = factory.createPort();
      // lets try to find a PortTypeRef in the component TypeDefinition provided ports that matches portName
      var inputRefs = comp.typeDefinition.provided.iterator();
      while (inputRefs.hasNext()) {
        var inRef = inputRefs.next();
        if (inRef.name == portName) {
          // bingo, add it the the comp instance
          portInst.portTypeRef = inRef;
          comp.addProvided(portInst);
          break;
        }
      }
      if (!portInst.portTypeRef) {
        // well, it isn't a provided port obviously, so now lets try to find out if it is a required
        var outputRefs = comp.typeDefinition.required.iterator();
        while (outputRefs.hasNext()) {
          var outRef = outputRefs.next();
          if (outRef.name == portName) {
            // bingo, add it to the comp instance
            portInst.portTypeRef = outRef;
            comp.addRequired(portInst);
            break;
          }
        }
      }
    }

    if (portInst && portInst.portTypeRef && portInst.portTypeRef.name == portName) {
      var bindings = model.mBindings.iterator();
      var alreadyBound = false;
      while (bindings.hasNext()) {
        var binding = bindings.next();
        if (binding.hub.name === chanInst.name &&
          binding.port.portTypeRef.name === portName &&
          binding.port.eContainer().name === comp.name &&
          binding.port.eContainer().eContainer().name === node.name) {
          alreadyBound = true;
          break;
        }
      }

      if (!alreadyBound) {
        binding = factory.createMBinding();
        binding.port = portInst;
        binding.hub  = chanInst;
        model.addMBindings(binding);
      }
    } else {
      // seems like you are trying to connect a port that do not belong to the comp you referred to
      return cb(new Error('Unable to find port "'+portName+'" in component '+comp.typeDefinition.name+'['+comp.name+'] (bind '+port.toString()+' '+chan.toString()+')'));
    }
  }

  function addBinding1(portName, compName, node, chanInst) {
    var comp = node.findComponentsByID(compName);
    if (comp) {
      if (portName === '*') {
        var inputRefs = comp.typeDefinition.provided.iterator();
        while (inputRefs.hasNext()) {
          addBinding2(inputRefs.next().name, comp, node, chanInst);
        }
        var outputRefs = comp.typeDefinition.required.iterator();
        while (outputRefs.hasNext()) {
          addBinding2(outputRefs.next().name, comp, node, chanInst);
        }

      } else {
        addBinding2(portName, comp, node, chanInst);
      }
    } else {
      return cb(new Error('Unable to find component instance "'+compName+'" in node "'+node.name+'" (bind '+port.toString()+' '+chan.toString()+')'));
    }
  }

  function addBinding0(portName, compName, nodeName, chanInst) {
    var node = model.findNodesByID(nodeName);
    if (node) {
      if (compName === '*') {
        var compz = node.components.iterator();
        while (compz.hasNext()) {
          addBinding1(portName, compz.next().name, node, chanInst);
        }

      } else {
        addBinding1(portName, compName, node, chanInst);
      }
    } else {
      return cb(new Error('Unable to find node instance "'+nodeName+'" in model (bind '+port.toString()+' '+chan.toString()+')'));
    }
  }

  function bindPortToChan(chanInst) {
    port.expect(3, 4, function (err, namespace, nodeName, compName, portName) {
      if (err) {
        err.message += ' (bind '+port.toString()+' '+chan.toString()+')';
        return cb(err);
      }

      if (namespace) {
        // TODO
        return cb(new Error('Namespaces are not handled yet :/ Sorry (bind '+port.toString()+' '+chan.toString()+')'));

      } else {
        if (nodeName === '*') {
          var nodes = model.nodes.iterator();
          while (nodes.hasNext()) {
            addBinding0(portName, compName, nodes.next().name, chanInst);
          }

        } else {
          addBinding0(portName, compName, nodeName, chanInst);
        }
      }
    });
  }

  chan.expect(1, 2, function (err, namespace, name) {
    if (err) {
      err.message += ' (bind '+port.toString()+' '+chan.toString()+')';
      return cb(err);
    }

    if (namespace) {
      // TODO
      return cb(new Error('Namespaces are not handled yet :/ Sorry (bind '+port.toString()+' '+chan.toString()+')'));

    } else {
      if (name === '*') {
        var chanz = model.hubs.iterator();
        while (chanz.hasNext()) {
          bindPortToChan(chanz.next());
        }

      } else {
        var chanInst = model.findHubsByID(name);
        if (chanInst) {
          bindPortToChan(chanInst);

        } else {
          return cb(new Error('Unable to find target channel instance "'+name+'" (bind '+port.toString()+' '+chan.toString()+')'));
        }
      }
    }
  });

  cb();
}
},{"kevoree-library":35}],8:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts, cb) {
  console.log("Not implemented yet");
}
},{}],9:[function(require,module,exports){
module.exports = function (model, statements, stmt) {
  return stmt.children.join('');
}
},{}],10:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts, cb) {
  var nameList = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
  var target   = statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);

  function addNodeToGroup(group) {
    for (var i=0; i < nameList.length; i++) {
      nameList[i].expect(1, 2, function (err, namespace, nodeName) {
        if (err) {
          err.message += ' (attach '+nameList.toString()+' '+target.toString()+')';
          return cb(err);
        }

        if (namespace) {
          // TODO
          return cb(new Error('Namespaces are not handled yet :/ Sorry (attach '+nameList.toString()+' '+target.toString()+')'));

        } else {
          if (nodeName === '*') {
            // attach all nodes to group
            var nodes = model.nodes.iterator();
            while (nodes.hasNext()) group.addSubNodes(nodes.next());

          } else {
            var node = model.findNodesByID(nodeName);
            if (node) {
              group.addSubNodes(node);
            } else {
              return cb(new Error('Unable to find node "'+nodeName+'" in model (attach '+nameList.toString()+' '+target.toString()+')'));
            }
          }
        }
      });
    }
  }

  target.expect(1, 2, function (err, namespace, name) {
    if (err) {
      err.message += ' (attach '+nameList.toString()+' '+target.toString()+')';
      return cb(err);
    }

    if (namespace) {
      // TODO
      return cb(new Error('Namespaces are not handled yet :/ Sorry (attach '+nameList.toString()+' '+target.toString()+')'));

    } else {
      if (name === '*') {
        var groups = model.groups.iterator();
        while (groups.hasNext()) addNodeToGroup(groups.next());

      } else {
        var group = model.findGroupsByID(name);
        if (group) {
          addNodeToGroup(group);

        } else {
          return cb(new Error('Unable to find group "'+name+'" in model (attach '+nameList.toString()+' '+target.toString()+')'));
        }
      }
    }
  });

  cb();
}
},{}],11:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts, cb) {
  var port = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
  var chan = statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);

  function unbindPortFromChan2(portName, comp, node, chanName) {
    var bindings = model.mBindings.iterator();
    while (bindings.hasNext()) {
      var binding = bindings.next();
      if (binding.port.portTypeRef.name === portName &&              // binding's port matches portName
        binding.port.eContainer().name === comp.name &&              // port's component matches comp.name
        binding.port.eContainer().eContainer().name === node.name && // component's container matches node.name
        binding.hub.name === chanName) {                             // binding's hub name matches chanName
        model.removeMBindings(binding);
      }
    }
  }

  function unbindPortFromChan1(portName, comp, node, chanName) {
    if (portName === '*') {
      var inputRefs = comp.typeDefinition.provided.iterator();
      var outputRefs = comp.typeDefinition.required.iterator();

      while (inputRefs.hasNext()) {
        unbindPortFromChan2(inputRefs.next().name, comp, node, chanName);
      }

      while (outputRefs.hasNext()) {
        unbindPortFromChan2(outputRefs.next().name, comp, node, chanName);
      }

    } else {
      unbindPortFromChan2(portName, comp, node, chanName);
    }
  }

  function unbindPortFromChan0(portName, compName, node, chanName) {
    if (compName === '*') {
      var compz = node.components.iterator();
      while (compz.hasNext()) {
        unbindPortFromChan1(portName, compz.next(), node, chanName);
      }

    } else {
      var comp = node.findComponentsByID(compName);
      if (comp) {
        unbindPortFromChan1(portName, comp, node, chanName);
      } else {
        return cb(new Error('Unable to find component instance "'+compName+'" in node instance "'+node.name+'" (unbind '+port.toString()+' '+chan.toString()+')'));
      }
    }
  }

  function preUnbindProcess(chanInst) {
    port.expect(3, 4, function (err, namespace, nodeName, compName, portName) {
      if (err) {
        err.message += ' (unbind '+port.toString()+' '+chan.toString()+')';
        return cb(err);
      }

      if (namespace) {
        // TODO
        return cb(new Error('Namespaces are not handled yet :/ Sorry (unbind '+port.toString()+' '+chan.toString()+')'));

      } else {
        if (nodeName === '*') {
          var nodes = model.nodes.iterator();
          while (nodes.hasNext()) {
            unbindPortFromChan0(portName, compName, nodes.next(), chanInst.name);
          }

        } else {
          var node = model.findNodesByID(nodeName);
          if (node) {
            unbindPortFromChan0(portName, compName, node, chanInst.name);
          } else {
            return cb(new Error('Unable to find node instance "'+nodeName+'" in model (unbind '+port.toString()+' '+chan.toString()+')'));
          }
        }
      }
    });
  }

  chan.expect(1, 2, function (err, namespace, name) {
    if (err) {
      err.message += ' (unbind '+port.toString()+' '+chan.toString()+')';
      return cb(err);
    }

    if (namespace) {
      // TODO
      return cb(new Error('Namespaces are not handled yet :/ Sorry (unbind '+port.toString()+' '+chan.toString()+')'));

    } else {
      if (name === '*') {
        var chanz = model.hubs.iterator();
        while (chanz.hasNext()) {
          preUnbindProcess(chanz.next());
        }

      } else {
        var chanInst = model.findHubsByID(name);
        if (chanInst) {
          preUnbindProcess(chanInst);
        } else {
          return cb(new Error('Unable to find channel instance "'+name+'" in model (unbind '+port.toString()+' '+chan.toString()+')'));
        }
      }
    }
  });

  cb();
}
},{}],12:[function(require,module,exports){
var kevoree = require('kevoree-library').org.kevoree;
var factory = kevoree.impl.DefaultKevoreeFactory();

module.exports = function (model, statements, stmt, opts, cb) {
  var names = [];
  var group = null;
  var target = stmt.children[1].children.join('');

  if (stmt.children[0].type == 'nameList') {
    var nodeList = stmt.children[0].children;
    for (var i in nodeList) {
      names.push(nodeList[i].children.join(''));
    }

  } else if (stmt.children[0] == '*') {
    group = model.findGroupsByID(target);
    if (typeof(group) != 'undefined') {
      var nodes = group.subNodes.iterator();
      while (nodes.hasNext()) names.push(nodes.next().name);
    } else {
      return cb(new Error('Unable to find group instance "'+target+'" in current model. (detach * '+target+')'));
    }
  } else {
    names.push(stmt.children[0].children.join(''));
  }

  for (var i in names) {
    group = model.findGroupsByID(target);
    if (typeof(group) != 'undefined') {
      var node = model.findNodesByID(names[i]);
      if (typeof(node) != 'undefined') {
        group.removeSubNodes(node);
      }
    }
  }

  cb();
}
},{"kevoree-library":35}],13:[function(require,module,exports){
var kevoree = require('kevoree-library').org.kevoree;
var path = require('path');

var factory = new kevoree.impl.DefaultKevoreeFactory();
var compare = new kevoree.compare.DefaultModelCompare();

module.exports = function (model, statements, stmt, opts, cb) {
  if (!opts.resolvers) {
    // if "cb" is undefined, then  there is no "opts" parameter given, so no resolver, so :/
    return opts(new Error('You must give resolvers as options to "include.js" statement processor'));
  }

  if (!opts.resolvers) return cb(new Error('Unable to process include. No resolver given'));

  var du = factory.createDeployUnit();
  var type = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
  var mergeDef = statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);

  if (type == 'npm' && opts.resolvers.npm) {
    var colon = mergeDef.split(':');
    var arobas = mergeDef.split('@');
    if (colon.length == 1 && arobas.length == 1) {
      du.name = mergeDef;
    } else if (colon.length == 1 && arobas.length == 2) {
      du.name = arobas[0];
      du.version = arobas[1];
    } else if (colon.length == 2 && arobas.length == 1) {
      du.name = colon[0];
      du.version = colon[1];
    } else {
      return cb(new Error('Unable to parse include statement "'+mergeDef+'"'));
    }

    opts.resolvers.npm.resolve(du, function (err, Clazz, duModel) {
      if (err) return cb(err);

      var loader = new kevoree.loader.JSONModelLoader();
      var serializer = new kevoree.serializer.JSONModelSerializer();

      var tmp = loader.loadModelFromString(serializer.serialize(duModel)).get(0);
      var mergeSeq = compare.merge(model, tmp);
      mergeSeq.applyOn(model);
      return cb();
    });

  } else if (type == 'file' && opts.resolvers.file) {
    var pkg = require(path.resolve(mergeDef, 'package.json'));
    du.name = pkg.name;
    du.version = pkg.version;
    du.type = 'file';
    du.url = mergeDef;
    opts.resolvers.file.resolve(du, function (err, Clazz, duModel) {
      var loader = new kevoree.loader.JSONModelLoader();
      var serializer = new kevoree.serializer.JSONModelSerializer();

      var tmp = loader.loadModelFromString(serializer.serialize(duModel)).get(0);
      var mergeSeq = compare.merge(model, tmp);
      mergeSeq.applyOn(model);
      var dus = model.deployUnits.iterator();
      while (dus.hasNext()) {
        var deployUnit = dus.next();
        if (deployUnit.name == du.name) {
          deployUnit.type = 'file';
          deployUnit.url = mergeDef;
        }
      }
      return cb();
    });

  } else {
    // TODO handle mvn type and others
    console.log('Ignored: include '+type+':'+mergeDef+' (Unable to handle "'+type+'" include type yet. Sorry :/)');
    cb();
  }
}
},{"kevoree-library":35,"path":30}],14:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts, cb) {
  var instancePath = [];
  for (var i in stmt.children) {
    instancePath.push(statements[stmt.children[i].type](model, statements, stmt.children[i], opts, cb));
  }

  return {
    expect: function (min, max, callback) {
      if (instancePath.length > max || instancePath.length < min) {
        return callback(new Error('InstancePath does not match requirements (path: '+instancePath.join('.')+', length: '+instancePath.length+', min: '+min+', max: '+max+')'));
      }

      instancePath.unshift(null); // prepend null error value to params array
      // nullify missing value in path (ex: 'a.b.c' with expect(2, 4, function (err, one, two, three, four) { }
      // will nullify 'one' and shift values so you get two => a, three => b and four => c
      for (var i=instancePath.length-1; i < max; i++) instancePath.unshift(null);
      return callback.apply(null, instancePath);
    },
    toString:   function () { return instancePath.join('.'); }
  };
}
},{}],15:[function(require,module,exports){
var Kotlin = require('kevoree-kotlin');
var kevoree = require('kevoree-library').org.kevoree;

module.exports = function (model, statements, stmt, opts, cb) {
  // instances to move
  var nameList = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
  // target node to move instances to
  var target   = statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);

  function processNameList(targetNode) {
    for (var i in nameList) {
      nameList[i].expect(2, 3, function (err, namespace, nodeName, compName) {
        if (err) {
          err.message += ' (move '+nameList.toString()+' '+target.toString()+')';
          return cb(err);
        }

        if (namespace) {
          // TODO
          return cb(new Error('Namespaces are not handled yet :/ Sorry (move '+nameList.toString()+' '+target.toString()+')'));

        } else {
          if (nodeName === '*') {
            if (compName === '*') {
              // move *.* fooNode
              var nodes = model.nodes.iterator();
              while (nodes.hasNext()) {
                var fromNode = nodes.next();
                var comps = fromNode.components.iterator();
                while (comps.hasNext()) {
                  var comp = comps.next();
                  fromNode.removeComponents(comp);
                  targetNode.addComponents(comp);
                }
              }

            } else {
              // move *.fooComp fooNode
              var nodes = model.nodes.iterator();
              while (nodes.hasNext()) {
                var fromNode = nodes.next();
                var comp = fromNode.findComponentsByID(compName);
                if (comp) {
                  fromNode.removeComponents(comp);
                  targetNode.addComponents(comp);
                }
              }
            }

          } else {
            if (compName === '*') {
              // move fooNode.* barNode
              var fromNode = model.findNodesByID(nodeName);
              if (fromNode) {
                var comps = fromNode.components.iterator();
                while (comps.hasNext()) {
                  var comp = comps.next();
                  fromNode.removeComponents(comp);
                  targetNode.addComponents(comp);
                }

              } else {
                return cb(new Error('Unable to find node "'+nodeName+'" in model (move '+nameList.toString()+' '+target.toString()+')'));
              }

            } else {
              // move fooNode.fooComp barNode
              var node = model.findNodesByID(nodeName);
              if (node) {
                var comp = node.findComponentsByID(compName);
                if (comp) {
                  node.removeComponents(comp);
                  targetNode.addComponents(comp);
                }

              } else {
                return cb(new Error('Unable to find node "'+nodeName+'" in model (move '+nameList.toString()+' '+target.toString()+')'));
              }
            }
          }
        }
      });
    }
  }

  // process target instancePath
  target.expect(1, 2, function (err, namespace, name) {
    if (err) {
      err.message += ' (move '+nameList.toString()+' '+target.toString()+')';
      return cb(err);
    }

    if (namespace) {
      // TODO
      return cb(new Error('Namespaces are not handled yet :/ Sorry (move '+nameList.toString()+' '+target.toString()+')'));
//      if (opts.namespaces[namespace]) {
//        var instance = opts.namespaces[namespace][name];
//        if (Kotlin.isType(instance.typeDefinition, kevoree.impl.NodeTypeImpl)) {
//          // target node exists
//          processNameList(instance);
//
//        } else {
//          return cb(new Error('Matched entity in namespace "'+[namespace, name].join('.')+'" must be a NodeType.'));
//        }
//
//      } else {
//        return cb(new Error('Unable to find namespace "'+namespace+'"'));
//      }

    } else {
      if (name === '*') {
        return cb(new Error('You must specify one and only node target (move '+nameList.toString()+' '+target.toString()+')'));

      } else {
        // check if the target exists
        var targetNode = model.findNodesByID(name);
        if (targetNode) {
          // target node exists
          processNameList(targetNode);

        } else {
          // node does not exist in current model
          return cb(new Error('Unable to find target node "'+target.toString()+'" in current model (move '+nameList.toString()+' '+target.toString()+')'));
        }
      }
    }
  });

  cb();
}
},{"kevoree-kotlin":33,"kevoree-library":35}],16:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts, cb) {
  var ret = [];
  for (var i in stmt.children) {
    ret.push(statements[stmt.children[i].type](model, statements, stmt.children[i], opts, cb));
  }
  return ret;
}
},{}],17:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts, cb) {
  opts.namespaces = opts.namespaces || {};
  var name = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
  opts.namespaces[name] = [];
}
},{}],18:[function(require,module,exports){
var kevoree = require('kevoree-library').org.kevoree;
var factory = new kevoree.impl.DefaultKevoreeFactory();

module.exports = function (model, statements, stmt, opts, cb) {
  var nodePath  = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
  var value = statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);

  nodePath.expect(1, 2, function (err, namespace, name) {
    if (err) {
      err.message += ' (network '+nodePath.toString()+' '+value+')';
      return cb(err);
    }

    if (namespace) {
      // TODO
      return cb(new Error('Namespaces are not handled yet :/ Sorry (network '+nodePath.toString()+' '+value+')'));

    } else {
      if (nodePath === '*') {

      } else {
        var node = model.findNodesByID(name);
        if (node) {
          var net = factory.createNodeNetwork();
          net.target = node;
          net.initBy = node;
          var link = factory.createNodeLink();
          link.networkType = 'ip';
          link.estimatedRate = 99;
          net.addLink(link);
          var prop = factory.createNetworkProperty();
          prop.name = 'ip';
          prop.value = value;
          link.addNetworkProperties(prop);
          model.addNodeNetworks(net);

        } else {
          return cb(new Error('Unable to find node instance "'+name+'" in model (network '+nodePath.toString()+' '+value+')'));
        }
      }
    }
  });

  cb();
}
},{"kevoree-library":35}],19:[function(require,module,exports){
var kevoree = require('kevoree-library').org.kevoree;
var Kotlin = require('kevoree-kotlin');
var factory = kevoree.impl.DefaultKevoreeFactory();
var helper = require('../model-helper');

module.exports = function (model, statements, stmt, opts, cb) {
  var nameList = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);

  function doRemove1(nodeName, third) {
    var node = model.findNodesByID(nodeName);
    if (node) {
      if (third === '*') {
        // remove all components within this node
        var compz = node.components.iterator();
        while (compz.hasNext()) doRemove(compz.next());

      } else {
        var comp = node.findComponentsByID(third);
        if (comp) {
          doRemove(comp);
        } else {
          return cb(new Error('Unable to find component instance "'+third+'" in node instance "'+nodeName+'" in model (remove '+nameList.toString()+')'));
        }
      }
    } else {
      return cb(new Error('Unable to find node instance "'+nodeName+'" in model (remove '+nameList.toString()+')'));
    }
  }

  function doRemove(instance) {
    if (Kotlin.isType(instance.typeDefinition, kevoree.impl.NodeTypeImpl)) {
      var groups = model.groups.iterator();
      while (groups.hasNext()) {
        var group = groups.next();
        var subNodes = group.subNodes.iterator()
        while (subNodes.hasNext()) {
          if (subNodes.next().name == instance.name) group.removeSubNodes(instance);
        }
        var dics = group.fragmentDictionary.iterator();
        while (dics.hasNext()) {
          var dic = dics.next();
          if (dic.name === instance.name) {
            group.removeFragmentDictionary(dic);
          }
        }
      }
      var networks = model.nodeNetworks.iterator();
      while (networks.hasNext()) {
        var net = networks.next();
        if (net.target.name === instance.name) {
          model.removeNodeNetworks(net);
        }
      }
      model.removeNodes(instance);

    } else if (Kotlin.isType(instance.typeDefinition, kevoree.impl.GroupTypeImpl)) {
      model.removeGroups(instance);
    } else if (Kotlin.isType(instance.typeDefinition, kevoree.impl.ChannelTypeImpl)) {
      var bindings = model.mBindings.iterator();
      while (bindings.hasNext()) {
        var binding = bindings.next();
        if (binding.hub.name === instance.name) {
          model.removeMBindings(binding);
        }
      }
      model.removeHubs(instance);
    } else if (Kotlin.isType(instance.typeDefinition, kevoree.impl.ComponentTypeImpl)) {
      instance.eContainer().removeComponents(instance);
    } else {
      return cb(new Error('Unable to remove instance "'+names[i]+'" from current model. (Are you sure it is a node, group, chan, component?)'));
    }
  }

  for (var i in nameList) {
    nameList[i].expect(1, 3, function (err, first, second, third) {
      if (err) {
        err.message = ' (remove '+nameList.toString()+')';
        return cb(err);
      }

      if (first) {
        // TODO there is at least 3 parts in path so it must refer to a namespace 'first.second.third'
        return cb(new Error('Namespaces are not handled yet :/ Sorry (remove '+nameList.toString()+')'));

      } else {
        if (second) {
          // two parts path: 'second.third'
          if (second === '*') {
            var nodes = model.nodes.iterator();
            while (nodes.hasNext()) doRemove1(nodes.next().name, third);
          } else {
            doRemove1(second, third);
          }
        } else {
          // one part path: 'third'
          if (third === '*') {
            var nodes = model.nodes.iterator();
            var groups = model.groups.iterator();
            var hubs = model.hubs.iterator();

            while (nodes.hasNext())  doRemove(nodes.next());
            while (groups.hasNext()) doRemove(groups.next());
            while (hubs.hasNext())   doRemove(hubs.next());

          } else {
            var instance = helper.findEntityByName(model, third);
            if (instance)
              doRemove(instance);
            else
              return cb(new Error('Unable to find instance "'+third+'" in model (remove '+nameList.toString()+')'));
          }
        }
      }
    });
  }

  var names = [];

  if (stmt.children[0].type == 'nameList') {
    for (var i in stmt.children[0].children) {
      names.push(stmt.children[0].children[i].children.join(''));
    }
  } else {
    names.push(stmt.children[0].children.join(''));
  }

  for (var i in names) {
    var entity = helper.findEntityByName(model, names[i]);
    if (entity != null) {
      if (Kotlin.isType(entity.typeDefinition, kevoree.impl.NodeTypeImpl)) {
        var groups = (model.groups) ? model.groups.iterator() : null;
        if (groups != null) {
          while (groups.hasNext()) {
            var group = groups.next();
            var subNodes = group.subNodes.iterator()
            while (subNodes.hasNext()) {
              if (subNodes.next().name == entity.name) group.removeSubNodes(entity);
            }
            var values = group.dictionary.values.iterator();
            while (values.hasNext()) {
              var val = values.next();
              if (val.targetNode.name == entity.name) group.dictionary.removeValues(val);
            }
          }
        }
        model.removeNodes(entity);

      } else if (Kotlin.isType(entity.typeDefinition, kevoree.impl.GroupTypeImpl)) {
        model.removeGroups(entity);
      } else if (Kotlin.isType(entity.typeDefinition, kevoree.impl.ChannelTypeImpl)) {
        model.removeHubs(entity);
      } else if (Kotlin.isType(entity.typeDefinition, kevoree.impl.ComponentTypeImpl)) {
        entity.eContainer().removeComponents(entity);
      } else {
        return cb(new Error('Unable to remove instance "'+names[i]+'" from current model. (Are you sure it is a node, group, chan, component?)'));
      }
    }
  }

  cb();
}
},{"../model-helper":4,"kevoree-kotlin":33,"kevoree-library":35}],20:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts) {
  return stmt.children.join('');
}
},{}],21:[function(require,module,exports){
var kevoree = require('kevoree-library').org.kevoree;
var factory = new kevoree.impl.DefaultKevoreeFactory();
var helper  = require('../model-helper');

module.exports = function (model, statements, stmt, opts, cb) {
  var attr, node, value;
  if (stmt.children.length === 2) {
    attr  = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
    value = statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);

  } else if (stmt.children.length === 3) {
    attr  = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
    node  = statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);
    value = statements[stmt.children[2].type](model, statements, stmt.children[2], opts, cb);
  }

  function setAttribute2(attrName, dictionary) {
    var dicValue = dictionary.findValuesByID(attrName);
    if (dicValue) {
      // dictionary value for attribute named attrName already exists: overwrite it
      dicValue.value = value;

    } else {
      // dictionary value for attribute named attrName does not exist yet: create it and add it if possible
      var attrs = dictionary.eContainer().typeDefinition.dictionaryType.attributes.iterator();
      while (attrs.hasNext()) {
        // by doing this, we will kinda fail silently if you are trying to set an inexisting
        // attribute value in one of the instances
        if (attrs.next().name === attrName) {
          dicValue = factory.createDictionaryValue();
          dicValue.name = attrName;
          dicValue.value = value;
          dictionary.addValues(dicValue);
          break;
        }
      }
    }
  }

  function setAttribute1(attrName, instance) {
    if (node) {
      // fragDep attribute
      node.expect(1, 2, function (err, namespace, nodeName) {
        if (err) {
          err.message += ' (set '+attr.toString()+'/'+node.toString()+' = '+value+')';
          return cb(err);
        }

        if (namespace) {
          // TODO
          return cb(new Error('Namespaces are not handled yet :/ Sorry (set '+attr.toString()+'/'+node.toString()+' = '+value+')'));

        } else {
          if (nodeName === '*') {
            var dics = instance.fragmentDictionary.iterator();
            while (dics.hasNext()) setAttribute2(attrName, dics.next());

          } else {
            var fragDic = instance.findFragmentDictionaryByID(nodeName);
            if (fragDic) {
              setAttribute2(attrName, fragDic);
            } else {
              // fragment dictionary needs to be created and added
              fragDic = factory.createFragmentDictionary();
              fragDic.name = nodeName;
              instance.addFragmentDictionary(fragDic);
              setAttribute2(attrName, fragDic);
            }
          }
        }
      });

    } else {
      // non fragDep attribute
      if (!instance.dictionary) instance.dictionary = factory.createDictionary();
      setAttribute2(attrName, instance.dictionary);
    }
  }

  function setAttribute0(attrName, instance) {
    if (attrName === '*') {
      var attrs = instance.typeDefinition.dictionaryType.attributes.iterator();
      while (attrs.hasNext()) {
        setAttribute1(attrs.next().name, instance);
      }

    } else {
      setAttribute1(attrName, instance);
    }
  }

  attr.expect(2, 3, function (err, namespace, instanceName, attrName) {
    if (err) {
      err.message += ' (set '+attr.toString()+((node) ? '/'+node.toString() : '')+' = '+value+')';
      return cb(err);
    }

    if (namespace) {
      // TODO
      return cb(new Error('Namespaces are not handled yet :/ Sorry (set '+attr.toString()+((node) ? '/'+node.toString() : '')+' = '+value+')'));

    } else {
      if (instanceName === '*') {
        var groups = model.groups.iterator();
        while (groups.hasNext()) setAttribute0(attrName, groups.next());

        var chans = model.hubs.iterator();
        while (chans.hasNext()) setAttribute0(attrName, chans.next());

        var nodes = model.nodes.iterator();
        while (nodes.hasNext()) {
          var node = nodes.next();
          setAttribute0(attrName, node);

          var comps = node.components.iterator();
          while (comps.hasNext()) setAttribute0(attrName, comps.next());
        }

      } else {
        var instance = helper.findEntityByName(model, instanceName);
        if (instance) {
          setAttribute0(attrName, instance);
        } else {
          return cb(new Error('Unable to find instance "'+instanceName+'" in model (set '+attr.toString()+((node) ? '/'+node.toString() : '')+' = '+value+')'));
        }
      }
    }
  });

  cb();
}
},{"../model-helper":4,"kevoree-library":35}],22:[function(require,module,exports){
module.exports=require(20)
},{}],23:[function(require,module,exports){
module.exports=require(20)
},{}],24:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts, cb) {
  var name = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);

  if (stmt.children[1]) {
    return name + '/' + statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);
  } else {
    return name;
  }
}
},{}],25:[function(require,module,exports){
module.exports=require(9)
},{}],26:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts, cb) {
  return stmt.children.join('');
}
},{}],27:[function(require,module,exports){
var waxeye;
/*
# Waxeye Parser Generator
# www.waxeye.org
# Copyright (C) 2008-2010 Orlando Hill
# Licensed under the MIT license. See 'LICENSE' for details.
*/
waxeye = (function() {
  var AST, Edge, FA, InnerParser, ParseError, State, WaxeyeParser, namespace;
  Edge = function(_a, _b, _c) {
    this.voided = _c;
    this.state = _b;
    this.trans = _a;
    return this;
  };
  State = function(_a, _b) {
    this.match = _b;
    this.edges = _a;
    return this;
  };
  FA = function(_a, _b, _c) {
    this.mode = _c;
    this.states = _b;
    this.type = _a;
    return this;
  };
  FA.VOID = 0;
  FA.PRUNE = 1;
  FA.LEFT = 2;
  FA.POS = 3;
  FA.NEG = 4;
  ParseError = function(_a, _b, _c, _d) {
    this.nt = _d;
    this.col = _c;
    this.line = _b;
    this.pos = _a;
    return this;
  };
  ParseError.prototype.toString = function() {
    return "parse error: failed to match '" + this.nt + "' at line=" + this.line + ", col=" + this.col + ", pos=" + this.pos;
  };
  AST = function(_a, _b, _c) {
    this.pos = _c;
    this.children = _b;
    this.type = _a;
    return this;
  };
  AST.prototype.toString = function() {
    var acc, indent, toStringIter;
    acc = "";
    indent = 0;
    toStringIter = function(ast) {
      var _a, _b, _c, a, i;
      i = 0;
      while (i < indent - 1) {
        acc += '    ';
        i++;
      }
      indent > 0 ? acc += '->  ' : null;
      acc += ast.type;
      indent++;
      _b = ast.children;
      for (_a = 0, _c = _b.length; _a < _c; _a++) {
        a = _b[_a];
        acc += '\n';
        if ((typeof a) === 'string') {
          i = 0;
          while (i < indent - 1) {
            acc += '    ';
            i++;
          }
          indent > 0 ? acc += '|   ' : null;
          acc += a;
        } else {
          toStringIter(a);
        }
      }
      indent--;
      return acc;
    };
    return toStringIter(this);
  };
  WaxeyeParser = function(_a, _b, _c) {
    this.automata = _c;
    this.eofCheck = _b;
    this.start = _a;
    return this;
  };
  WaxeyeParser.prototype.parse = function(input) {
    return new InnerParser(this.start, this.eofCheck, this.automata, input).parse();
  };
  InnerParser = function(_a, _b, _c, input) {
    this.automata = _c;
    this.eofCheck = _b;
    this.start = _a;
    this.input = input;
    this.inputLen = input.length;
    this.inputPos = 0;
    this.line = 1;
    this.column = 0;
    this.lastCR = false;
    this.errorPos = 0;
    this.errorLine = 1;
    this.errorCol = 0;
    this.errorNT = this.automata[this.start].type;
    this.faStack = [];
    this.cache = {};
    return this;
  };
  InnerParser.prototype.parse = function() {
    return this.doEOFCheck(this.matchAutomaton(this.start));
  };
  InnerParser.prototype.matchAutomaton = function(index) {
    var _a, automaton, cached, key, mode, res, startCR, startCol, startLine, startPos, type, value;
    startPos = this.inputPos;
    key = ("" + index + "," + startPos);
    cached = this.cache[key];
    if (typeof cached !== "undefined" && cached !== null) {
      this.restorePos(cached[1], cached[2], cached[3], cached[4]);
      return cached[0];
    }
    startLine = this.line;
    startCol = this.column;
    startCR = this.lastCR;
    automaton = this.automata[index];
    type = automaton.type;
    mode = automaton.mode;
    this.faStack.push(automaton);
    res = this.matchState(0);
    this.faStack.pop();
    value = (function() {
      if (mode === FA.POS) {
        this.restorePos(startPos, startLine, startCol, startCR);
        if (res) {
          return true;
        } else {
          this.updateError();
          return false;
        }
      } else if (mode === FA.NEG) {
        this.restorePos(startPos, startLine, startCol, startCR);
        if (res) {
          this.updateError();
          return false;
        } else {
          return true;
        }
      } else {
        if (res) {
          if (mode === FA.VOID) {
            return true;
          } else if (mode === FA.PRUNE) {
            if ((_a = res.length) === 0) {
              return true;
            } else if (_a === 1) {
              return res[0];
            } else {
              return new AST(type, res, [startPos, this.inputPos]);
            }
          } else {
            return new AST(type, res, [startPos, this.inputPos]);
          }
        } else {
          return this.updateError();
        }
      }
    }).call(this);
    this.cache[key] = [value, this.inputPos, this.line, this.column, this.lastCR];
    return value;
  };
  InnerParser.prototype.matchState = function(index) {
    var res, state;
    state = this.faStack[this.faStack.length - 1].states[index];
    res = this.matchEdges(state.edges, 0);
    return res ? res : state.match && [];
  };
  InnerParser.prototype.matchEdges = function(edges, index) {
    var res;
    if (index === edges.length) {
      return false;
    } else {
      res = this.matchEdge(edges[index]);
      return res ? res : this.matchEdges(edges, (index + 1));
    }
  };
  InnerParser.prototype.matchEdge = function(edge) {
    var res, startCR, startCol, startLine, startPos, t, tranRes;
    startPos = this.inputPos;
    startLine = this.line;
    startCol = this.column;
    startCR = this.lastCR;
    t = edge.trans;
    res = t === -1 ? this.inputPos < this.inputLen ? this.mv() : this.updateError() : typeof t === 'string' ? this.inputPos < this.inputLen && t === this.input[this.inputPos] ? this.mv() : this.updateError() : t instanceof Array ? this.inputPos < this.inputLen && this.withinSet(t, 0, (this.input[this.inputPos].charCodeAt(0))) ? this.mv() : this.updateError() : typeof t === 'number' ? this.matchAutomaton(t) : false;
    if (res) {
      tranRes = this.matchState(edge.state);
      if (tranRes) {
        return edge.voided || res === true ? tranRes : [res].concat(tranRes);
      } else {
        this.restorePos(startPos, startLine, startCol, startCR);
        return false;
      }
    } else {
      return false;
    }
  };
  InnerParser.prototype.restorePos = function(pos, line, col, cr) {
    this.inputPos = pos;
    this.line = line;
    this.column = col;
    return (this.lastCR = cr);
  };
  InnerParser.prototype.updateError = function() {
    if (this.errorPos < this.inputPos) {
      this.errorPos = this.inputPos;
      this.errorLine = this.line;
      this.errorCol = this.column;
      this.errorNT = this.faStack[this.faStack.length - 1].type;
    }
    return false;
  };
  InnerParser.prototype.mv = function() {
    var ch;
    ch = this.input[this.inputPos];
    this.inputPos++;
    if (ch === '\r') {
      this.line++;
      this.column = 0;
      this.lastCR = true;
    } else {
      if (ch === '\n') {
        if (!this.lastCR) {
          this.line++;
          this.column = 0;
        }
      } else {
        this.column++;
      }
      this.lastCR = false;
    }
    return ch;
  };
  InnerParser.prototype.doEOFCheck = function(res) {
    return res ? this.eofCheck && this.inputPos < this.inputLen ? new ParseError(this.errorPos, this.errorLine, this.errorCol, this.errorNT) : res : new ParseError(this.errorPos, this.errorLine, this.errorCol, this.errorNT);
  };
  InnerParser.prototype.withinSet = function(set, index, c) {
    var aa;
    if (index === set.length) {
      return false;
    } else {
      aa = set[index];
      return typeof aa === 'string' ? (aa.charCodeAt(0)) === c ? true : (aa.charCodeAt(0)) < c ? this.withinSet(set, index + 1, c) : false : c >= aa[0] && c <= aa[1] ? true : c > aa[1] ? this.withinSet(set, index + 1, c) : false;
    }
  };
  namespace = {
    Edge: Edge,
    State: State,
    FA: FA,
    ParseError: ParseError,
    AST: AST,
    WaxeyeParser: WaxeyeParser
  };
  return namespace;
})();
if (typeof module !== "undefined" && module !== null) {
  module.exports.AST = waxeye.AST;
  module.exports.Edge = waxeye.Edge;
  module.exports.FA = waxeye.FA;
  module.exports.ParseError = waxeye.ParseError;
  module.exports.State = waxeye.State;
  module.exports.WaxeyeParser = waxeye.WaxeyeParser;
}
},{}],28:[function(require,module,exports){
var process=require("__browserify_process");/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = setImmediate;
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                }
            }));
        });
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (err, v) {
                results[x.index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        if (!keys.length) {
            return callback(null);
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (_keys(results).length === keys.length) {
                callback(null, results);
                callback = function () {};
            }
        });

        _each(keys, function (k) {
            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor !== Array) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (test()) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (!test()) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if(data.constructor !== Array) {
              data = [data];
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            }
        };
        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
                if(data.constructor !== Array) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain) cargo.drain();
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                callback.apply(null, memo[key]);
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.compose = function (/* functions... */) {
        var fns = Array.prototype.reverse.call(arguments);
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // AMD / RequireJS
    if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // Node.js
    else if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

},{"__browserify_process":32}],29:[function(require,module,exports){


//
// The shims in this file are not fully implemented shims for the ES5
// features, but do work for the particular usecases there is in
// the other modules.
//

var toString = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

// Array.isArray is supported in IE9
function isArray(xs) {
  return toString.call(xs) === '[object Array]';
}
exports.isArray = typeof Array.isArray === 'function' ? Array.isArray : isArray;

// Array.prototype.indexOf is supported in IE9
exports.indexOf = function indexOf(xs, x) {
  if (xs.indexOf) return xs.indexOf(x);
  for (var i = 0; i < xs.length; i++) {
    if (x === xs[i]) return i;
  }
  return -1;
};

// Array.prototype.filter is supported in IE9
exports.filter = function filter(xs, fn) {
  if (xs.filter) return xs.filter(fn);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    if (fn(xs[i], i, xs)) res.push(xs[i]);
  }
  return res;
};

// Array.prototype.forEach is supported in IE9
exports.forEach = function forEach(xs, fn, self) {
  if (xs.forEach) return xs.forEach(fn, self);
  for (var i = 0; i < xs.length; i++) {
    fn.call(self, xs[i], i, xs);
  }
};

// Array.prototype.map is supported in IE9
exports.map = function map(xs, fn) {
  if (xs.map) return xs.map(fn);
  var out = new Array(xs.length);
  for (var i = 0; i < xs.length; i++) {
    out[i] = fn(xs[i], i, xs);
  }
  return out;
};

// Array.prototype.reduce is supported in IE9
exports.reduce = function reduce(array, callback, opt_initialValue) {
  if (array.reduce) return array.reduce(callback, opt_initialValue);
  var value, isValueSet = false;

  if (2 < arguments.length) {
    value = opt_initialValue;
    isValueSet = true;
  }
  for (var i = 0, l = array.length; l > i; ++i) {
    if (array.hasOwnProperty(i)) {
      if (isValueSet) {
        value = callback(value, array[i], i, array);
      }
      else {
        value = array[i];
        isValueSet = true;
      }
    }
  }

  return value;
};

// String.prototype.substr - negative index don't work in IE8
if ('ab'.substr(-1) !== 'b') {
  exports.substr = function (str, start, length) {
    // did we get a negative start, calculate how much it is from the beginning of the string
    if (start < 0) start = str.length + start;

    // call the original function
    return str.substr(start, length);
  };
} else {
  exports.substr = function (str, start, length) {
    return str.substr(start, length);
  };
}

// String.prototype.trim is supported in IE9
exports.trim = function (str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
};

// Function.prototype.bind is supported in IE9
exports.bind = function () {
  var args = Array.prototype.slice.call(arguments);
  var fn = args.shift();
  if (fn.bind) return fn.bind.apply(fn, args);
  var self = args.shift();
  return function () {
    fn.apply(self, args.concat([Array.prototype.slice.call(arguments)]));
  };
};

// Object.create is supported in IE9
function create(prototype, properties) {
  var object;
  if (prototype === null) {
    object = { '__proto__' : null };
  }
  else {
    if (typeof prototype !== 'object') {
      throw new TypeError(
        'typeof prototype[' + (typeof prototype) + '] != \'object\''
      );
    }
    var Type = function () {};
    Type.prototype = prototype;
    object = new Type();
    object.__proto__ = prototype;
  }
  if (typeof properties !== 'undefined' && Object.defineProperties) {
    Object.defineProperties(object, properties);
  }
  return object;
}
exports.create = typeof Object.create === 'function' ? Object.create : create;

// Object.keys and Object.getOwnPropertyNames is supported in IE9 however
// they do show a description and number property on Error objects
function notObject(object) {
  return ((typeof object != "object" && typeof object != "function") || object === null);
}

function keysShim(object) {
  if (notObject(object)) {
    throw new TypeError("Object.keys called on a non-object");
  }

  var result = [];
  for (var name in object) {
    if (hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// getOwnPropertyNames is almost the same as Object.keys one key feature
//  is that it returns hidden properties, since that can't be implemented,
//  this feature gets reduced so it just shows the length property on arrays
function propertyShim(object) {
  if (notObject(object)) {
    throw new TypeError("Object.getOwnPropertyNames called on a non-object");
  }

  var result = keysShim(object);
  if (exports.isArray(object) && exports.indexOf(object, 'length') === -1) {
    result.push('length');
  }
  return result;
}

var keys = typeof Object.keys === 'function' ? Object.keys : keysShim;
var getOwnPropertyNames = typeof Object.getOwnPropertyNames === 'function' ?
  Object.getOwnPropertyNames : propertyShim;

if (new Error().hasOwnProperty('description')) {
  var ERROR_PROPERTY_FILTER = function (obj, array) {
    if (toString.call(obj) === '[object Error]') {
      array = exports.filter(array, function (name) {
        return name !== 'description' && name !== 'number' && name !== 'message';
      });
    }
    return array;
  };

  exports.keys = function (object) {
    return ERROR_PROPERTY_FILTER(object, keys(object));
  };
  exports.getOwnPropertyNames = function (object) {
    return ERROR_PROPERTY_FILTER(object, getOwnPropertyNames(object));
  };
} else {
  exports.keys = keys;
  exports.getOwnPropertyNames = getOwnPropertyNames;
}

// Object.getOwnPropertyDescriptor - supported in IE8 but only on dom elements
function valueObject(value, key) {
  return { value: value[key] };
}

if (typeof Object.getOwnPropertyDescriptor === 'function') {
  try {
    Object.getOwnPropertyDescriptor({'a': 1}, 'a');
    exports.getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  } catch (e) {
    // IE8 dom element issue - use a try catch and default to valueObject
    exports.getOwnPropertyDescriptor = function (value, key) {
      try {
        return Object.getOwnPropertyDescriptor(value, key);
      } catch (e) {
        return valueObject(value, key);
      }
    };
  }
} else {
  exports.getOwnPropertyDescriptor = valueObject;
}

},{}],30:[function(require,module,exports){
var process=require("__browserify_process");// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util');
var shims = require('_shims');

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (!util.isString(path)) {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(shims.filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = shims.substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(shims.filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(shims.filter(paths, function(p, index) {
    if (!util.isString(p)) {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

},{"__browserify_process":32,"_shims":29,"util":31}],31:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var shims = require('_shims');

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  shims.forEach(array, function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = shims.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = shims.getOwnPropertyNames(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }

  shims.forEach(keys, function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = shims.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (shims.indexOf(ctx.seen, desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = shims.reduce(output, function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return shims.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) && objectToString(e) === '[object Error]';
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.binarySlice === 'function'
  ;
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = shims.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = shims.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

},{"_shims":29}],32:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],33:[function(require,module,exports){
module.exports = require('./lib/kotlin');

},{"./lib/kotlin":34}],34:[function(require,module,exports){
(function () {
  'use strict';

  if (!Array.isArray) {
    Array.isArray = function (vArg) {
      return Object.prototype.toString.call(vArg) === "[object Array]";
    };
  }

  if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {
      if (typeof this !== "function") {
        // closest thing possible to the ECMAScript 5 internal IsCallable function
        throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
      }

      var aArgs = Array.prototype.slice.call(arguments, 1),
        fToBind = this,
        fNOP = function () {
        },
        fBound = function () {
          return fToBind.apply(this instanceof fNOP && oThis
            ? this
            : oThis,
            aArgs.concat(Array.prototype.slice.call(arguments)));
        };

      fNOP.prototype = this.prototype;
      fBound.prototype = new fNOP();

      return fBound;
    };
  }

  if (!Object.keys) {
    Object.keys = function (o) {
      var result = [];
      var i = 0;
      for (var p in o) {
        if (o.hasOwnProperty(p)) {
          result[i++] = p;
        }
      }
      return result;
    };
  }

  if (!Object.create) {
    Object.create = function(proto) {
      function F() {}
      F.prototype = proto;
      return new F();
    }
  }

  // http://ejohn.org/blog/objectgetprototypeof/
  if ( typeof Object.getPrototypeOf !== "function" ) {
    if ( typeof "test".__proto__ === "object" ) {
      Object.getPrototypeOf = function(object){
        return object.__proto__;
      };
    } else {
      Object.getPrototypeOf = function(object){
        // May break if the constructor has been tampered with
        return object.constructor.prototype;
      };
    }
  }
})();

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

var Kotlin = {};

(function () {

  function toArray(obj) {
    var array;
    if (obj == null) {
      array = [];
    }
    else if(!Array.isArray(obj)) {
      array = [obj];
    }
    else {
      array = obj;
    }
    return array;
  }

  function copyProperties(to, from) {
    if (to == null || from == null) {
      return;
    }
    for (var p in from) {
      if (from.hasOwnProperty(p)) {
        to[p] = from[p];
      }
    }
  }

  function getClass(basesArray) {
    for (var i = 0; i < basesArray.length; i++) {
      if (isNativeClass(basesArray[i]) || basesArray[i].$metadata$.type === Kotlin.TYPE.CLASS) {
        return basesArray[i];
      }
    }
    return null;
  }

  var emptyFunction = function() {
    return function() {};
  };

  Kotlin.TYPE = {
    CLASS: "class",
    TRAIT: "trait",
    OBJECT: "object"
  };

  Kotlin.classCount = 0;
  Kotlin.newClassIndex = function() {
    var tmp = Kotlin.classCount;
    Kotlin.classCount++;
    return tmp;
  };

  function isNativeClass(obj) {
    return !(obj == null) && obj.$metadata$ == null;
  }

  function applyExtension(current, bases, baseGetter) {
    for (var i = 0; i < bases.length; i++) {
      if (isNativeClass(bases[i])) {
        continue;
      }
      var base = baseGetter(bases[i]);
      for (var p in  base) {
        if (base.hasOwnProperty(p)) {
          if(!current.hasOwnProperty(p) || current[p].$classIndex$ < base[p].$classIndex$) {
            current[p] = base[p];
          }
        }
      }
    }
  }

  function computeMetadata(bases, properties) {
    var metadata = {};

    metadata.baseClasses = toArray(bases);
    metadata.baseClass = getClass(metadata.baseClasses);
    metadata.classIndex = Kotlin.newClassIndex();
    metadata.functions = {};
    metadata.properties = {};

    if (!(properties == null)) {
      for (var p in properties) {
        if (properties.hasOwnProperty(p)) {
          var property = properties[p];
          property.$classIndex$ = metadata.classIndex;
          if (typeof property === "function") {
            metadata.functions[p] = property;
          } else {
            metadata.properties[p] = property;
          }
        }
      }
    }
    applyExtension(metadata.functions, metadata.baseClasses, function (it) {
      return it.$metadata$.functions
    });
    applyExtension(metadata.properties, metadata.baseClasses, function (it) {
      return it.$metadata$.properties
    });

    return metadata;
  }

  function class_object() {
    var object = this.object_initializer$();
    Object.defineProperty(this, "object", {value: object});
    return object;
  }

  Kotlin.createClass = function (bases, constructor, properties, staticProperties) {
    if (constructor == null) {
      constructor = emptyFunction();
    }
    copyProperties(constructor, staticProperties);

    var metadata = computeMetadata(bases, properties);
    metadata.type = Kotlin.TYPE.CLASS;

    var prototypeObj;
    if (metadata.baseClass !== null) {
      prototypeObj = Object.create(metadata.baseClass.prototype);
    } else {
      prototypeObj = {};
    }
    Object.defineProperties(prototypeObj, metadata.properties);
    copyProperties(prototypeObj, metadata.functions);
    prototypeObj.constructor = constructor;

    if (metadata.baseClass != null) {
      constructor.baseInitializer = metadata.baseClass;
    }

    constructor.$metadata$ = metadata;
    constructor.prototype = prototypeObj;
    Object.defineProperty(constructor, "object", {get: class_object, configurable: true});
    return constructor;
  };

  Kotlin.createObject = function (bases, constructor, functions) {
    var noNameClass = Kotlin.createClass(bases, constructor, functions);
    var obj = new noNameClass();
    obj.$metadata$ = {
      type: Kotlin.TYPE.OBJECT
    };
    return  obj;
  };

  Kotlin.createTrait = function (bases, properties, staticProperties) {
    var obj = function () {};
    copyProperties(obj, staticProperties);

    obj.$metadata$ = computeMetadata(bases, properties);
    obj.$metadata$.type = Kotlin.TYPE.TRAIT;
    return obj;
  };

  function isInheritanceFromTrait (objConstructor, trait) {
    if (isNativeClass(objConstructor) || objConstructor.$metadata$.classIndex < trait.$metadata$.classIndex) {
      return false;
    }
    var baseClasses = objConstructor.$metadata$.baseClasses;
    var i;
    for (i = 0; i < baseClasses.length; i++) {
      if (baseClasses[i] === trait) {
        return true;
      }
    }
    for (i = 0; i < baseClasses.length; i++) {
      if (isInheritanceFromTrait(baseClasses[i], trait)) {
        return true;
      }
    }
    return false;
  }

  Kotlin.isType = function (object, klass) {
    if (object == null || klass == null) {
      return false;
    } else {
      if (object instanceof klass) {
        return true;
      }
      else if (isNativeClass(klass) || klass.$metadata$.type == Kotlin.TYPE.CLASS) {
        return false;
      }
      else {
        return isInheritanceFromTrait(object.constructor, klass);
      }
    }
  };


////////////////////////////////// packages & modules //////////////////////////////

  function createPackageGetter(instance, initializer) {
    return function () {
      if (initializer !== null) {
        var tmp = initializer;
        initializer = null;
        tmp.call(instance);
      }

      return instance;
    };
  }

  function createDefinition(members) {
    var definition = {};
    if (members == null) {
      return definition;
    }
    for (var p in members) {
      if (members.hasOwnProperty(p)) {
        if ((typeof members[p]) === "function") {
          definition[p] = members[p];
        } else {
          Object.defineProperty(definition, p, members[p]);
        }
      }
    }
    return definition;
  }

  Kotlin.definePackage = function (initializer, members) {
    var definition = createDefinition(members);
    if (initializer === null) {
      return {value: definition};
    }
    else {
      var getter = createPackageGetter(definition, initializer);
      return {get: getter};
    }
  };

  Kotlin.defineRootPackage = function (initializer, members) {
    var definition = createDefinition(members);

    if (initializer === null) {
      definition.$initializer$ = emptyFunction();
    } else {
      definition.$initializer$ = initializer;
    }
    return definition;
  };

  Kotlin.defineModule = function (id, declaration) {
    if (id in Kotlin.modules) {
      throw new Error("Module " + id + " is already defined");
    }
    declaration.$initializer$.call(declaration); // TODO: temporary hack
    Object.defineProperty(Kotlin.modules, id, {value: declaration});
  };

})();

"use strict";

// todo inlined
String.prototype.startsWith = function (s) {
  return this.indexOf(s) === 0;
};

String.prototype.endsWith = function (s) {
  return this.indexOf(s, this.length - s.length) !== -1;
};

String.prototype.contains = function (s) {
  return this.indexOf(s) !== -1;
};

(function () {
  Kotlin.equals = function (obj1, obj2) {
    if (obj1 == null) {
      return obj2 == null;
    }

    if (Array.isArray(obj1)) {
      return Kotlin.arrayEquals(obj1, obj2);
    }

    if (typeof obj1 == "object" && obj1.equals !== undefined) {
      return obj1.equals(obj2);
    }

    return obj1 === obj2;
  };

  Kotlin.toString = function (o) {
    if (o == null) {
      return "null";
    }
    else if (Array.isArray(o)) {
      return Kotlin.arrayToString(o);
    }
    else {
      return o.toString();
    }
  };

  Kotlin.arrayToString = function(a) {
    return "[" + a.join(", ") + "]";
  };

  Kotlin.intUpto = function (from, to) {
    return new Kotlin.NumberRange(from, to);
  };

  Kotlin.intDownto = function (from, to) {
    return new Kotlin.Progression(from, to, -1);
  };

  Kotlin.modules = {};

  Kotlin.RuntimeException = Kotlin.createClass();
  Kotlin.NullPointerException = Kotlin.createClass();
  Kotlin.NoSuchElementException = Kotlin.createClass();
  Kotlin.IllegalArgumentException = Kotlin.createClass();
  Kotlin.IllegalStateException = Kotlin.createClass();
  Kotlin.UnsupportedOperationException = Kotlin.createClass();
  Kotlin.IOException = Kotlin.createClass();

  Kotlin.throwNPE = function () {
    throw new Kotlin.NullPointerException();
  };

  function throwAbstractFunctionInvocationError(funName) {
    return function() {
      var message;
      if (funName !== undefined) {
        message = "Function " + funName + " is abstract";
      } else {
        message = "Function is abstract";
      }
      throw new TypeError(message);
    };
  }

  Kotlin.Iterator = Kotlin.createClass(null, null, {
    next: throwAbstractFunctionInvocationError("Iterator#next"),
    hasNext: throwAbstractFunctionInvocationError("Iterator#hasNext")
  });

  var ArrayIterator = Kotlin.createClass(Kotlin.Iterator,
    function (array) {
      this.array = array;
      this.size = array.length;
      this.index = 0;
    }, {
      next: function () {
        return this.array[this.index++];
      },
      hasNext: function () {
        return this.index < this.size;
      }
    });

  var ListIterator = Kotlin.createClass(ArrayIterator,
    function (list) {
      this.list = list;
      this.size = list.size();
      this.index = 0;
    }, {
      next: function () {
        return this.list.get(this.index++);
      }
    });

  Kotlin.Collection = Kotlin.createClass();

  Kotlin.Enum = Kotlin.createClass(null,
    function () {
      this.name$ = undefined;
      this.ordinal$ = undefined;
    }, {
      name: function () {
        return this.name$;
      },
      ordinal: function () {
        return this.ordinal$;
      },
      toString: function () {
        return this.name();
      }
    });
  (function (){
    function valueOf(name) {
      return this[name];
    }
    function getValues() {
      return this.values$;
    }

    Kotlin.createEnumEntries = function(enumEntryList) {
      var i = 0;
      var values = [];
      for (var entryName in enumEntryList) {
        if (enumEntryList.hasOwnProperty(entryName)) {
          var entryObject = enumEntryList[entryName];
          values[i] = entryObject;
          entryObject.ordinal$ = i;
          entryObject.name$ = entryName;
          i++;
        }
      }
      enumEntryList.values$ = values;
      enumEntryList.valueOf = valueOf;
      enumEntryList.values = getValues;
      return enumEntryList;
    };
  })();

  Kotlin.PropertyMetadata = Kotlin.createClass(null,
    function(name) {
      this.name = name;
    }
  );

  Kotlin.AbstractCollection = Kotlin.createClass(Kotlin.Collection, null, {
    size: function () {
      return this.$size;
    },
    addAll: function (collection) {
      var it = collection.iterator();
      var i = this.size();
      while (i-- > 0) {
        this.add(it.next());
      }
    },
    isEmpty: function () {
      return this.size() === 0;
    },
    iterator: function () {
      return new ArrayIterator(this.toArray());
    },
    equals: function (o) {
      if (this.size() !== o.size()) return false;

      var iterator1 = this.iterator();
      var iterator2 = o.iterator();
      var i = this.size();
      while (i-- > 0) {
        if (!Kotlin.equals(iterator1.next(), iterator2.next())) {
          return false;
        }
      }

      return true;
    },
    toString: function () {
      var builder = "[";
      var iterator = this.iterator();
      var first = true;
      var i = this.$size;
      while (i-- > 0) {
        if (first) {
          first = false;
        }
        else {
          builder += ", ";
        }
        builder += iterator.next();
      }
      builder += "]";
      return builder;
    },
    toJSON: function () {
      return this.toArray();
    }
  });

  Kotlin.AbstractList = Kotlin.createClass(Kotlin.AbstractCollection, null, {
    iterator: function () {
      return new ListIterator(this);
    },
    remove: function (o) {
      var index = this.indexOf(o);
      if (index !== -1) {
        this.removeAt(index);
      }
    },
    contains: function (o) {
      return this.indexOf(o) !== -1;
    }
  });

  //TODO: should be JS Array-like (https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Predefined_Core_Objects#Working_with_Array-like_objects)
  Kotlin.ArrayList = Kotlin.createClass(Kotlin.AbstractList,
    function () {
      this.array = [];
      this.$size = 0;
    }, {
      get: function (index) {
        this.checkRange(index);
        return this.array[index];
      },
      set: function (index, value) {
        this.checkRange(index);
        this.array[index] = value;
      },
      size: function () {
        return this.$size;
      },
      iterator: function () {
        return Kotlin.arrayIterator(this.array);
      },
      add: function (element) {
        this.array[this.$size++] = element;
      },
      addAt: function (index, element) {
        this.array.splice(index, 0, element);
        this.$size++;
      },
      addAll: function (collection) {
        var it = collection.iterator();
        for (var i = this.$size, n = collection.size(); n-- > 0;) {
          this.array[i++] = it.next();
        }

        this.$size += collection.size();
      },
      removeAt: function (index) {
        this.checkRange(index);
        this.$size--;
        return this.array.splice(index, 1)[0];
      },
      clear: function () {
        this.array.length = 0;
        this.$size = 0;
      },
      indexOf: function (o) {
        for (var i = 0, n = this.$size; i < n; ++i) {
          if (Kotlin.equals(this.array[i], o)) {
            return i;
          }
        }
        return -1;
      },
      toArray: function () {
        return this.array.slice(0, this.$size);
      },
      toString: function () {
        return "[" + this.array.join(", ") + "]";
      },
      toJSON: function () {
        return this.array;
      },
      checkRange: function(index) {
        if (index < 0 || index >= this.$size) {
          throw new RangeError();
        }
      }
    });

  Kotlin.Runnable = Kotlin.createClass(null, null, {
    run: throwAbstractFunctionInvocationError("Runnable#run")
  });

  Kotlin.Comparable = Kotlin.createClass(null, null, {
    compareTo: throwAbstractFunctionInvocationError("Comparable#compareTo")
  });

  Kotlin.Appendable = Kotlin.createClass(null, null, {
    append: throwAbstractFunctionInvocationError("Appendable#append")
  });

  Kotlin.Closeable = Kotlin.createClass(null, null, {
    close: throwAbstractFunctionInvocationError("Closeable#close")
  });

  Kotlin.safeParseInt = function(str) {
    var r = parseInt(str, 10);
    return isNaN(r) ? null : r;
  };

  Kotlin.safeParseDouble = function(str) {
    var r = parseFloat(str);
    return isNaN(r) ? null : r;
  };

  Kotlin.arrayEquals = function (a, b) {
    if (a === b) {
      return true;
    }
    if (!Array.isArray(b) || a.length !== b.length) {
      return false;
    }

    for (var i = 0, n = a.length; i < n; i++) {
      if (!Kotlin.equals(a[i], b[i])) {
        return false;
      }
    }
    return true;
  };

  Kotlin.System = function () {
    var output = "";

    var print = function (obj) {
      if (obj !== undefined) {
        if (obj === null || typeof obj !== "object") {
          output += obj;
        }
        else {
          output += obj.toString();
        }
      }
    };
    var println = function (obj) {
      this.print(obj);
      output += "\n";
    };

    return {
      out: function () {
        return {
          print: print,
          println: println
        };
      },
      output: function () {
        return output;
      },
      flush: function () {
        output = "";
      }
    };
  }();

  Kotlin.println = function (s) {
    Kotlin.System.out().println(s);
  };

  Kotlin.print = function (s) {
    Kotlin.System.out().print(s);
  };

  Kotlin.RangeIterator = Kotlin.createClass(Kotlin.Iterator,
    function (start, end, increment) {
      this.start = start;
      this.end = end;
      this.increment = increment;
      this.i = start;
    }, {
      next: function () {
        var value = this.i;
        this.i = this.i + this.increment;
        return value;
      },
      hasNext: function () {
        return this.i <= this.end;
      }
    });

  Kotlin.NumberRange = Kotlin.createClass(null,
    function (start, end) {
      this.start = start;
      this.end = end;
      this.increment = 1;
    }, {
      contains: function (number) {
        return this.start <= number && number <= this.end;
      },
      iterator: function () {
        return new Kotlin.RangeIterator(this.start, this.end);
      }
    });

  Kotlin.Progression = Kotlin.createClass(null,
    function (start, end, increment) {
      this.start = start;
      this.end = end;
      this.increment = increment;
    }, {
      iterator: function () {
        return new Kotlin.RangeIterator(this.start, this.end, this.increment);
      }
    });

  Kotlin.Comparator = Kotlin.createClass(null, null, {
    compare: throwAbstractFunctionInvocationError("Comparator#compare")
  });

  var ComparatorImpl = Kotlin.createClass(Kotlin.Comparator,
    function (comparator) {
      this.compare = comparator;
    }
  );

  Kotlin.comparator = function (f) {
    return new ComparatorImpl(f);
  };

  Kotlin.collectionsMax = function (c, comp) {
    if (c.isEmpty()) {
      //TODO: which exception?
      throw new Error();
    }
    var it = c.iterator();
    var max = it.next();
    while (it.hasNext()) {
      var el = it.next();
      if (comp.compare(max, el) < 0) {
        max = el;
      }
    }
    return max;
  };

  Kotlin.collectionsSort = function (mutableList, comparator) {
    var boundComparator = undefined;
    if (comparator !== undefined) {
      boundComparator = comparator.compare.bind(comparator);
    }

    if (mutableList instanceof Array) {
      mutableList.sort(boundComparator);
    }

    //TODO: should be deleted when List will be JS Array-like (https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Predefined_Core_Objects#Working_with_Array-like_objects)
    var array = [];
    var it = mutableList.iterator();
    while (it.hasNext()) {
      array.push(it.next());
    }

    array.sort(boundComparator);

    for (var i = 0, n = array.length; i < n; i++) {
      mutableList.set(i, array[i]);
    }
  };

  Kotlin.copyToArray = function (collection) {
    var array = [];
    var it = collection.iterator();
    while (it.hasNext()) {
      array.push(it.next());
    }

    return array;
  };


  Kotlin.StringBuilder = Kotlin.createClass(null,
    function () {
      this.string = "";
    }, {
      append:function (obj) {
        this.string = this.string + obj.toString();
      },
      toString:function () {
        return this.string;
      }
    });

  Kotlin.splitString = function (str, regex, limit) {
    return str.split(new RegExp(regex), limit);
  };

  Kotlin.nullArray = function (size) {
    var res = [];
    var i = size;
    while (i > 0) {
      res[--i] = null;
    }
    return res;
  };

  Kotlin.numberArrayOfSize = function (size) {
    return Kotlin.arrayFromFun(size, function(){ return 0; });
  };

  Kotlin.charArrayOfSize = function (size) {
    return Kotlin.arrayFromFun(size, function(){ return '\0'; });
  };

  Kotlin.booleanArrayOfSize = function (size) {
    return Kotlin.arrayFromFun(size, function(){ return false; });
  };

  Kotlin.arrayFromFun = function (size, initFun) {
    var result = new Array(size);
    for (var i = 0; i < size; i++) {
      result[i] = initFun(i);
    }
    return result;
  };

  Kotlin.arrayIndices = function (arr) {
    return new Kotlin.NumberRange(0, arr.length - 1);
  };

  Kotlin.arrayIterator = function (array) {
    return new ArrayIterator(array);
  };

  Kotlin.jsonFromTuples = function (pairArr) {
    var i = pairArr.length;
    var res = {};
    while (i > 0) {
      --i;
      res[pairArr[i][0]] = pairArr[i][1];
    }
    return res;
  };

  Kotlin.jsonAddProperties = function (obj1, obj2) {
    for (var p in obj2) {
      if (obj2.hasOwnProperty(p)) {
        obj1[p] = obj2[p];
      }
    }
    return obj1;
  };
})();

Kotlin.assignOwner = function(f, o) {
  f.o = o;
  return f;
};

"use strict";
(function () {
  var FUNCTION = "function";
  var arrayRemoveAt = (typeof Array.prototype.splice == FUNCTION) ?
    function (arr, idx) {
      arr.splice(idx, 1);
    } :

    function (arr, idx) {
      var itemsAfterDeleted, i, len;
      if (idx === arr.length - 1) {
        arr.length = idx;
      }
      else {
        itemsAfterDeleted = arr.slice(idx + 1);
        arr.length = idx;
        for (i = 0, len = itemsAfterDeleted.length; i < len; ++i) {
          arr[idx + i] = itemsAfterDeleted[i];
        }
      }
    };

  function hashObject(obj) {
    var hashCode;
    if (typeof obj == "string") {
      return obj;
    }
    else if (typeof obj.hashCode == FUNCTION) {
      // Check the hashCode method really has returned a string
      hashCode = obj.hashCode();
      return (typeof hashCode == "string") ? hashCode : hashObject(hashCode);
    }
    else if (typeof obj.toString == FUNCTION) {
      return obj.toString();
    }
    else {
      try {
        return String(obj);
      }
      catch (ex) {
        // For host objects (such as ActiveObjects in IE) that have no toString() method and throw an error when
        // passed to String()
        return Object.prototype.toString.call(obj);
      }
    }
  }

  function equals_fixedValueHasEquals(fixedValue, variableValue) {
    return fixedValue.equals(variableValue);
  }

  function equals_fixedValueNoEquals(fixedValue, variableValue) {
    return (typeof variableValue.equals == FUNCTION) ?
      variableValue.equals(fixedValue) : (fixedValue === variableValue);
  }

  function createKeyValCheck(kvStr) {
    return function (kv) {
      if (kv === null) {
        throw new Error("null is not a valid " + kvStr);
      }
      else if (typeof kv == "undefined") {
        throw new Error(kvStr + " must not be undefined");
      }
    };
  }

  var checkKey = createKeyValCheck("key"), checkValue = createKeyValCheck("value");

  function Bucket(hash, firstKey, firstValue, equalityFunction) {
    this[0] = hash;
    this.entries = [];
    this.addEntry(firstKey, firstValue);

    if (equalityFunction !== null) {
      this.getEqualityFunction = function () {
        return equalityFunction;
      };
    }
  }

  var EXISTENCE = 0, ENTRY = 1, ENTRY_INDEX_AND_VALUE = 2;

  function createBucketSearcher(mode) {
    return function (key) {
      var i = this.entries.length, entry, equals = this.getEqualityFunction(key);
      while (i--) {
        entry = this.entries[i];
        if (equals(key, entry[0])) {
          switch (mode) {
            case EXISTENCE:
              return true;
            case ENTRY:
              return entry;
            case ENTRY_INDEX_AND_VALUE:
              return [ i, entry[1] ];
          }
        }
      }
      return false;
    };
  }

  function createBucketLister(entryProperty) {
    return function (aggregatedArr) {
      var startIndex = aggregatedArr.length;
      for (var i = 0, len = this.entries.length; i < len; ++i) {
        aggregatedArr[startIndex + i] = this.entries[i][entryProperty];
      }
    };
  }

  Bucket.prototype = {
    getEqualityFunction: function (searchValue) {
      return (typeof searchValue.equals == FUNCTION) ? equals_fixedValueHasEquals : equals_fixedValueNoEquals;
    },

    getEntryForKey: createBucketSearcher(ENTRY),

    getEntryAndIndexForKey: createBucketSearcher(ENTRY_INDEX_AND_VALUE),

    removeEntryForKey: function (key) {
      var result = this.getEntryAndIndexForKey(key);
      if (result) {
        arrayRemoveAt(this.entries, result[0]);
        return result[1];
      }
      return null;
    },

    addEntry: function (key, value) {
      this.entries[this.entries.length] = [key, value];
    },

    keys: createBucketLister(0),

    values: createBucketLister(1),

    getEntries: function (entries) {
      var startIndex = entries.length;
      for (var i = 0, len = this.entries.length; i < len; ++i) {
        // Clone the entry stored in the bucket before adding to array
        entries[startIndex + i] = this.entries[i].slice(0);
      }
    },

    containsKey: createBucketSearcher(EXISTENCE),

    containsValue: function (value) {
      var i = this.entries.length;
      while (i--) {
        if (value === this.entries[i][1]) {
          return true;
        }
      }
      return false;
    }
  };

  /*----------------------------------------------------------------------------------------------------------------*/

  // Supporting functions for searching hashtable buckets

  function searchBuckets(buckets, hash) {
    var i = buckets.length, bucket;
    while (i--) {
      bucket = buckets[i];
      if (hash === bucket[0]) {
        return i;
      }
    }
    return null;
  }

  function getBucketForHash(bucketsByHash, hash) {
    var bucket = bucketsByHash[hash];

    // Check that this is a genuine bucket and not something inherited from the bucketsByHash's prototype
    return ( bucket && (bucket instanceof Bucket) ) ? bucket : null;
  }

  /*----------------------------------------------------------------------------------------------------------------*/

  var Hashtable = function (hashingFunctionParam, equalityFunctionParam) {
    var that = this;
    var buckets = [];
    var bucketsByHash = {};

    var hashingFunction = (typeof hashingFunctionParam == FUNCTION) ? hashingFunctionParam : hashObject;
    var equalityFunction = (typeof equalityFunctionParam == FUNCTION) ? equalityFunctionParam : null;

    this.put = function (key, value) {
      checkKey(key);
      checkValue(value);
      var hash = hashingFunction(key), bucket, bucketEntry, oldValue = null;

      // Check if a bucket exists for the bucket key
      bucket = getBucketForHash(bucketsByHash, hash);
      if (bucket) {
        // Check this bucket to see if it already contains this key
        bucketEntry = bucket.getEntryForKey(key);
        if (bucketEntry) {
          // This bucket entry is the current mapping of key to value, so replace old value and we're done.
          oldValue = bucketEntry[1];
          bucketEntry[1] = value;
        }
        else {
          // The bucket does not contain an entry for this key, so add one
          bucket.addEntry(key, value);
        }
      }
      else {
        // No bucket exists for the key, so create one and put our key/value mapping in
        bucket = new Bucket(hash, key, value, equalityFunction);
        buckets[buckets.length] = bucket;
        bucketsByHash[hash] = bucket;
      }
      return oldValue;
    };

    this.get = function (key) {
      checkKey(key);

      var hash = hashingFunction(key);

      // Check if a bucket exists for the bucket key
      var bucket = getBucketForHash(bucketsByHash, hash);
      if (bucket) {
        // Check this bucket to see if it contains this key
        var bucketEntry = bucket.getEntryForKey(key);
        if (bucketEntry) {
          // This bucket entry is the current mapping of key to value, so return the value.
          return bucketEntry[1];
        }
      }
      return null;
    };

    this.containsKey = function (key) {
      checkKey(key);
      var bucketKey = hashingFunction(key);

      // Check if a bucket exists for the bucket key
      var bucket = getBucketForHash(bucketsByHash, bucketKey);

      return bucket ? bucket.containsKey(key) : false;
    };

    this.containsValue = function (value) {
      checkValue(value);
      var i = buckets.length;
      while (i--) {
        if (buckets[i].containsValue(value)) {
          return true;
        }
      }
      return false;
    };

    this.clear = function () {
      buckets.length = 0;
      bucketsByHash = {};
    };

    this.isEmpty = function () {
      return !buckets.length;
    };

    var createBucketAggregator = function (bucketFuncName) {
      return function () {
        var aggregated = [], i = buckets.length;
        while (i--) {
          buckets[i][bucketFuncName](aggregated);
        }
        return aggregated;
      };
    };

    this._keys = createBucketAggregator("keys");
    this._values = createBucketAggregator("values");
    this._entries = createBucketAggregator("getEntries");

    this.values = function () {
      var values = this._values();
      var i = values.length;
      var result = new Kotlin.ArrayList();
      while (i--) {
        result.add(values[i]);
      }
      return result;
    };

    this.remove = function (key) {
      checkKey(key);

      var hash = hashingFunction(key), bucketIndex, oldValue = null;

      // Check if a bucket exists for the bucket key
      var bucket = getBucketForHash(bucketsByHash, hash);

      if (bucket) {
        // Remove entry from this bucket for this key
        oldValue = bucket.removeEntryForKey(key);
        if (oldValue !== null) {
          // Entry was removed, so check if bucket is empty
          if (!bucket.entries.length) {
            // Bucket is empty, so remove it from the bucket collections
            bucketIndex = searchBuckets(buckets, hash);
            arrayRemoveAt(buckets, bucketIndex);
            delete bucketsByHash[hash];
          }
        }
      }
      return oldValue;
    };

    this.size = function () {
      var total = 0, i = buckets.length;
      while (i--) {
        total += buckets[i].entries.length;
      }
      return total;
    };

    this.each = function (callback) {
      var entries = that._entries(), i = entries.length, entry;
      while (i--) {
        entry = entries[i];
        callback(entry[0], entry[1]);
      }
    };


    this.putAll = function (hashtable, conflictCallback) {
      var entries = hashtable._entries();
      var entry, key, value, thisValue, i = entries.length;
      var hasConflictCallback = (typeof conflictCallback == FUNCTION);
      while (i--) {
        entry = entries[i];
        key = entry[0];
        value = entry[1];

        // Check for a conflict. The default behaviour is to overwrite the value for an existing key
        if (hasConflictCallback && (thisValue = that.get(key))) {
          value = conflictCallback(key, thisValue, value);
        }
        that.put(key, value);
      }
    };

    this.clone = function () {
      var clone = new Hashtable(hashingFunctionParam, equalityFunctionParam);
      clone.putAll(that);
      return clone;
    };

    this.keySet = function () {
      var res = new Kotlin.ComplexHashSet();
      var keys = this._keys();
      var i = keys.length;
      while (i--) {
        res.add(keys[i]);
      }
      return res;
    };
  };


  Kotlin.HashTable = Hashtable;
})();

Kotlin.Map = Kotlin.createClass();

Kotlin.HashMap = Kotlin.createClass(Kotlin.Map,
  function () {
    Kotlin.HashTable.call(this);
  }
);

Kotlin.ComplexHashMap = Kotlin.HashMap;

(function () {
  var PrimitiveHashMapValuesIterator = Kotlin.createClass(Kotlin.Iterator,
    function (map, keys) {
      this.map = map;
      this.keys = keys;
      this.size = keys.length;
      this.index = 0;
    }, {
      next: function () {
        return this.map[this.keys[this.index++]];
      },
      hasNext: function () {
        return this.index < this.size;
      }
    });

  var PrimitiveHashMapValues = Kotlin.createClass(Kotlin.Collection,
    function (map) {
      this.map = map;
    }, {
      iterator: function () {
        return new PrimitiveHashMapValuesIterator(this.map.map, Object.keys(this.map.map));
      },
      isEmpty: function () {
        return this.map.$size === 0;
      },
      contains: function (o) {
        return this.map.containsValue(o);
      }
    });

  Kotlin.PrimitiveHashMap = Kotlin.createClass(Kotlin.Map,
    function () {
      this.$size = 0;
      this.map = {};
    }, {
      size: function () {
        return this.$size;
      },
      isEmpty: function () {
        return this.$size === 0;
      },
      containsKey: function (key) {
        return this.map[key] !== undefined;
      },
      containsValue: function (value) {
        var map = this.map;
        for (var key in map) {
          if (map.hasOwnProperty(key) && map[key] === value) {
            return true;
          }
        }

        return false;
      },
      get: function (key) {
        return this.map[key];
      },
      put: function (key, value) {
        var prevValue = this.map[key];
        this.map[key] = value === undefined ? null : value;
        if (prevValue === undefined) {
          this.$size++;
        }
        return prevValue;
      },
      remove: function (key) {
        var prevValue = this.map[key];
        if (prevValue !== undefined) {
          delete this.map[key];
          this.$size--;
        }
        return prevValue;
      },
      clear: function () {
        this.$size = 0;
        this.map = {};
      },
      putAll: function (fromMap) {
        var map = fromMap.map;
        for (var key in map) {
          if (map.hasOwnProperty(key)) {
            this.map[key] = map[key];
            this.$size++;
          }
        }
      },
      keySet: function () {
        var result = new Kotlin.PrimitiveHashSet();
        var map = this.map;
        for (var key in map) {
          if (map.hasOwnProperty(key)) {
            result.add(key);
          }
        }

        return result;
      },
      values: function () {
        return new PrimitiveHashMapValues(this);
      },
      toJSON: function () {
        return this.map;
      }
    });
}());

Kotlin.Set = Kotlin.createClass(Kotlin.Collection);

Kotlin.PrimitiveHashSet = Kotlin.createClass(Kotlin.AbstractCollection,
  function () {
    this.$size = 0;
    this.map = {};
  }, {
    contains: function (key) {
      return this.map[key] === true;
    },
    add: function (element) {
      var prevElement = this.map[element];
      this.map[element] = true;
      if (prevElement === true) {
        return false;
      }
      else {
        this.$size++;
        return true;
      }
    },
    remove: function (element) {
      if (this.map[element] === true) {
        delete this.map[element];
        this.$size--;
        return true;
      }
      else {
        return false;
      }
    },
    clear: function () {
      this.$size = 0;
      this.map = {};
    },
    toArray: function () {
      return Object.keys(this.map);
    }
  });

(function () {
  function HashSet(hashingFunction, equalityFunction) {
    var hashTable = new Kotlin.HashTable(hashingFunction, equalityFunction);

    this.add = function (o) {
      hashTable.put(o, true);
    };

    this.addAll = function (arr) {
      var i = arr.length;
      while (i--) {
        hashTable.put(arr[i], true);
      }
    };

    this.values = function () {
      return hashTable._keys();
    };

    this.iterator = function () {
      return Kotlin.arrayIterator(this.values());
    };

    this.remove = function (o) {
      return hashTable.remove(o) ? o : null;
    };

    this.contains = function (o) {
      return hashTable.containsKey(o);
    };

    this.clear = function () {
      hashTable.clear();
    };

    this.size = function () {
      return hashTable.size();
    };

    this.isEmpty = function () {
      return hashTable.isEmpty();
    };

    this.clone = function () {
      var h = new HashSet(hashingFunction, equalityFunction);
      h.addAll(hashTable.keys());
      return h;
    };

    this.equals = function (o) {
      if (o === null || o === undefined) return false;
      if (this.size() === o.size()) {
        var iter1 = this.iterator();
        var iter2 = o.iterator();
        while (true) {
          var hn1 = iter1.hasNext();
          var hn2 = iter2.hasNext();
          if (hn1 != hn2) return false;
          if (!hn2)
            return true;
          else {
            var o1 = iter1.next();
            var o2 = iter2.next();
            if (!Kotlin.equals(o1, o2)) return false;
          }
        }
      }
      return false;
    };

    this.toString = function() {
      var builder = "[";
      var iter = this.iterator();
      var first = true;
      while (iter.hasNext()) {
        if (first)
          first = false;
        else
          builder += ", ";
        builder += iter.next();
      }
      builder += "]";
      return builder;
    };

    this.intersection = function (hashSet) {
      var intersection = new HashSet(hashingFunction, equalityFunction);
      var values = hashSet.values(), i = values.length, val;
      while (i--) {
        val = values[i];
        if (hashTable.containsKey(val)) {
          intersection.add(val);
        }
      }
      return intersection;
    };

    this.union = function (hashSet) {
      var union = this.clone();
      var values = hashSet.values(), i = values.length, val;
      while (i--) {
        val = values[i];
        if (!hashTable.containsKey(val)) {
          union.add(val);
        }
      }
      return union;
    };

    this.isSubsetOf = function (hashSet) {
      var values = hashTable.keys(), i = values.length;
      while (i--) {
        if (!hashSet.contains(values[i])) {
          return false;
        }
      }
      return true;
    };
  }

  Kotlin.HashSet = Kotlin.createClass(Kotlin.Set,
    function () {
      HashSet.call(this);
    }
  );

  Kotlin.ComplexHashSet = Kotlin.HashSet;
}());

module.exports = Kotlin;
},{}],35:[function(require,module,exports){
var Kotlin = require('kevoree-kotlin');

(function () {
  'use strict';
  var _c = function () {
    var KMFFactory = Kotlin.createTrait(null)
    , ModelLoader = Kotlin.createTrait(null)
    , KMFContainer = Kotlin.createTrait(null)
    , KMFContainerProxy = Kotlin.createTrait(KMFContainer, /** @lends _c.KMFContainerProxy.prototype */ {
      relativeLookupFrom: function (base, relationInParent, key) {
        var currentPath = base.path();
        var tmp$0;
        return (tmp$0 = this.originFactory) != null ? tmp$0.lookupFrom(Kotlin.toString(currentPath) + '/' + relationInParent + '[' + key + ']', base) : null;
      }
    })
    , PersistenceKMFFactory = Kotlin.createTrait(KMFFactory, /** @lends _c.PersistenceKMFFactory.prototype */ {
      remove: function (elem) {
        if (this.datastore != null) {
          var tmp$0, tmp$1, tmp$2, tmp$3;
          ((tmp$0 = this.datastore) != null ? tmp$0 : Kotlin.throwNPE()).remove('trace', (tmp$1 = elem.path()) != null ? tmp$1 : Kotlin.throwNPE());
          ((tmp$2 = this.datastore) != null ? tmp$2 : Kotlin.throwNPE()).remove('type', (tmp$3 = elem.path()) != null ? tmp$3 : Kotlin.throwNPE());
        }
      },
      clearCache: function () {
        this.elem_cache.clear();
      },
      lookup: function (path) {
        return this.lookupFrom(path, null);
      },
      lookupFrom: function (path, origin) {
        var path2 = path;
        if (Kotlin.equals(path2, '/')) {
          path2 = '';
        }
        if (path2.startsWith('/')) {
          path2 = path2.substring(1);
        }
        if (this.elem_cache.containsKey(path2)) {
          return this.elem_cache.get(path2);
        }
        if (this.datastore != null) {
          var tmp$0;
          var typeName = ((tmp$0 = this.datastore) != null ? tmp$0 : Kotlin.throwNPE()).get('type', path2);
          if (typeName != null) {
            var tmp$1;
            var elem = (tmp$1 = this.create(typeName)) != null ? tmp$1 : Kotlin.throwNPE();
            this.elem_cache.put(path2, elem);
            elem.originFactory = this;
            elem.isResolved = false;
            elem.setOriginPath(path2);
            return elem;
          }
           else {
            throw new Error('Empty Type Name for ' + path2);
          }
        }
        return null;
      },
      getTraces: function (origin) {
        var sequence = this.compare.createSequence();
        var tmp$0, tmp$1;
        var traces = (tmp$1 = this.datastore) != null ? tmp$1.get('trace', (tmp$0 = origin.path()) != null ? tmp$0 : Kotlin.throwNPE()) : null;
        if (traces != null) {
          sequence.populateFromString(traces);
          return sequence;
        }
        return null;
      },
      persist: function (elem) {
        if (this.datastore != null) {
          var traces = elem.toTraces(true, true);
          var traceSeq = this.compare.createSequence();
          traceSeq.populate(traces);
          var tmp$0, tmp$1, tmp$2, tmp$3;
          ((tmp$0 = this.datastore) != null ? tmp$0 : Kotlin.throwNPE()).put('trace', (tmp$1 = elem.path()) != null ? tmp$1 : Kotlin.throwNPE(), traceSeq.exportToString());
          ((tmp$2 = this.datastore) != null ? tmp$2 : Kotlin.throwNPE()).put('type', (tmp$3 = elem.path()) != null ? tmp$3 : Kotlin.throwNPE(), elem.metaClassName());
          if (Kotlin.isType(elem, _c.KMFContainerProxy)) {
            elem.originFactory = this;
          }
        }
      },
      persistBatch: function (batch) {
        {
          var tmp$0 = batch.elements.iterator();
          while (tmp$0.hasNext()) {
            var b = tmp$0.next();
            this.persist(b);
          }
        }
      },
      createBatch: function () {
        return new _.org.kevoree.modeling.api.persistence.Batch();
      },
      commit: function () {
        var tmp$0;
        (tmp$0 = this.datastore) != null ? tmp$0.sync() : null;
      }
    })
    , ModelSerializer = Kotlin.createTrait(null)
    , NamedElement = Kotlin.createTrait(KMFContainer)
    , Instance = Kotlin.createTrait([NamedElement, KMFContainer])
    , TypeDefinition = Kotlin.createTrait([NamedElement, KMFContainer])
    , PortType = Kotlin.createTrait([TypeDefinition, KMFContainer])
    , Dictionary = Kotlin.createTrait(KMFContainer)
    , TypedElement = Kotlin.createTrait([NamedElement, KMFContainer]);
    return {KMFFactory: KMFFactory, KevoreeFactory: Kotlin.createTrait(KMFFactory), ModelVisitor: Kotlin.createClass(null, function () {
      this.visitStopped = false;
      this.visitChildren = true;
      this.visitReferences = true;
      this.alreadyVisited = null;
    }, /** @lends _c.ModelVisitor.prototype */ {
      stopVisit: function () {
        this.visitStopped = true;
      },
      noChildrenVisit: function () {
        this.visitChildren = false;
      },
      noReferencesVisit: function () {
        this.visitReferences = false;
      },
      beginVisitElem: function (elem) {
      },
      endVisitElem: function (elem) {
      },
      beginVisitRef: function (refName, refType) {
      },
      endVisitRef: function (refName) {
      }
    }), ModelAttributeVisitor: Kotlin.createTrait(null), ModelLoader: ModelLoader, KMFContainer: KMFContainer, DataStore: Kotlin.createTrait(null), KMFContainerProxy: KMFContainerProxy, PersistenceKMFFactory: PersistenceKMFFactory, ModelSerializer: ModelSerializer, TimeAwareKMFFactory: Kotlin.createTrait(PersistenceKMFFactory, /** @lends _c.TimeAwareKMFFactory.prototype */ {
      shiftElem: function (path, relativeNow) {
      },
      shiftQuery: function (query, relativeNow) {
      },
      persist: function (elem) {
        if (this.datastore != null) {
          var traces = elem.toTraces(true, true);
          var traceSeq = this.compare.createSequence();
          traceSeq.populate(traces);
          var currentNow = elem != null ? elem.now : null;
          if (currentNow == null) {
            currentNow = this.relativeTime;
          }
          var tmp$0, tmp$1, tmp$2, tmp$3, tmp$4;
          var currentPath = (tmp$0 = elem.path()) != null ? tmp$0 : Kotlin.throwNPE();
          ((tmp$1 = this.datastore) != null ? tmp$1 : Kotlin.throwNPE()).put(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), Kotlin.toString(currentNow) + '/' + currentPath, traceSeq.exportToString());
          ((tmp$2 = this.datastore) != null ? tmp$2 : Kotlin.throwNPE()).put(_.org.kevoree.modeling.api.time.TimeSegment.object.LATEST.name(), currentPath, Kotlin.toString(currentNow));
          var previousType = ((tmp$3 = this.datastore) != null ? tmp$3 : Kotlin.throwNPE()).get(_.org.kevoree.modeling.api.time.TimeSegment.object.TYPE.name(), (tmp$4 = elem.path()) != null ? tmp$4 : Kotlin.throwNPE());
          if (previousType == null) {
            var tmp$5, tmp$6;
            ((tmp$5 = this.datastore) != null ? tmp$5 : Kotlin.throwNPE()).put(_.org.kevoree.modeling.api.time.TimeSegment.object.TYPE.name(), (tmp$6 = elem.path()) != null ? tmp$6 : Kotlin.throwNPE(), elem.metaClassName());
          }
          if (Kotlin.isType(elem, _c.KMFContainerProxy)) {
            elem.originFactory = this;
          }
        }
      },
      remove: function (elem) {
        if (this.datastore != null) {
          var tmp$0, tmp$1, tmp$2, tmp$3, tmp$4, tmp$5;
          ((tmp$0 = this.datastore) != null ? tmp$0 : Kotlin.throwNPE()).remove(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), (tmp$1 = elem.path()) != null ? tmp$1 : Kotlin.throwNPE());
          ((tmp$2 = this.datastore) != null ? tmp$2 : Kotlin.throwNPE()).remove(_.org.kevoree.modeling.api.time.TimeSegment.object.TYPE.name(), (tmp$3 = elem.path()) != null ? tmp$3 : Kotlin.throwNPE());
          ((tmp$4 = this.datastore) != null ? tmp$4 : Kotlin.throwNPE()).remove(_.org.kevoree.modeling.api.time.TimeSegment.object.LATEST.name(), (tmp$5 = elem.path()) != null ? tmp$5 : Kotlin.throwNPE());
        }
      },
      resolvedTimeFromParams: function (path) {
        {
          var tmp$0 = _.kotlin.iterator(this.timedElement);
          while (tmp$0.hasNext()) {
            var staticPathV = tmp$0.next();
            if (Kotlin.equals(_.kotlin.get_key(staticPathV), path)) {
              return _.kotlin.get_value(staticPathV);
            }
          }
        }
        return null;
      },
      lookupFrom: function (path, origin) {
        var path2 = path;
        if (Kotlin.equals(path2, '/')) {
          path2 = '';
        }
        if (path2.startsWith('/')) {
          path2 = path2.substring(1);
        }
        var currentTime = origin != null ? origin.now : null;
        var tmp$0 = this.relativityStrategy;
        if (tmp$0 === _.org.kevoree.modeling.api.time.RelativeTimeStrategy.object.BEGINNING_OF_TIME_FIRST) {
          currentTime = this.relativeTime;
          var resolved = this.resolvedTimeFromParams(path2);
          if (resolved != null) {
            currentTime = resolved;
          }
        }
         else if (tmp$0 === _.org.kevoree.modeling.api.time.RelativeTimeStrategy.object.LATEST_FIRST) {
          var tmp$1, tmp$2;
          currentTime = _.org.kevoree.modeling.api.time.TimePoint.object.create((tmp$2 = ((tmp$1 = this.datastore) != null ? tmp$1 : Kotlin.throwNPE()).get(_.org.kevoree.modeling.api.time.TimeSegment.object.LATEST.name(), path2)) != null ? tmp$2 : Kotlin.throwNPE());
          var resolved_0 = this.resolvedTimeFromParams(path2);
          if (resolved_0 != null) {
            currentTime = resolved_0;
          }
        }
         else if (tmp$0 === _.org.kevoree.modeling.api.time.RelativeTimeStrategy.object.RELATIVE_FIRST) {
          if (currentTime == null) {
            currentTime = this.relativeTime;
          }
        }
         else {
        }
        if (currentTime == null) {
          var tmp$3, tmp$4;
          currentTime = _.org.kevoree.modeling.api.time.TimePoint.object.create((tmp$4 = ((tmp$3 = this.datastore) != null ? tmp$3 : Kotlin.throwNPE()).get(_.org.kevoree.modeling.api.time.TimeSegment.object.LATEST.name(), path2)) != null ? tmp$4 : Kotlin.throwNPE());
        }
        var composedKey = (currentTime != null ? currentTime : Kotlin.throwNPE()).toString() + path2;
        if (this.elem_cache.containsKey(composedKey)) {
          return this.elem_cache.get(composedKey);
        }
        if (this.datastore != null) {
          var tmp$5;
          var typeName = ((tmp$5 = this.datastore) != null ? tmp$5 : Kotlin.throwNPE()).get(_.org.kevoree.modeling.api.time.TimeSegment.object.TYPE.name(), path2);
          if (typeName != null) {
            var tmp$6;
            var elem = (tmp$6 = this.create(typeName)) != null ? tmp$6 : Kotlin.throwNPE();
            this.elem_cache.put(composedKey, elem);
            elem.originFactory = this;
            elem.isResolved = false;
            elem.now = currentTime != null ? currentTime : Kotlin.throwNPE();
            elem.setOriginPath(path2);
            return elem;
          }
           else {
            throw new Error('Empty Type Name for ' + path2);
          }
        }
        return null;
      },
      getTraces: function (origin) {
        var currentNow = (origin != null ? origin : Kotlin.throwNPE()).now;
        var tmp$0, tmp$1;
        var currentPath = (tmp$0 = origin.path()) != null ? tmp$0 : Kotlin.throwNPE();
        var composedKey = Kotlin.toString(currentNow) + '/' + currentPath;
        var sequence = this.compare.createSequence();
        var traces = (tmp$1 = this.datastore) != null ? tmp$1.get(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), composedKey) : null;
        if (traces != null) {
          sequence.populateFromString(traces);
          return sequence;
        }
        return null;
      }
    }), TimeAwareKMFContainer: Kotlin.createTrait(KMFContainerProxy, /** @lends _c.TimeAwareKMFContainer.prototype */ {
      shift: function (timePoint) {
        this.now = timePoint;
      },
      deepShift: function (timePoint) {
        throw new Error('WTF exception!!!');
      },
      previous: function () {
        return this;
      },
      next: function () {
        return this;
      }
    }), ModelCompare: Kotlin.createTrait(null, /** @lends _c.ModelCompare.prototype */ {
      diff: function (origin, target) {
        return this.createSequence().populate(this.internal_diff(origin, target, false, false));
      },
      merge: function (origin, target) {
        return this.createSequence().populate(this.internal_diff(origin, target, false, true));
      },
      inter: function (origin, target) {
        return this.createSequence().populate(this.internal_diff(origin, target, true, false));
      },
      internal_diff: function (origin, target, inter, merge) {
        var traces = new Kotlin.ArrayList(0);
        var tracesRef = new Kotlin.ArrayList(0);
        var objectsMap = new Kotlin.PrimitiveHashMap(0);
        traces.addAll(origin.createTraces(target, inter, merge, false, true));
        tracesRef.addAll(origin.createTraces(target, inter, merge, true, false));
        var visitor = _c.ModelCompare.f0(objectsMap);
        origin.visit(visitor, true, true, false);
        var visitor2 = _c.ModelCompare.f1(objectsMap, inter, traces, merge, tracesRef);
        target.visit(visitor2, true, true, false);
        if (!inter) {
          if (!merge) {
            {
              var tmp$0 = objectsMap.values().iterator();
              while (tmp$0.hasNext()) {
                var diffChild = tmp$0.next();
                var tmp$3, tmp$5, tmp$6;
                if (diffChild.eContainer() != null) {
                  var tmp$1, tmp$2;
                  tmp$3 = (tmp$2 = ((tmp$1 = diffChild.eContainer()) != null ? tmp$1 : Kotlin.throwNPE()).path()) != null ? tmp$2 : Kotlin.throwNPE();
                }
                 else {
                  tmp$3 = 'null';
                }
                var src = tmp$3;
                if (diffChild.getRefInParent() != null) {
                  var tmp$4;
                  tmp$5 = (tmp$4 = diffChild.getRefInParent()) != null ? tmp$4 : Kotlin.throwNPE();
                }
                 else {
                  tmp$5 = 'null';
                }
                var refNameInParent = tmp$5;
                traces.add(new _.org.kevoree.modeling.api.trace.ModelRemoveTrace(src, refNameInParent, (tmp$6 = (diffChild != null ? diffChild : Kotlin.throwNPE()).path()) != null ? tmp$6 : Kotlin.throwNPE()));
              }
            }
          }
        }
        traces.addAll(tracesRef);
        return traces;
      }
    }, /** @lends _c.ModelCompare */ {
      f0: function (objectsMap) {
        return Kotlin.createObject(_c.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: function (elem, refNameInParent, parent) {
            var childPath = elem.path();
            if (childPath != null) {
              objectsMap.put(childPath, elem);
            }
             else {
              throw new Error('Null child path ' + elem);
            }
          }
        });
      },
      f1: function (objectsMap, inter, traces, merge, tracesRef) {
        return Kotlin.createObject(_c.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: function (elem, refNameInParent, parent) {
            var childPath = elem.path();
            if (childPath != null) {
              if (objectsMap.containsKey(childPath)) {
                if (inter) {
                  var tmp$0;
                  traces.add(new _.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$0 = parent.path()) != null ? tmp$0 : Kotlin.throwNPE(), refNameInParent, elem.path(), elem.metaClassName()));
                }
                var tmp$1, tmp$2;
                traces.addAll(((tmp$1 = objectsMap.get(childPath)) != null ? tmp$1 : Kotlin.throwNPE()).createTraces(elem, inter, merge, false, true));
                tracesRef.addAll(((tmp$2 = objectsMap.get(childPath)) != null ? tmp$2 : Kotlin.throwNPE()).createTraces(elem, inter, merge, true, false));
                objectsMap.remove(childPath);
              }
               else {
                if (!inter) {
                  var tmp$3;
                  traces.add(new _.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$3 = parent.path()) != null ? tmp$3 : Kotlin.throwNPE(), refNameInParent, elem.path(), elem.metaClassName()));
                  traces.addAll(elem.createTraces(elem, true, merge, false, true));
                  tracesRef.addAll(elem.createTraces(elem, true, merge, true, false));
                }
              }
            }
             else {
              throw new Error('Null child path ' + elem);
            }
          }
        });
      }
    }), XMIModelLoader: Kotlin.createClass(ModelLoader, function () {
      this.resourceSet = null;
      this.LOADER_XMI_LOCAL_NAME = 'type';
      this.LOADER_XMI_XSI = 'xsi';
      this.LOADER_XMI_NS_URI = 'nsURI';
      this.factory = null;
      this.attributesHashmap = new Kotlin.PrimitiveHashMap(0);
      this.referencesHashmap = new Kotlin.PrimitiveHashMap(0);
      this.namedElementSupportActivated = false;
      this.attributeVisitor = _c.XMIModelLoader.f1(this);
      this.referencesVisitor = _c.XMIModelLoader.f3(this);
    }, /** @lends _c.XMIModelLoader.prototype */ {
      activateSupportForNamedElements: function (activate) {
        this.namedElementSupportActivated = activate;
      },
      unescapeXml: function (src) {
        var builder = null;
        var i = 0;
        while (i < src.length) {
          var c = src.charAt(i);
          if (c === '&') {
            if (builder == null) {
              builder = new _.java.lang.StringBuilder();
              (builder != null ? builder : Kotlin.throwNPE()).append(src.substring(0, i));
            }
            if (src.charAt(i + 1) === 'a') {
              if (src.charAt(i + 2) === 'm') {
                builder != null ? builder.append('&') : null;
                i = i + 5;
              }
               else if (src.charAt(i + 2) === 'p') {
                builder != null ? builder.append("'") : null;
                i = i + 6;
              }
               else {
                Kotlin.println('Could not unescaped chain:' + src.charAt(i) + src.charAt(i + 1) + src.charAt(i + 2));
              }
            }
             else if (src.charAt(i + 1) === 'q') {
              builder != null ? builder.append('"') : null;
              i = i + 6;
            }
             else if (src.charAt(i + 1) === 'l') {
              builder != null ? builder.append('<') : null;
              i = i + 4;
            }
             else if (src.charAt(i + 1) === 'g') {
              builder != null ? builder.append('>') : null;
              i = i + 4;
            }
             else {
              Kotlin.println('Could not unescaped chain:' + src.charAt(i) + src.charAt(i + 1));
            }
          }
           else {
            if (builder != null) {
              builder != null ? builder.append_0(c) : null;
            }
            i++;
          }
        }
        if (builder != null) {
          return Kotlin.toString(builder);
        }
         else {
          return src;
        }
      },
      loadModelFromString: function (str) {
        var reader = new _.org.kevoree.modeling.api.xmi.XmlParser(_.org.kevoree.modeling.api.util.ByteConverter.byteArrayInputStreamFromString(str));
        if (reader.hasNext()) {
          return this.deserialize(reader);
        }
         else {
          Kotlin.println('Loader::Nothing in the String !');
          return null;
        }
      },
      loadModelFromStream: function (inputStream) {
        var reader = new _.org.kevoree.modeling.api.xmi.XmlParser(inputStream);
        if (reader.hasNext()) {
          return this.deserialize(reader);
        }
         else {
          Kotlin.println('Loader::Nothing in the file !');
          return null;
        }
      },
      loadObject: function (ctx, xmiAddress, objectType) {
        var tmp$0, tmp$12, tmp$13, tmp$14, tmp$15, tmp$16, tmp$17, tmp$18;
        var elementTagName = ((tmp$0 = ctx.xmiReader) != null ? tmp$0 : Kotlin.throwNPE()).getLocalName();
        var modelElem;
        if (objectType != null) {
          var tmp$1;
          modelElem = (tmp$1 = this.factory) != null ? tmp$1.create(objectType) : null;
          if (modelElem == null) {
            var xsiType = null;
            var tmp$2, tmp$3, tmp$4, tmp$5, tmp$6;
            {
              tmp$3 = new Kotlin.NumberRange(0, ((tmp$2 = ctx.xmiReader) != null ? tmp$2 : Kotlin.throwNPE()).getAttributeCount() - 1), tmp$4 = tmp$3.start, tmp$5 = tmp$3.end, tmp$6 = tmp$3.increment;
              for (var i = tmp$4; i <= tmp$5; i += tmp$6) {
                var tmp$7, tmp$8;
                var localName = ((tmp$7 = ctx.xmiReader) != null ? tmp$7 : Kotlin.throwNPE()).getAttributeLocalName(i);
                var xsi = ((tmp$8 = ctx.xmiReader) != null ? tmp$8 : Kotlin.throwNPE()).getAttributePrefix(i);
                if (Kotlin.equals(localName, this.LOADER_XMI_LOCAL_NAME) && Kotlin.equals(xsi, this.LOADER_XMI_XSI)) {
                  var tmp$9;
                  xsiType = ((tmp$9 = ctx.xmiReader) != null ? tmp$9 : Kotlin.throwNPE()).getAttributeValue(i);
                  break;
                }
              }
            }
            if (xsiType != null) {
              var tmp$10;
              modelElem = (tmp$10 = this.factory) != null ? tmp$10.create((xsiType != null ? xsiType : Kotlin.throwNPE()).substring((xsiType != null ? xsiType : Kotlin.throwNPE()).lastIndexOf(':') + 1, (xsiType != null ? xsiType : Kotlin.throwNPE()).length)) : null;
            }
          }
        }
         else {
          var tmp$11;
          modelElem = (tmp$11 = this.factory) != null ? tmp$11.create(elementTagName) : null;
        }
        if (modelElem == null) {
          Kotlin.println('Could not create an object for local name ' + elementTagName);
        }
        ctx.map.put(xmiAddress, modelElem != null ? modelElem : Kotlin.throwNPE());
        if (!this.attributesHashmap.containsKey((modelElem != null ? modelElem : Kotlin.throwNPE()).metaClassName())) {
          modelElem != null ? modelElem.visitAttributes(this.attributeVisitor) : null;
        }
        var elemAttributesMap = (tmp$12 = this.attributesHashmap.get((modelElem != null ? modelElem : Kotlin.throwNPE()).metaClassName())) != null ? tmp$12 : Kotlin.throwNPE();
        if (!this.referencesHashmap.containsKey((modelElem != null ? modelElem : Kotlin.throwNPE()).metaClassName())) {
          modelElem != null ? modelElem.visit(this.referencesVisitor, false, true, false) : null;
        }
        var elemReferencesMap = (tmp$13 = this.referencesHashmap.get((modelElem != null ? modelElem : Kotlin.throwNPE()).metaClassName())) != null ? tmp$13 : Kotlin.throwNPE();
        {
          tmp$15 = new Kotlin.NumberRange(0, ((tmp$14 = ctx.xmiReader) != null ? tmp$14 : Kotlin.throwNPE()).getAttributeCount() - 1), tmp$16 = tmp$15.start, tmp$17 = tmp$15.end, tmp$18 = tmp$15.increment;
          for (var i_0 = tmp$16; i_0 <= tmp$17; i_0 += tmp$18) {
            var tmp$19;
            var prefix = ((tmp$19 = ctx.xmiReader) != null ? tmp$19 : Kotlin.throwNPE()).getAttributePrefix(i_0);
            if (prefix == null || Kotlin.equals(prefix, '')) {
              var tmp$20, tmp$21;
              var attrName = ((tmp$20 = ctx.xmiReader) != null ? tmp$20 : Kotlin.throwNPE()).getAttributeLocalName(i_0).trim();
              var valueAtt = ((tmp$21 = ctx.xmiReader) != null ? tmp$21 : Kotlin.throwNPE()).getAttributeValue(i_0).trim();
              if (valueAtt != null) {
                if (elemAttributesMap.containsKey(attrName)) {
                  modelElem != null ? modelElem.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, attrName, this.unescapeXml(valueAtt), false, false) : null;
                  if (this.namedElementSupportActivated && Kotlin.equals(attrName, 'name')) {
                    var parent = ctx.map.get(xmiAddress.substring(0, xmiAddress.lastIndexOf('/')));
                    {
                      var tmp$22 = _.kotlin.toList(ctx.map.entrySet()).iterator();
                      while (tmp$22.hasNext()) {
                        var entry = tmp$22.next();
                        if (Kotlin.equals(_.kotlin.get_value(entry), parent)) {
                          var refT = _.kotlin.get_key(entry) + '/' + this.unescapeXml(valueAtt);
                          ctx.map.put(refT, modelElem != null ? modelElem : Kotlin.throwNPE());
                        }
                      }
                    }
                  }
                }
                 else {
                  if (!valueAtt.startsWith('#') && !valueAtt.startsWith('/')) {
                    if (this.resourceSet != null) {
                      var tmp$23;
                      var previousLoadedRef = ((tmp$23 = this.resourceSet) != null ? tmp$23 : Kotlin.throwNPE()).resolveObject(valueAtt);
                      if (previousLoadedRef != null) {
                        modelElem != null ? modelElem.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, attrName, previousLoadedRef, true, false) : null;
                      }
                       else {
                        throw new Error('Unresolve NsURI based XMI reference ' + valueAtt);
                      }
                    }
                     else {
                      throw new Error('Bad XMI reference ' + valueAtt);
                    }
                  }
                   else {
                    var tmp$24, tmp$25, tmp$26;
                    {
                      tmp$24 = Kotlin.splitString(valueAtt, ' '), tmp$25 = tmp$24.length;
                      for (var tmp$26 = 0; tmp$26 !== tmp$25; ++tmp$26) {
                        var xmiRef = tmp$24[tmp$26];
                        var tmp$27, tmp$28;
                        if (xmiRef.startsWith('#')) {
                          tmp$27 = xmiRef.substring(1);
                        }
                         else {
                          tmp$27 = xmiRef;
                        }
                        var adjustedRef = tmp$27;
                        if (adjustedRef.startsWith('//')) {
                          tmp$28 = '/0' + adjustedRef.substring(1);
                        }
                         else {
                          tmp$28 = adjustedRef;
                        }
                        adjustedRef = tmp$28;
                        adjustedRef = adjustedRef.replace('.0', '');
                        var ref = ctx.map.get(adjustedRef);
                        if (ref != null) {
                          modelElem != null ? modelElem.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, attrName, ref, true, false) : null;
                        }
                         else {
                          ctx.resolvers.add(new _.org.kevoree.modeling.api.xmi.XMIResolveCommand(ctx, modelElem != null ? modelElem : Kotlin.throwNPE(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, attrName, adjustedRef, this.resourceSet));
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        var done = false;
        while (!done) {
          var tmp$29;
          var tmp$30 = ((tmp$29 = ctx.xmiReader) != null ? tmp$29 : Kotlin.throwNPE()).next();
          if (tmp$30 === _.org.kevoree.modeling.api.xmi.Token.START_TAG) {
            var tmp$31, tmp$32, tmp$34;
            var subElemName = ((tmp$31 = ctx.xmiReader) != null ? tmp$31 : Kotlin.throwNPE()).getLocalName();
            var i_1 = (tmp$32 = ctx.elementsCount.get(xmiAddress + '/@' + subElemName)) != null ? tmp$32 : 0;
            var tmp$33 = xmiAddress + '/@' + subElemName;
            if (i_1 !== 0) {
              tmp$34 = '.' + i_1;
            }
             else {
              tmp$34 = '';
            }
            var subElementId = tmp$33 + tmp$34;
            var containedElement = this.loadObject(ctx, subElementId, elemReferencesMap.get(subElemName));
            modelElem != null ? modelElem.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, subElemName != null ? subElemName : Kotlin.throwNPE(), containedElement, true, false) : null;
            ctx.elementsCount.put(xmiAddress + '/@' + subElemName, i_1 + 1);
          }
           else if (tmp$30 === _.org.kevoree.modeling.api.xmi.Token.END_TAG) {
            var tmp$35;
            if (Kotlin.equals(((tmp$35 = ctx.xmiReader) != null ? tmp$35 : Kotlin.throwNPE()).getLocalName(), elementTagName)) {
              done = true;
            }
          }
           else {
          }
        }
        return modelElem != null ? modelElem : Kotlin.throwNPE();
      },
      deserialize: function (reader) {
        var nsURI = null;
        var context = new _.org.kevoree.modeling.api.xmi.LoadingContext();
        context.xmiReader = reader;
        while (reader.hasNext()) {
          var nextTag = reader.next();
          if (nextTag === _.org.kevoree.modeling.api.xmi.Token.START_TAG) {
            var localName = reader.getLocalName();
            if (localName != null) {
              var loadedRootsSize = context.loadedRoots.size();
              var tmp$0, tmp$1, tmp$2, tmp$3, tmp$4;
              {
                tmp$1 = new Kotlin.NumberRange(0, ((tmp$0 = context.xmiReader) != null ? tmp$0 : Kotlin.throwNPE()).getAttributeCount() - 1), tmp$2 = tmp$1.start, tmp$3 = tmp$1.end, tmp$4 = tmp$1.increment;
                for (var i = tmp$2; i <= tmp$3; i += tmp$4) {
                  var tmp$5, tmp$6;
                  var localName_0 = ((tmp$5 = context.xmiReader) != null ? tmp$5 : Kotlin.throwNPE()).getAttributeLocalName(i);
                  var localValue = ((tmp$6 = context.xmiReader) != null ? tmp$6 : Kotlin.throwNPE()).getAttributeValue(i);
                  if (Kotlin.equals(localName_0, this.LOADER_XMI_NS_URI)) {
                    nsURI = localValue;
                  }
                }
              }
              context.loadedRoots.add(this.loadObject(context, '/' + loadedRootsSize, null));
            }
             else {
              Kotlin.println('Tried to read a tag with null tag_name.');
            }
          }
           else if (nextTag === _.org.kevoree.modeling.api.xmi.Token.END_TAG) {
            break;
          }
           else if (nextTag === _.org.kevoree.modeling.api.xmi.Token.END_DOCUMENT) {
            break;
          }
           else {
          }
        }
        {
          var tmp$7 = context.resolvers.iterator();
          while (tmp$7.hasNext()) {
            var res = tmp$7.next();
            res.run();
          }
        }
        if (this.resourceSet != null && nsURI != null) {
          var tmp$8;
          ((tmp$8 = this.resourceSet) != null ? tmp$8 : Kotlin.throwNPE()).registerXmiAddrMappedObjects(nsURI != null ? nsURI : Kotlin.throwNPE(), context.map);
        }
        return context.loadedRoots;
      }
    }, /** @lends _c.XMIModelLoader */ {
      f0: function () {
        return new Kotlin.PrimitiveHashMap(0);
      },
      f1: function ($outer) {
        return Kotlin.createObject(_c.ModelAttributeVisitor, null, {
          visit: function (value, name, parent) {
            _.kotlin.getOrPut($outer.attributesHashmap, parent.metaClassName(), _c.XMIModelLoader.f0).put(name, true);
          }
        });
      },
      f2: function () {
        return new Kotlin.PrimitiveHashMap(0);
      },
      f3: function ($outer) {
        return Kotlin.createObject(_c.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
          this.refMap = null;
        }, {
          beginVisitElem: function (elem) {
            this.refMap = _.kotlin.getOrPut($outer.referencesHashmap, elem.metaClassName(), _c.XMIModelLoader.f2);
          },
          endVisitElem: function (elem) {
            this.refMap = null;
          },
          beginVisitRef: function (refName, refType) {
            var tmp$0;
            ((tmp$0 = this.refMap) != null ? tmp$0 : Kotlin.throwNPE()).put(refName, refType);
          },
          visit: function (elem, refNameInParent, parent) {
          }
        });
      }
    }), XMIModelSerializer: Kotlin.createClass(ModelSerializer, function () {
      this.resourceSet = null;
      this.ignoreGeneratedID = false;
    }, /** @lends _c.XMIModelSerializer.prototype */ {
      serialize: function (oMS) {
        var oo = new _.java.io.ByteArrayOutputStream();
        this.serializeToStream(oMS, oo);
        oo.flush();
        return oo.toString();
      },
      serializeToStream: function (oMS, ostream) {
        var wt = new _.java.io.PrintStream(new _.java.io.BufferedOutputStream(ostream), false);
        var addressTable = new Kotlin.ComplexHashMap(0);
        var packageList = new Kotlin.ArrayList(0);
        addressTable.put(oMS, '/');
        var elementsCount = new Kotlin.PrimitiveHashMap(0);
        var addressBuilderVisitor = new _.org.kevoree.modeling.api.xmi.ModelAddressVisitor(addressTable, elementsCount, packageList);
        oMS.visit(addressBuilderVisitor, true, true, false);
        var masterVisitor = new _.org.kevoree.modeling.api.xmi.ModelSerializationVisitor(wt, addressTable, elementsCount, this.resourceSet, this.ignoreGeneratedID);
        wt.println_0('<?xml version="1.0" encoding="UTF-8"?>');
        wt.print('<' + this.formatMetaClassName(oMS.metaClassName()).replace('.', '_'));
        wt.print(' xmlns:xsi="http://wwww.w3.org/2001/XMLSchema-instance"');
        wt.print(' xmi:version="2.0"');
        wt.print(' xmlns:xmi="http://www.omg.org/XMI"');
        var index = 0;
        while (index < _.kotlin.get_size_1(packageList)) {
          wt.print(' xmlns:' + packageList.get(index).replace('.', '_') + '="http://' + packageList.get(index) + '"');
          index++;
        }
        oMS.visitAttributes(new _.org.kevoree.modeling.api.xmi.AttributesVisitor(wt, this.ignoreGeneratedID));
        oMS.visit(new _.org.kevoree.modeling.api.xmi.ReferencesVisitor(wt, addressTable, elementsCount, this.resourceSet), false, false, true);
        wt.println_0('>');
        oMS.visit(masterVisitor, false, true, false);
        wt.println_0('<\/' + this.formatMetaClassName(oMS.metaClassName()).replace('.', '_') + '>');
        wt.flush();
      },
      formatMetaClassName: function (metaClassName) {
        var lastPoint = _.js.lastIndexOf(metaClassName, '.');
        var pack = metaClassName.substring(0, lastPoint);
        var cls = metaClassName.substring(lastPoint + 1);
        return pack + ':' + cls;
      }
    }), ModelTrace: Kotlin.createTrait(null), TraceConverter: Kotlin.createTrait(null), TraceSequence: Kotlin.createTrait(null, /** @lends _c.TraceSequence.prototype */ {
      populate: function (addtraces) {
        this.traces.addAll(addtraces);
        return this;
      },
      append: function (seq) {
        this.traces.addAll(seq.traces);
      },
      populateFromString: function (addtracesTxt) {
        return this.populateFromStream(_.org.kevoree.modeling.api.util.ByteConverter.byteArrayInputStreamFromString(addtracesTxt));
      },
      populateFromStream: function (inputStream) {
        var lexer = new _.org.kevoree.modeling.api.json.Lexer(inputStream);
        var currentToken = lexer.nextToken();
        if (currentToken.tokenType !== _.org.kevoree.modeling.api.json.Type.LEFT_BRACKET) {
          throw new Error('Bad Format : expect [');
        }
        currentToken = lexer.nextToken();
        var keys = new Kotlin.PrimitiveHashMap(0);
        var previousName = null;
        while (currentToken.tokenType !== _.org.kevoree.modeling.api.json.Type.EOF && currentToken.tokenType !== _.org.kevoree.modeling.api.json.Type.RIGHT_BRACKET) {
          if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACE) {
            keys.clear();
          }
          if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.VALUE) {
            if (previousName != null) {
              keys.put(previousName != null ? previousName : Kotlin.throwNPE(), Kotlin.toString(currentToken.value));
              previousName = null;
            }
             else {
              previousName = Kotlin.toString(currentToken.value);
            }
          }
          if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.RIGHT_BRACE) {
            var tmp$0;
            var tmp$1 = (tmp$0 = keys.get('traceType')) != null ? tmp$0 : Kotlin.throwNPE();
            if (tmp$1 === Kotlin.toString(_.org.kevoree.modeling.api.util.ActionType.object.SET)) {
              var tmp$2, tmp$3;
              this.traces.add(new _.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$2 = keys.get('src')) != null ? tmp$2 : Kotlin.throwNPE(), (tmp$3 = keys.get('refname')) != null ? tmp$3 : Kotlin.throwNPE(), keys.get('objpath'), keys.get('content'), keys.get('typename')));
            }
             else if (tmp$1 === Kotlin.toString(_.org.kevoree.modeling.api.util.ActionType.object.ADD)) {
              var tmp$4, tmp$5, tmp$6;
              this.traces.add(new _.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$4 = keys.get('src')) != null ? tmp$4 : Kotlin.throwNPE(), (tmp$5 = keys.get('refname')) != null ? tmp$5 : Kotlin.throwNPE(), (tmp$6 = keys.get('previouspath')) != null ? tmp$6 : Kotlin.throwNPE(), keys.get('typename')));
            }
             else if (tmp$1 === Kotlin.toString(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL)) {
              var tmp$7, tmp$8, tmp$9, tmp$10, tmp$11, tmp$12;
              this.traces.add(new _.org.kevoree.modeling.api.trace.ModelAddAllTrace((tmp$7 = keys.get('src')) != null ? tmp$7 : Kotlin.throwNPE(), (tmp$8 = keys.get('refname')) != null ? tmp$8 : Kotlin.throwNPE(), (tmp$10 = (tmp$9 = keys.get('content')) != null ? Kotlin.splitString(tmp$9, ';') : null) != null ? _.kotlin.toList_8(tmp$10) : null, (tmp$12 = (tmp$11 = keys.get('typename')) != null ? Kotlin.splitString(tmp$11, ';') : null) != null ? _.kotlin.toList_8(tmp$12) : null));
            }
             else if (tmp$1 === Kotlin.toString(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE)) {
              var tmp$13, tmp$14, tmp$15;
              this.traces.add(new _.org.kevoree.modeling.api.trace.ModelRemoveTrace((tmp$13 = keys.get('src')) != null ? tmp$13 : Kotlin.throwNPE(), (tmp$14 = keys.get('refname')) != null ? tmp$14 : Kotlin.throwNPE(), (tmp$15 = keys.get('objpath')) != null ? tmp$15 : Kotlin.throwNPE()));
            }
             else if (tmp$1 === Kotlin.toString(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL)) {
              var tmp$16, tmp$17;
              this.traces.add(new _.org.kevoree.modeling.api.trace.ModelRemoveAllTrace((tmp$16 = keys.get('src')) != null ? tmp$16 : Kotlin.throwNPE(), (tmp$17 = keys.get('refname')) != null ? tmp$17 : Kotlin.throwNPE()));
            }
             else if (tmp$1 === Kotlin.toString(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX)) {
            }
             else {
              Kotlin.println('Trace lost !!!');
            }
          }
          currentToken = lexer.nextToken();
        }
        return this;
      },
      exportToString: function () {
        var buffer = new _.java.lang.StringBuilder();
        buffer.append('[');
        var isFirst = true;
        {
          var tmp$0 = this.traces.iterator();
          while (tmp$0.hasNext()) {
            var trace = tmp$0.next();
            if (!isFirst) {
              buffer.append(',\n');
            }
            buffer.append(trace.toString());
            isFirst = false;
          }
        }
        buffer.append(']');
        return buffer.toString();
      },
      toString: function () {
        return this.exportToString();
      },
      applyOn: function (target) {
        var tmp$0;
        var traceApplicator = new _.org.kevoree.modeling.api.trace.ModelTraceApplicator(target, (tmp$0 = this.factory) != null ? tmp$0 : Kotlin.throwNPE());
        traceApplicator.applyTraceOnModel(this);
        return true;
      },
      silentlyApplyOn: function (target) {
        var tmp$0;
        var traceApplicator = new _.org.kevoree.modeling.api.trace.ModelTraceApplicator(target, (tmp$0 = this.factory) != null ? tmp$0 : Kotlin.throwNPE());
        traceApplicator.fireEvents = false;
        traceApplicator.applyTraceOnModel(this);
        return true;
      },
      reverse: function () {
        var tmp$0;
        this.traces = (tmp$0 = _.kotlin.reverse_7(this.traces)) != null ? tmp$0 : Kotlin.throwNPE();
      }
    }), ModelCloner: Kotlin.createTrait(null, /** @lends _c.ModelCloner.prototype */ {
      clone: function (o) {
        return this.clone_0(o, false);
      },
      clone_0: function (o, readOnly) {
        return this.clone_1(o, readOnly, false);
      },
      cloneMutableOnly: function (o, readOnly) {
        return this.clone_1(o, readOnly, true);
      },
      cloneModelElem: function (src) {
        var tmp$0;
        var clonedSrc = (tmp$0 = this.mainFactory.create(src.metaClassName())) != null ? tmp$0 : Kotlin.throwNPE();
        var attributesCloner = _c.ModelCloner.f0(clonedSrc);
        src.visitAttributes(attributesCloner);
        return clonedSrc;
      },
      resolveModelElem: function (src, target, context, mutableOnly) {
        var refResolver = _c.ModelCloner.f1(mutableOnly, target, context);
        src.visit(refResolver, false, true, true);
      },
      clone_1: function (o, readOnly, mutableOnly) {
        var context = this.createContext();
        var clonedObject = this.cloneModelElem(o);
        context.put(o, clonedObject);
        var cloneGraphVisitor = _c.ModelCloner.f2(this, mutableOnly, context);
        o.visit(cloneGraphVisitor, true, true, false);
        var resolveGraphVisitor = _c.ModelCloner.f3(this, mutableOnly, context, readOnly);
        this.resolveModelElem(o, clonedObject, context, mutableOnly);
        o.visit(resolveGraphVisitor, true, true, false);
        if (readOnly) {
          clonedObject.setInternalReadOnly();
        }
        return clonedObject != null ? clonedObject : Kotlin.throwNPE();
      }
    }, /** @lends _c.ModelCloner */ {
      f0: function (clonedSrc) {
        return Kotlin.createObject(_c.ModelAttributeVisitor, null, {
          visit: function (value, name, parent) {
            if (value != null) {
              if (Kotlin.isType(value, Kotlin.ArrayList)) {
                var clonedList = new Kotlin.ArrayList(0);
                clonedList.addAll(value != null ? value : Kotlin.throwNPE());
                clonedSrc.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, name, clonedList, false, false);
              }
               else {
                clonedSrc.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, name, value, false, false);
              }
            }
          }
        });
      },
      f1: function (mutableOnly, target, context) {
        return Kotlin.createObject(_c.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: function (elem, refNameInParent, parent) {
            if (mutableOnly && elem.isRecursiveReadOnly()) {
              target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, refNameInParent, elem, false, false);
            }
             else {
              target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, refNameInParent, context.get(elem), false, false);
            }
          }
        });
      },
      f2: function ($outer, mutableOnly, context) {
        return Kotlin.createObject(_c.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: function (elem, refNameInParent, parent) {
            if (mutableOnly && elem.isRecursiveReadOnly()) {
              this.noChildrenVisit();
            }
             else {
              context.put(elem, $outer.cloneModelElem(elem));
            }
          }
        });
      },
      f3: function ($outer, mutableOnly, context, readOnly) {
        return Kotlin.createObject(_c.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: function (elem, refNameInParent, parent) {
            if (mutableOnly && elem.isRecursiveReadOnly()) {
            }
             else {
              var tmp$0;
              var clonedObj = (tmp$0 = context.get(elem)) != null ? tmp$0 : Kotlin.throwNPE();
              $outer.resolveModelElem(elem, clonedObj, context, mutableOnly);
              if (readOnly) {
                clonedObj.setInternalReadOnly();
              }
            }
          }
        });
      }
    }), JSONModelLoader: Kotlin.createClass(ModelLoader, function () {
      this.factory = null;
    }, /** @lends _c.JSONModelLoader.prototype */ {
      loadModelFromString: function (str) {
        return this.deserialize(_.org.kevoree.modeling.api.util.ByteConverter.byteArrayInputStreamFromString(str));
      },
      loadModelFromStream: function (inputStream) {
        return this.deserialize(inputStream);
      },
      deserialize: function (instream) {
        var resolverCommands = new Kotlin.ArrayList(0);
        var roots = new Kotlin.ArrayList(0);
        var lexer = new _.org.kevoree.modeling.api.json.Lexer(instream);
        var currentToken = lexer.nextToken();
        if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACE) {
          this.loadObject(lexer, null, null, roots, resolverCommands);
        }
         else {
          throw new Error('Bad Format / {\xA0expected');
        }
        {
          var tmp$0 = resolverCommands.iterator();
          while (tmp$0.hasNext()) {
            var resol = tmp$0.next();
            resol.run();
          }
        }
        return roots;
      },
      loadObject: function (lexer, nameInParent, parent, roots, commands) {
        var currentToken = lexer.nextToken();
        var currentObject = null;
        if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.VALUE) {
          if (Kotlin.equals(currentToken.value, 'eClass')) {
            lexer.nextToken();
            currentToken = lexer.nextToken();
            var tmp$0, tmp$1;
            var name = (tmp$0 = Kotlin.toString(currentToken.value)) != null ? tmp$0 : Kotlin.throwNPE();
            currentObject = (tmp$1 = this.factory) != null ? tmp$1.create(name) : null;
            if (parent == null) {
              roots.add(currentObject != null ? currentObject : Kotlin.throwNPE());
            }
            var currentNameAttOrRef = null;
            var refModel = false;
            currentToken = lexer.nextToken();
            while (currentToken.tokenType !== _.org.kevoree.modeling.api.json.Type.EOF) {
              if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACE) {
                this.loadObject(lexer, currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE(), currentObject, roots, commands);
              }
              if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.COMMA) {
              }
              if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.VALUE) {
                if (currentNameAttOrRef == null) {
                  currentNameAttOrRef = Kotlin.toString(currentToken.value);
                }
                 else {
                  if (refModel) {
                    var tmp$2;
                    commands.add(new _.org.kevoree.modeling.api.json.ResolveCommand(roots, Kotlin.toString((tmp$2 = currentToken.value) != null ? tmp$2 : Kotlin.throwNPE()), currentObject != null ? currentObject : Kotlin.throwNPE(), currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE()));
                  }
                   else {
                    (currentObject != null ? currentObject : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE(), this.unescapeJSON(Kotlin.toString(currentToken.value)), false, false);
                    currentNameAttOrRef = null;
                  }
                }
              }
              if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACKET) {
                currentToken = lexer.nextToken();
                if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACE) {
                  this.loadObject(lexer, currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE(), currentObject, roots, commands);
                }
                 else {
                  refModel = true;
                  if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.VALUE) {
                    var tmp$3;
                    commands.add(new _.org.kevoree.modeling.api.json.ResolveCommand(roots, Kotlin.toString((tmp$3 = currentToken.value) != null ? tmp$3 : Kotlin.throwNPE()), currentObject != null ? currentObject : Kotlin.throwNPE(), currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE()));
                  }
                }
              }
              if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.RIGHT_BRACKET) {
                currentNameAttOrRef = null;
                refModel = false;
              }
              if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.RIGHT_BRACE) {
                if (parent != null) {
                  parent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, nameInParent != null ? nameInParent : Kotlin.throwNPE(), currentObject, false, false);
                }
                return;
              }
              currentToken = lexer.nextToken();
            }
          }
           else {
            throw new Error('Bad Format / eClass att must be first');
          }
        }
         else {
          throw new Error('Bad Format');
        }
      },
      unescapeJSON: function (src) {
        var builder = null;
        var i = 0;
        while (i < src.length) {
          var c = src.charAt(i);
          if (c === '&') {
            if (builder == null) {
              builder = src.substring(0, i);
            }
            if (src.charAt(i + 1) === 'a') {
              builder = (builder != null ? builder : Kotlin.throwNPE()) + "'";
              i = i + 6;
            }
             else if (src.charAt(i + 1) === 'q') {
              builder = (builder != null ? builder : Kotlin.throwNPE()) + '"';
              i = i + 6;
            }
             else {
              Kotlin.println('Could not unescaped chain:' + src.charAt(i) + src.charAt(i + 1));
            }
          }
           else {
            if (builder != null) {
              builder = (builder != null ? builder : Kotlin.throwNPE()) + c;
            }
            i++;
          }
        }
        if (builder != null) {
          return builder != null ? builder : Kotlin.throwNPE();
        }
         else {
          return src;
        }
      }
    }), JSONModelSerializer: Kotlin.createClass(ModelSerializer, null, /** @lends _c.JSONModelSerializer.prototype */ {
      serialize: function (model) {
        var outstream = new _.java.io.ByteArrayOutputStream();
        this.serializeToStream(model, outstream);
        outstream.close();
        return outstream.toString();
      },
      serializeToStream: function (model, raw) {
        var out = new _.java.io.PrintStream(new _.java.io.BufferedOutputStream(raw), false);
        var internalReferenceVisitor = new _.org.kevoree.modeling.api.json.ModelReferenceVisitor(out);
        var masterVisitor = _c.JSONModelSerializer.f0(this, out, internalReferenceVisitor);
        model.visit(masterVisitor, true, true, false);
        out.flush();
      },
      printAttName: function (elem, out) {
        out.print('\n{"eClass":"' + elem.metaClassName() + '"');
        var attributeVisitor = _c.JSONModelSerializer.f1(this, out);
        elem.visitAttributes(attributeVisitor);
      },
      escapeJson: function (ostream, chain) {
        if (chain == null) {
          return;
        }
        var i = 0;
        while (i < chain.length) {
          var c = chain.charAt(i);
          if (c === '"') {
            ostream.print('&quot;');
          }
           else if (c === "'") {
            ostream.print('&apos;');
          }
           else {
            ostream.print_0(c);
          }
          i = i + 1;
        }
      }
    }, /** @lends _c.JSONModelSerializer */ {
      f0: function ($outer, out, internalReferenceVisitor) {
        return Kotlin.createObject(_c.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
          this.isFirstInRef = true;
        }, {
          beginVisitElem: function (elem) {
            if (!this.isFirstInRef) {
              out.print(',');
              this.isFirstInRef = false;
            }
            $outer.printAttName(elem, out);
            var tmp$0;
            (tmp$0 = internalReferenceVisitor.alreadyVisited) != null ? tmp$0.clear() : null;
            elem.visit(internalReferenceVisitor, false, false, true);
          },
          endVisitElem: function (elem) {
            out.println_0('}');
            this.isFirstInRef = false;
          },
          beginVisitRef: function (refName, refType) {
            out.print(',"' + refName + '":[');
            this.isFirstInRef = true;
          },
          endVisitRef: function (refName) {
            out.print(']');
            this.isFirstInRef = false;
          },
          visit: function (elem, refNameInParent, parent) {
          }
        });
      },
      f1: function ($outer, out) {
        return Kotlin.createObject(_c.ModelAttributeVisitor, null, {
          visit: function (value, name, parent) {
            if (value != null) {
              out.print(',"' + name + '":"');
              if (Kotlin.isType(value, Date)) {
                $outer.escapeJson(out, '' + value.getTime());
              }
               else {
                $outer.escapeJson(out, _.org.kevoree.modeling.api.util.AttConverter.convFlatAtt(value));
              }
              out.print('"');
            }
          }
        });
      }
    }), ModelElementListener: Kotlin.createTrait(null), NamedElement: NamedElement, Instance: Instance, ComponentInstance: Kotlin.createTrait([Instance, KMFContainer]), TypeDefinition: TypeDefinition, ComponentType: Kotlin.createTrait([TypeDefinition, KMFContainer]), ContainerNode: Kotlin.createTrait([Instance, KMFContainer]), ContainerRoot: Kotlin.createTrait(KMFContainer), PortType: PortType, Port: Kotlin.createTrait(KMFContainer), Namespace: Kotlin.createTrait([NamedElement, KMFContainer]), Dictionary: Dictionary, FragmentDictionary: Kotlin.createTrait([Dictionary, KMFContainer]), DictionaryType: Kotlin.createTrait(KMFContainer), TypedElement: TypedElement, DictionaryAttribute: Kotlin.createTrait([TypedElement, KMFContainer]), DictionaryValue: Kotlin.createTrait(KMFContainer), PortTypeRef: Kotlin.createTrait([NamedElement, KMFContainer]), ServicePortType: Kotlin.createTrait([PortType, KMFContainer]), Operation: Kotlin.createTrait([NamedElement, KMFContainer]), Parameter: Kotlin.createTrait([NamedElement, KMFContainer]), MessagePortType: Kotlin.createTrait([PortType, KMFContainer]), Repository: Kotlin.createTrait(KMFContainer), DeployUnit: Kotlin.createTrait([NamedElement, KMFContainer]), TypeLibrary: Kotlin.createTrait([NamedElement, KMFContainer]), PortTypeMapping: Kotlin.createTrait(KMFContainer), Channel: Kotlin.createTrait([Instance, KMFContainer]), MBinding: Kotlin.createTrait(KMFContainer), NodeNetwork: Kotlin.createTrait(KMFContainer), NodeLink: Kotlin.createTrait(KMFContainer), NetworkInfo: Kotlin.createTrait([NamedElement, KMFContainer]), NetworkProperty: Kotlin.createTrait([NamedElement, KMFContainer]), ChannelType: Kotlin.createTrait([TypeDefinition, KMFContainer]), Group: Kotlin.createTrait([Instance, KMFContainer]), GroupType: Kotlin.createTrait([TypeDefinition, KMFContainer]), NodeType: Kotlin.createTrait([TypeDefinition, KMFContainer]), KMFContainerImpl: Kotlin.createTrait(KMFContainer, /** @lends _c.KMFContainerImpl.prototype */ {
      eContainer: function () {
        return this.internal_eContainer;
      },
      setRecursiveReadOnly: function () {
        if (Kotlin.equals(this.internal_recursive_readOnlyElem, true)) {
          return;
        }
        this.setInternalRecursiveReadOnly();
        var recVisitor = _c.KMFContainerImpl.f0();
        this.visit(recVisitor, true, true, true);
        this.setInternalReadOnly();
      },
      setInternalReadOnly: function () {
        this.internal_readOnlyElem = true;
      },
      setInternalRecursiveReadOnly: function () {
        this.internal_recursive_readOnlyElem = true;
      },
      getRefInParent: function () {
        return this.internal_containmentRefName;
      },
      isReadOnly: function () {
        return this.internal_readOnlyElem;
      },
      isRecursiveReadOnly: function () {
        return this.internal_recursive_readOnlyElem;
      },
      setEContainer: function (container, unsetCmd, refNameInParent) {
        if (this.internal_readOnlyElem) {
          return;
        }
        if (Kotlin.equals(this.eContainer(), container)) {
          return;
        }
        var tempUnsetCmd = this.internal_unsetCmd;
        this.internal_unsetCmd = null;
        if (tempUnsetCmd != null) {
          tempUnsetCmd.run();
        }
        this.internal_eContainer = container;
        this.internal_unsetCmd = unsetCmd;
        this.internal_containmentRefName = refNameInParent;
        this.path_cache = null;
        this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
      },
      selectByQuery: function (query) {
        throw new Error('Not activated, please add selector option in KMF generation plugin');
      },
      fireModelEvent: function (evt) {
        if (this.internal_modelElementListeners != null) {
          var tmp$0;
          {
            var tmp$1 = ((tmp$0 = this.internal_modelElementListeners) != null ? tmp$0 : Kotlin.throwNPE()).iterator();
            while (tmp$1.hasNext()) {
              var lst = tmp$1.next();
              lst.elementChanged(evt);
            }
          }
        }
        this.fireModelEventOnTree(evt);
      },
      addModelElementListener: function (lst) {
        if (this.internal_modelElementListeners == null) {
          this.internal_modelElementListeners = new Kotlin.ArrayList(0);
        }
        var tmp$0;
        ((tmp$0 = this.internal_modelElementListeners) != null ? tmp$0 : Kotlin.throwNPE()).add(lst);
      },
      removeModelElementListener: function (lst) {
        if (this.internal_modelElementListeners != null) {
          var tmp$0, tmp$1;
          ((tmp$0 = this.internal_modelElementListeners) != null ? tmp$0 : Kotlin.throwNPE()).remove(lst);
          if (((tmp$1 = this.internal_modelElementListeners) != null ? tmp$1 : Kotlin.throwNPE()).isEmpty()) {
            this.internal_modelElementListeners = null;
          }
        }
      },
      removeAllModelElementListeners: function () {
        if (this.internal_modelElementListeners != null) {
          var tmp$0;
          ((tmp$0 = this.internal_modelElementListeners) != null ? tmp$0 : Kotlin.throwNPE()).clear();
          this.internal_modelElementListeners = null;
        }
      },
      fireModelEventOnTree: function (evt) {
        if (this.internal_modelTreeListeners != null) {
          var tmp$0;
          {
            var tmp$1 = ((tmp$0 = this.internal_modelTreeListeners) != null ? tmp$0 : Kotlin.throwNPE()).iterator();
            while (tmp$1.hasNext()) {
              var lst = tmp$1.next();
              lst.elementChanged(evt);
            }
          }
        }
        if (this.eContainer() != null) {
          var tmp$2;
          ((tmp$2 = this.eContainer()) != null ? tmp$2 : Kotlin.throwNPE()).fireModelEventOnTree(evt);
        }
      },
      addModelTreeListener: function (lst) {
        if (this.internal_modelTreeListeners == null) {
          this.internal_modelTreeListeners = new Kotlin.ArrayList(0);
        }
        var tmp$0;
        ((tmp$0 = this.internal_modelTreeListeners) != null ? tmp$0 : Kotlin.throwNPE()).add(lst);
      },
      removeModelTreeListener: function (lst) {
        if (this.internal_modelTreeListeners != null) {
          var tmp$0, tmp$1;
          ((tmp$0 = this.internal_modelTreeListeners) != null ? tmp$0 : Kotlin.throwNPE()).remove(lst);
          if (((tmp$1 = this.internal_modelTreeListeners) != null ? tmp$1 : Kotlin.throwNPE()).isEmpty()) {
            this.internal_modelTreeListeners = null;
          }
        }
      },
      removeAllModelTreeListeners: function () {
        if (this.internal_modelTreeListeners != null) {
          var tmp$0;
          ((tmp$0 = this.internal_modelTreeListeners) != null ? tmp$0 : Kotlin.throwNPE()).clear();
          this.internal_modelElementListeners = null;
        }
      },
      visit: function (visitor, recursive, containedReference, nonContainedReference) {
      },
      visitAttributes: function (visitor) {
      },
      internal_visit: function (visitor, internalElem, recursive, containedReference, nonContainedReference, refName) {
        if (internalElem != null) {
          if (nonContainedReference && recursive) {
            var tmp$0, tmp$1, tmp$2;
            var elemPath = (tmp$0 = internalElem.path()) != null ? tmp$0 : Kotlin.throwNPE();
            if (visitor.alreadyVisited != null && ((tmp$1 = visitor.alreadyVisited) != null ? tmp$1 : Kotlin.throwNPE()).containsKey(elemPath)) {
              return;
            }
            if (visitor.alreadyVisited == null) {
              visitor.alreadyVisited = new Kotlin.PrimitiveHashMap(0);
            }
            ((tmp$2 = visitor.alreadyVisited) != null ? tmp$2 : Kotlin.throwNPE()).put(elemPath, internalElem);
          }
          visitor.visit(internalElem, refName, this);
          if (!visitor.visitStopped) {
            if (recursive && (visitor.visitChildren || visitor.visitReferences)) {
              var visitSubReferences = nonContainedReference && visitor.visitReferences;
              var visitSubChilds = containedReference && visitor.visitChildren;
              internalElem.visit(visitor, recursive, visitSubChilds, visitSubReferences);
            }
            visitor.visitChildren = true;
            visitor.visitReferences = true;
          }
        }
      },
      path: function () {
        if (this.path_cache != null) {
          return this.path_cache;
        }
        var container = this.eContainer();
        if (container != null) {
          var parentPath = container.path();
          if (parentPath == null) {
            return null;
          }
           else {
            var tmp$0;
            if (Kotlin.equals(parentPath, '')) {
              tmp$0 = '';
            }
             else {
              tmp$0 = parentPath + '/';
            }
            this.path_cache = tmp$0 + this.internal_containmentRefName + '[' + this.internalGetKey() + ']';
          }
        }
         else {
          this.path_cache = '';
        }
        return this.path_cache;
      },
      modelEquals: function (similarObj) {
        if (similarObj == null) {
          return false;
        }
        if (Kotlin.equals(this, similarObj)) {
          return true;
        }
        if (!Kotlin.equals(similarObj.metaClassName(), this.metaClassName())) {
          return false;
        }
        var values = new Kotlin.PrimitiveHashMap(0);
        var attVisitor = _c.KMFContainerImpl.f1(values);
        this.visitAttributes(attVisitor);
        similarObj.visitAttributes(attVisitor);
        if (!values.isEmpty()) {
          return false;
        }
        var payload = '';
        var refVisitor = _c.KMFContainerImpl.f2(values, payload);
        this.visit(refVisitor, false, false, true);
        similarObj.visit(refVisitor, false, false, true);
        if (!values.isEmpty()) {
          return false;
        }
        return true;
      },
      deepModelEquals: function (similarObj) {
        if (!this.modelEquals(similarObj)) {
          return false;
        }
        var similarRoot = similarObj != null ? similarObj : Kotlin.throwNPE();
        while (similarRoot.eContainer() != null) {
          var tmp$0;
          similarRoot = (tmp$0 = similarRoot.eContainer()) != null ? tmp$0 : Kotlin.throwNPE();
        }
        var resultTest = {v: true};
        var finalRoot = similarRoot;
        var objVisitor = _c.KMFContainerImpl.f3(finalRoot, resultTest);
        this.visit(objVisitor, true, true, false);
        return resultTest.v;
      },
      findByPath: function (query) {
        if (Kotlin.equals(query, this.path())) {
          return this;
        }
        var firstSepIndex = _.js.indexOf(query, '[');
        if (firstSepIndex === -1) {
          if (query.length === 0) {
            return this;
          }
           else {
            return null;
          }
        }
        var queryID = '';
        var extraReadChar = 2;
        var relationName = query.substring(0, _.js.indexOf(query, '['));
        if (_.js.indexOf(query, '{') === firstSepIndex + 1) {
          queryID = query.substring(_.js.indexOf(query, '{') + 1, _.js.indexOf(query, '}'));
          extraReadChar = extraReadChar + 2;
        }
         else {
          var indexFirstClose = _.js.indexOf(query, ']');
          while (indexFirstClose + 1 < query.length && query.charAt(indexFirstClose + 1) !== '/') {
            indexFirstClose = _.js.indexOf_0(query, ']', indexFirstClose + 1);
          }
          queryID = query.substring(_.js.indexOf(query, '[') + 1, indexFirstClose);
        }
        var subquery = query.substring(relationName.length + queryID.length + extraReadChar, query.length);
        if (_.js.indexOf(subquery, '/') !== -1) {
          subquery = subquery.substring(_.js.indexOf(subquery, '/') + 1, subquery.length);
        }
        var objFound = this.findByID(relationName, queryID);
        if (!Kotlin.equals(subquery, '') && objFound != null) {
          return objFound.findByPath(subquery);
        }
         else {
          return objFound;
        }
      },
      createTraces: function (similarObj, isInter, isMerge, onlyReferences, onlyAttributes) {
        var traces = new Kotlin.ArrayList(0);
        var values = new Kotlin.PrimitiveHashMap(0);
        if (onlyAttributes) {
          var attVisitorFill = _c.KMFContainerImpl.f4(values);
          this.visitAttributes(attVisitorFill);
          var attVisitor = _c.KMFContainerImpl.f5(this, values, isInter, traces);
          if (similarObj != null) {
            similarObj.visitAttributes(attVisitor);
          }
          if (!isInter && !isMerge && _.kotlin.get_size_0(values) !== 0) {
            {
              var tmp$0 = values.keySet().iterator();
              while (tmp$0.hasNext()) {
                var hashLoopRes = tmp$0.next();
                var tmp$1;
                traces.add(new _.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$1 = this.path()) != null ? tmp$1 : Kotlin.throwNPE(), hashLoopRes, null, null, null));
              }
            }
          }
        }
        if (onlyReferences) {
          var payload = '';
          var refVisitorFill = _c.KMFContainerImpl.f6(values, payload);
          this.visit(refVisitorFill, false, false, true);
          var refVisitor = _c.KMFContainerImpl.f7(this, values, isInter, traces);
          if (similarObj != null) {
            similarObj.visit(refVisitor, false, false, true);
          }
          if (!isInter && !isMerge && _.kotlin.get_size_0(values) !== 0) {
            {
              var tmp$2 = values.keySet().iterator();
              while (tmp$2.hasNext()) {
                var hashLoopRes_0 = tmp$2.next();
                var splittedVal = Kotlin.splitString(hashLoopRes_0, '_');
                var tmp$3;
                traces.add(new _.org.kevoree.modeling.api.trace.ModelRemoveTrace((tmp$3 = this.path()) != null ? tmp$3 : Kotlin.throwNPE(), splittedVal[0], splittedVal[1]));
              }
            }
          }
        }
        return traces;
      },
      toTraces: function (attributes, references) {
        var traces = new Kotlin.ArrayList(0);
        if (attributes) {
          var attVisitorFill = _c.KMFContainerImpl.f8(this, traces);
          this.visitAttributes(attVisitorFill);
        }
        if (references) {
          var refVisitorFill = _c.KMFContainerImpl.f9(this, traces);
          this.visit(refVisitorFill, false, true, true);
        }
        return traces;
      }
    }, /** @lends _c.KMFContainerImpl */ {
      f0: function () {
        return Kotlin.createObject(_c.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: function (elem, refNameInParent, parent) {
            if (elem.isRecursiveReadOnly()) {
              this.noChildrenVisit();
            }
             else {
              (elem != null ? elem : Kotlin.throwNPE()).setInternalRecursiveReadOnly();
              elem.setInternalReadOnly();
            }
          }
        });
      },
      f1: function (values) {
        return Kotlin.createObject(_c.ModelAttributeVisitor, null, {
          visit: function (value, name, parent) {
            if (values.containsKey(name)) {
              if (Kotlin.equals(values.get(name), Kotlin.toString(value))) {
                values.remove(name);
              }
            }
             else {
              values.put(name, Kotlin.toString(value));
            }
          }
        });
      },
      f2: function (values, payload) {
        return Kotlin.createObject(_c.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: function (elem, refNameInParent, parent) {
            var concatedKey = refNameInParent + '_' + elem.path();
            if (values.containsKey(concatedKey)) {
              values.remove(concatedKey);
            }
             else {
              values.put(concatedKey, payload);
            }
          }
        });
      },
      f3: function (finalRoot, resultTest) {
        return Kotlin.createObject(_c.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: function (elem, refNameInParent, parent) {
            var tmp$0;
            var similarSubObj = finalRoot.findByPath((tmp$0 = elem.path()) != null ? tmp$0 : Kotlin.throwNPE());
            if (!elem.modelEquals(similarSubObj)) {
              resultTest.v = false;
              this.stopVisit();
            }
          }
        });
      },
      f4: function (values) {
        return Kotlin.createObject(_c.ModelAttributeVisitor, null, {
          visit: function (value, name, parent) {
            values.put(name, _.org.kevoree.modeling.api.util.AttConverter.convFlatAtt(value));
          }
        });
      },
      f5: function ($outer, values, isInter, traces) {
        return Kotlin.createObject(_c.ModelAttributeVisitor, null, {
          visit: function (value, name, parent) {
            var attVal2 = _.org.kevoree.modeling.api.util.AttConverter.convFlatAtt(value);
            if (Kotlin.equals(values.get(name), attVal2)) {
              if (isInter) {
                var tmp$0;
                traces.add(new _.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$0 = $outer.path()) != null ? tmp$0 : Kotlin.throwNPE(), name, null, attVal2, null));
              }
            }
             else {
              if (!isInter) {
                var tmp$1;
                traces.add(new _.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$1 = $outer.path()) != null ? tmp$1 : Kotlin.throwNPE(), name, null, attVal2, null));
              }
            }
            values.remove(name);
          }
        });
      },
      f6: function (values, payload) {
        return Kotlin.createObject(_c.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: function (elem, refNameInParent, parent) {
            var concatedKey = refNameInParent + '_' + elem.path();
            values.put(concatedKey, payload);
          }
        });
      },
      f7: function ($outer, values, isInter, traces) {
        return Kotlin.createObject(_c.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: function (elem, refNameInParent, parent) {
            var concatedKey = refNameInParent + '_' + elem.path();
            if (values.get(concatedKey) != null) {
              if (isInter) {
                var tmp$0, tmp$1;
                traces.add(new _.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$0 = $outer.path()) != null ? tmp$0 : Kotlin.throwNPE(), refNameInParent, (tmp$1 = elem.path()) != null ? tmp$1 : Kotlin.throwNPE(), null));
              }
            }
             else {
              if (!isInter) {
                var tmp$2, tmp$3;
                traces.add(new _.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$2 = $outer.path()) != null ? tmp$2 : Kotlin.throwNPE(), refNameInParent, (tmp$3 = elem.path()) != null ? tmp$3 : Kotlin.throwNPE(), null));
              }
            }
            values.remove(concatedKey);
          }
        });
      },
      f8: function ($outer, traces) {
        return Kotlin.createObject(_c.ModelAttributeVisitor, null, {
          visit: function (value, name, parent) {
            var tmp$0;
            traces.add(new _.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$0 = $outer.path()) != null ? tmp$0 : Kotlin.throwNPE(), name, null, _.org.kevoree.modeling.api.util.AttConverter.convFlatAtt(value), null));
          }
        });
      },
      f9: function ($outer, traces) {
        return Kotlin.createObject(_c.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: function (elem, refNameInParent, parent) {
            var tmp$0, tmp$1;
            traces.add(new _.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$0 = $outer.path()) != null ? tmp$0 : Kotlin.throwNPE(), refNameInParent, (tmp$1 = elem.path()) != null ? tmp$1 : Kotlin.throwNPE(), null));
          }
        });
      }
    }), InputStream: Kotlin.createTrait(null), OutputStream: Kotlin.createTrait(null), EventListener: Kotlin.createTrait(null, /** @lends _c.EventListener.prototype */ {
      handleEvent: function (arg1) {
        noImpl;
      }
    }), Asserter: Kotlin.createTrait(null), AbstractIterator: Kotlin.createClass(Kotlin.Iterator, function () {
      this.state = _.kotlin.support.State.NotReady;
      this.nextValue = null;
    }, /** @lends _c.AbstractIterator.prototype */ {
      hasNext: function () {
        _.kotlin.require(this.state !== _.kotlin.support.State.Failed, 'Failed requirement');
        var tmp$0 = this.state, tmp$1;
        if (tmp$0 === _.kotlin.support.State.Done)
          tmp$1 = false;
        else if (tmp$0 === _.kotlin.support.State.Ready)
          tmp$1 = true;
        else
          tmp$1 = this.tryToComputeNext();
        return tmp$1;
      },
      next: function () {
        if (!this.hasNext())
          throw new Kotlin.NoSuchElementException();
        this.state = _.kotlin.support.State.NotReady;
        var tmp$0;
        return (tmp$0 = this.nextValue) != null ? tmp$0 : Kotlin.throwNPE();
      },
      peek: function () {
        if (!this.hasNext())
          throw new Kotlin.NoSuchElementException();
        var tmp$0;
        return (tmp$0 = this.nextValue) != null ? tmp$0 : Kotlin.throwNPE();
      },
      tryToComputeNext: function () {
        this.state = _.kotlin.support.State.Failed;
        this.computeNext();
        return this.state === _.kotlin.support.State.Ready;
      },
      setNext: function (value) {
        this.nextValue = value;
        this.state = _.kotlin.support.State.Ready;
      },
      done: function () {
        this.state = _.kotlin.support.State.Done;
      }
    })};
  }()
  , _ = Kotlin.defineRootPackage(null, /** @lends _ */ {
    kotlin: Kotlin.definePackage(null, /** @lends _.kotlin */ {
      hashMap: function (values) {
        var answer = new Kotlin.ComplexHashMap(0);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = values, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var v = tmp$0[tmp$2];
            answer.put(v.first, v.second);
          }
        }
        return answer;
      },
      toString: function ($receiver) {
        return _.kotlin.makeString($receiver, ', ', '[', ']', -1, '...');
      },
      arrayList: function (values) {
        var list = new Kotlin.ArrayList(0);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = values, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var value = tmp$0[tmp$2];
            list.add(value);
          }
        }
        return list;
      },
      hashSet: function (values) {
        var list = new Kotlin.ComplexHashSet();
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = values, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var value = tmp$0[tmp$2];
            list.add(value);
          }
        }
        return list;
      },
      map: function ($receiver, transform) {
        return _.kotlin.mapTo($receiver, new Kotlin.ArrayList(0), transform);
      },
      mapValues: function ($receiver, transform) {
        return _.kotlin.mapValuesTo($receiver, new Kotlin.ComplexHashMap(0), transform);
      },
      Pair: Kotlin.createClass(null, function (first, second) {
        this.first = first;
        this.second = second;
      }, /** @lends _.kotlin.Pair.prototype */ {
        component1: function () {
          return this.first;
        },
        component2: function () {
          return this.second;
        },
        toString: function () {
          return '(' + this.first + ', ' + this.second + ')';
        }
      }),
      Triple: Kotlin.createClass(null, function (first, second, third) {
        this.first = first;
        this.second = second;
        this.third = third;
      }, /** @lends _.kotlin.Triple.prototype */ {
        component1: function () {
          return this.first;
        },
        component2: function () {
          return this.second;
        },
        component3: function () {
          return this.third;
        },
        toString: function () {
          return '(' + this.first + ', ' + this.second + ', ' + this.third + ')';
        }
      }),
      all: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      any: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      count: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      find: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      filter: function ($receiver, predicate) {
        return _.kotlin.filterTo($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterTo: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNot: function ($receiver, predicate) {
        return _.kotlin.filterNotTo($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterNotTo: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      partition: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList(0);
        var second = new Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      map_0: function ($receiver, transform) {
        return _.kotlin.mapTo_0($receiver, new Kotlin.ArrayList(0), transform);
      },
      mapTo_0: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      },
      flatMap: function ($receiver, transform) {
        return _.kotlin.flatMapTo($receiver, new Kotlin.ArrayList(0), transform);
      },
      flatMapTo: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      },
      forEach: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      fold: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      },
      foldRight: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      reduce: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      },
      reduceRight: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      groupBy: function ($receiver, toKey) {
        return _.kotlin.groupByTo($receiver, new Kotlin.ComplexHashMap(0), toKey);
      },
      f0: function () {
        return new Kotlin.ArrayList(0);
      },
      groupByTo: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.f0);
            list.add(element);
          }
        }
        return result;
      },
      drop: function ($receiver, n) {
        return _.kotlin.dropWhile($receiver, _.kotlin.countTo(n));
      },
      dropWhile: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo($receiver, new Kotlin.ArrayList(0), predicate);
      },
      dropWhileTo: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      },
      take: function ($receiver, n) {
        return _.kotlin.takeWhile($receiver, _.kotlin.countTo(n));
      },
      takeWhile: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo($receiver, new Kotlin.ArrayList(0), predicate);
      },
      takeWhileTo: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      },
      toCollection: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      },
      reverse: function ($receiver) {
        var list = _.kotlin.toCollection($receiver, new Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      },
      toLinkedList: function ($receiver) {
        return _.kotlin.toCollection($receiver, new Kotlin.LinkedList());
      },
      toList_0: function ($receiver) {
        return _.kotlin.toCollection($receiver, new Kotlin.ArrayList(0));
      },
      toSet: function ($receiver) {
        return _.kotlin.toCollection($receiver, new Kotlin.LinkedHashSet());
      },
      toSortedSet: function ($receiver) {
        return _.kotlin.toCollection($receiver, new Kotlin.TreeSet());
      },
      plus: function ($receiver, element) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection($receiver, answer);
        answer.add(element);
        return answer;
      },
      plus_0: function ($receiver, iterator) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      },
      plus_1: function ($receiver, collection) {
        return _.kotlin.plus_0($receiver, collection.iterator());
      },
      withIndices: function ($receiver) {
        return new _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      },
      f1: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      },
      sortBy: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection($receiver, new Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.f1.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      appendString: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      },
      makeString_0: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = new Kotlin.StringBuilder();
        _.kotlin.appendString($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      },
      test: Kotlin.definePackage(function () {
        this.asserter = new _.kotlin.test.QUnitAsserter();
      }, /** @lends _.kotlin.test */ {
        todo: function (block) {
          Kotlin.println('TODO at ' + block);
        },
        QUnitAsserter: Kotlin.createClass(_c.Asserter, null, /** @lends _.kotlin.test.QUnitAsserter.prototype */ {
          assertTrue: function (message, actual) {
            ok(actual, message);
          },
          assertEquals: function (message, expected, actual) {
            ok(Kotlin.equals(expected, actual), message + '. Expected <' + Kotlin.toString(expected) + '> actual <' + Kotlin.toString(actual) + '>');
          },
          assertNotNull: function (message, actual) {
            ok(actual != null, message);
          },
          assertNull: function (message, actual) {
            ok(actual == null, message);
          },
          fail: function (message) {
            ok(false, message);
          }
        }),
        assertTrue: function (message, block) {
          var actual = block();
          _.kotlin.test.asserter.assertTrue(message, actual);
        },
        assertTrue_0: function (block) {
          _.kotlin.test.assertTrue(Kotlin.toString(block), block);
        },
        f0: function (block) {
          return !block();
        },
        assertNot: function (message, block) {
          _.kotlin.test.assertTrue(message, _.kotlin.test.f0.bind(null, block));
        },
        assertNot_0: function (block) {
          _.kotlin.test.assertNot(Kotlin.toString(block), block);
        },
        assertTrue_1: function (actual, message) {
          return _.kotlin.test.assertEquals(true, actual, message);
        },
        assertFalse: function (actual, message) {
          return _.kotlin.test.assertEquals(false, actual, message);
        },
        assertEquals: function (expected, actual, message) {
          _.kotlin.test.asserter.assertEquals(message, expected, actual);
        },
        assertNotNull: function (actual, message) {
          _.kotlin.test.asserter.assertNotNull(message, actual);
          return actual != null ? actual : Kotlin.throwNPE();
        },
        assertNotNull_0: function (actual, message, block) {
          _.kotlin.test.asserter.assertNotNull(message, actual);
          if (actual != null) {
            block(actual);
          }
        },
        assertNull: function (actual, message) {
          _.kotlin.test.asserter.assertNull(message, actual);
        },
        fail: function (message) {
          _.kotlin.test.asserter.fail(message);
        },
        expect: function (expected, block) {
          _.kotlin.test.expect_0(expected, Kotlin.toString(block), block);
        },
        expect_0: function (expected, message, block) {
          var actual = block();
          _.kotlin.test.assertEquals(expected, actual, message);
        },
        fails: function (block) {
          try {
            block();
            _.kotlin.test.asserter.fail('Expected an exception to be thrown');
            return null;
          }
           catch (e) {
            return e;
          }
        }
      }),
      dom: Kotlin.definePackage(null, /** @lends _.kotlin.dom */ {
        createDocument: function () {
          return document.implementation.createDocument(null, null, null);
        },
        toXmlString: function ($receiver) {
          return $receiver.outerHTML;
        },
        toXmlString_0: function ($receiver, xmlDeclaration) {
          return $receiver.outerHTML;
        },
        eventHandler: function (handler) {
          return new _.kotlin.dom.EventListenerHandler(handler);
        },
        EventListenerHandler: Kotlin.createClass(_c.EventListener, function (handler) {
          this.handler = handler;
        }, /** @lends _.kotlin.dom.EventListenerHandler.prototype */ {
          handleEvent: function (e) {
            if (e != null) {
              this.handler(e);
            }
          }
        }),
        f0: function (handler, e) {
          if (Kotlin.isType(e, MouseEvent)) {
            handler(e);
          }
        },
        mouseEventHandler: function (handler) {
          return _.kotlin.dom.eventHandler(_.kotlin.dom.f0.bind(null, handler));
        },
        on: function ($receiver, name, capture, handler) {
          return _.kotlin.dom.on_0($receiver, name, capture, _.kotlin.dom.eventHandler(handler));
        },
        on_0: function ($receiver, name, capture, listener) {
          var tmp$0;
          if (Kotlin.isType($receiver, EventTarget)) {
            addEventListener(name, listener, capture);
            tmp$0 = new _.kotlin.dom.CloseableEventListener($receiver, listener, name, capture);
          }
           else {
            tmp$0 = null;
          }
          return tmp$0;
        },
        CloseableEventListener: Kotlin.createClass(Kotlin.Closeable, function (target, listener, name, capture) {
          this.target = target;
          this.listener = listener;
          this.name = name;
          this.capture = capture;
        }, /** @lends _.kotlin.dom.CloseableEventListener.prototype */ {
          close: function () {
            this.target.removeEventListener(this.name, this.listener, this.capture);
          }
        }),
        onClick: function ($receiver, capture, handler) {
          return _.kotlin.dom.on_0($receiver, 'click', capture, _.kotlin.dom.mouseEventHandler(handler));
        },
        onDoubleClick: function ($receiver, capture, handler) {
          return _.kotlin.dom.on_0($receiver, 'dblclick', capture, _.kotlin.dom.mouseEventHandler(handler));
        },
        emptyElementList: function () {
          return Kotlin.emptyList();
        },
        emptyNodeList: function () {
          return Kotlin.emptyList();
        },
        get_text: {value: function ($receiver) {
          return $receiver.textContent;
        }},
        set_text: {value: function ($receiver, value) {
          $receiver.textContent = value;
        }},
        get_childrenText: {value: function ($receiver) {
          var buffer = new Kotlin.StringBuilder();
          var nodeList = $receiver.childNodes;
          var i = 0;
          var size = nodeList.length;
          while (i < size) {
            var node = nodeList.item(i);
            if (node != null) {
              if (_.kotlin.dom.isText(node)) {
                buffer.append(node.nodeValue);
              }
            }
            i++;
          }
          return buffer.toString();
        }},
        set_childrenText: {value: function ($receiver, value) {
          var element = $receiver;
          {
            var tmp$0 = _.kotlin.dom.children(element).iterator();
            while (tmp$0.hasNext()) {
              var node = tmp$0.next();
              if (_.kotlin.dom.isText(node)) {
                $receiver.removeChild(node);
              }
            }
          }
          _.kotlin.dom.addText(element, value, null);
        }},
        get_id: {value: function ($receiver) {
          var tmp$0;
          return (tmp$0 = $receiver.getAttribute('id')) != null ? tmp$0 : '';
        }},
        set_id: {value: function ($receiver, value) {
          $receiver.setAttribute('id', value);
          $receiver.setIdAttribute('id', true);
        }},
        get_style: {value: function ($receiver) {
          var tmp$0;
          return (tmp$0 = $receiver.getAttribute('style')) != null ? tmp$0 : '';
        }},
        set_style: {value: function ($receiver, value) {
          $receiver.setAttribute('style', value);
        }},
        get_classes: {value: function ($receiver) {
          var tmp$0;
          return (tmp$0 = $receiver.getAttribute('class')) != null ? tmp$0 : '';
        }},
        set_classes: {value: function ($receiver, value) {
          $receiver.setAttribute('class', value);
        }},
        hasClass: function ($receiver, cssClass) {
          var c = _.kotlin.dom.get_classes($receiver);
          return _.js.matches(c, '(^|.*' + '\\' + 's+)' + cssClass + '(' + '$' + '|' + '\\' + 's+.*)');
        },
        children: function ($receiver) {
          return _.kotlin.dom.toList($receiver != null ? $receiver.childNodes : null);
        },
        f1: function (it) {
          return it.nodeType === Node.ELEMENT_NODE;
        },
        f2: function (it) {
          return it != null ? it : Kotlin.throwNPE();
        },
        childElements: function ($receiver) {
          return _.kotlin.map_3(_.kotlin.filter_2(_.kotlin.dom.children($receiver), _.kotlin.dom.f1), _.kotlin.dom.f2);
        },
        f3: function (name, it) {
          return it.nodeType === Node.ELEMENT_NODE && Kotlin.equals(it.nodeName, name);
        },
        f4: function (it) {
          return it != null ? it : Kotlin.throwNPE();
        },
        childElements_0: function ($receiver, name) {
          return _.kotlin.map_3(_.kotlin.filter_2(_.kotlin.dom.children($receiver), _.kotlin.dom.f3.bind(null, name)), _.kotlin.dom.f4);
        },
        get_elements: {value: function ($receiver) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagName('*') : null);
        }},
        get_elements_0: {value: function ($receiver) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagName('*') : null);
        }},
        elements_1: function ($receiver, localName) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagName(localName) : null);
        },
        elements_2: function ($receiver, localName) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagName(localName) : null);
        },
        elements_3: function ($receiver, namespaceUri, localName) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagNameNS(namespaceUri, localName) : null);
        },
        elements_4: function ($receiver, namespaceUri, localName) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagNameNS(namespaceUri, localName) : null);
        },
        toList: function ($receiver) {
          var tmp$0;
          if ($receiver == null) {
            tmp$0 = _.kotlin.dom.emptyNodeList();
          }
           else {
            tmp$0 = new _.kotlin.dom.NodeListAsList($receiver);
          }
          return tmp$0;
        },
        toElementList: function ($receiver) {
          var tmp$0;
          if ($receiver == null) {
            tmp$0 = new Kotlin.ArrayList(0);
          }
           else {
            tmp$0 = new _.kotlin.dom.ElementListAsList($receiver);
          }
          return tmp$0;
        },
        f5: function (selector, it) {
          return _.kotlin.dom.hasClass(it, selector.substring(1));
        },
        get: function ($receiver, selector) {
          var root = $receiver != null ? $receiver.documentElement : null;
          var tmp$0;
          if (root != null) {
            if (Kotlin.equals(selector, '*')) {
              tmp$0 = _.kotlin.dom.get_elements($receiver);
            }
             else if (selector.startsWith('.')) {
              tmp$0 = _.kotlin.toList(_.kotlin.filter_2(_.kotlin.dom.get_elements($receiver), _.kotlin.dom.f5.bind(null, selector)));
            }
             else if (selector.startsWith('#')) {
              var id = selector.substring(1);
              var element = $receiver != null ? $receiver.getElementById(id) : null;
              return element != null ? _.kotlin.arrayList([element]) : _.kotlin.dom.emptyElementList();
            }
             else {
              tmp$0 = _.kotlin.dom.elements_2($receiver, selector);
            }
          }
           else {
            tmp$0 = _.kotlin.dom.emptyElementList();
          }
          return tmp$0;
        },
        f6: function (selector, it) {
          return _.kotlin.dom.hasClass(it, selector.substring(1));
        },
        get_0: function ($receiver, selector) {
          var tmp$1;
          if (Kotlin.equals(selector, '*')) {
            tmp$1 = _.kotlin.dom.get_elements_0($receiver);
          }
           else if (selector.startsWith('.')) {
            tmp$1 = _.kotlin.toList(_.kotlin.filter_2(_.kotlin.dom.get_elements_0($receiver), _.kotlin.dom.f6.bind(null, selector)));
          }
           else if (selector.startsWith('#')) {
            var tmp$0;
            var element = (tmp$0 = $receiver.ownerDocument) != null ? tmp$0.getElementById(selector.substring(1)) : null;
            return element != null ? _.kotlin.arrayList([element]) : _.kotlin.dom.emptyElementList();
          }
           else {
            tmp$1 = _.kotlin.dom.elements_1($receiver, selector);
          }
          return tmp$1;
        },
        NodeListAsList: Kotlin.createClass(Kotlin.AbstractList, function $fun(nodeList) {
          this.nodeList = nodeList;
          $fun.baseInitializer.call(this);
        }, /** @lends _.kotlin.dom.NodeListAsList.prototype */ {
          get: function (index) {
            var node = this.nodeList.item(index);
            if (node == null) {
              throw new RangeError('NodeList does not contain a node at index: ' + index);
            }
             else {
              return node;
            }
          },
          size: function () {
            return this.nodeList.length;
          }
        }),
        ElementListAsList: Kotlin.createClass(Kotlin.AbstractList, function $fun(nodeList) {
          this.nodeList = nodeList;
          $fun.baseInitializer.call(this);
        }, /** @lends _.kotlin.dom.ElementListAsList.prototype */ {
          get: function (index) {
            var node = this.nodeList.item(index);
            if (node == null) {
              throw new RangeError('NodeList does not contain a node at index: ' + index);
            }
             else if (node.nodeType === Node.ELEMENT_NODE) {
              return node != null ? node : Kotlin.throwNPE();
            }
             else {
              throw new Kotlin.IllegalArgumentException('Node is not an Element as expected but is ' + node);
            }
          },
          size: function () {
            return this.nodeList.length;
          }
        }),
        clear: function ($receiver) {
          while (true) {
            var child = $receiver.firstChild;
            if (child == null) {
              return;
            }
             else {
              $receiver.removeChild(child);
            }
          }
        },
        nextSiblings: function ($receiver) {
          return new _.kotlin.dom.NextSiblingIterator($receiver);
        },
        NextSiblingIterator: Kotlin.createClass(_c.AbstractIterator, function $fun(node) {
          this.node = node;
          $fun.baseInitializer.call(this);
        }, /** @lends _.kotlin.dom.NextSiblingIterator.prototype */ {
          computeNext: function () {
            var nextValue = this.node.nextSibling;
            if (nextValue != null) {
              this.setNext(nextValue);
              this.node = nextValue;
            }
             else {
              this.done();
            }
          }
        }),
        previousSiblings: function ($receiver) {
          return new _.kotlin.dom.PreviousSiblingIterator($receiver);
        },
        PreviousSiblingIterator: Kotlin.createClass(_c.AbstractIterator, function $fun(node) {
          this.node = node;
          $fun.baseInitializer.call(this);
        }, /** @lends _.kotlin.dom.PreviousSiblingIterator.prototype */ {
          computeNext: function () {
            var nextValue = this.node.previousSibling;
            if (nextValue != null) {
              this.setNext(nextValue);
              this.node = nextValue;
            }
             else {
              this.done();
            }
          }
        }),
        isText: function ($receiver) {
          var nt = $receiver.nodeType;
          return nt === Node.TEXT_NODE || nt === Node.CDATA_SECTION_NODE;
        },
        attribute: function ($receiver, name) {
          var tmp$0;
          return (tmp$0 = $receiver.getAttribute(name)) != null ? tmp$0 : '';
        },
        get_head: {value: function ($receiver) {
          return $receiver != null && $receiver.length > 0 ? $receiver.item(0) : null;
        }},
        get_first: {value: function ($receiver) {
          return _.kotlin.dom.get_head($receiver);
        }},
        get_tail: {value: function ($receiver) {
          if ($receiver == null) {
            return null;
          }
           else {
            var s = $receiver.length;
            return s > 0 ? $receiver.item(s - 1) : null;
          }
        }},
        get_last: {value: function ($receiver) {
          return _.kotlin.dom.get_tail($receiver);
        }},
        toXmlString_1: function ($receiver, xmlDeclaration) {
          var tmp$0;
          if ($receiver == null)
            tmp$0 = '';
          else {
            tmp$0 = _.kotlin.dom.nodesToXmlString(_.kotlin.dom.toList($receiver), xmlDeclaration);
          }
          return tmp$0;
        },
        nodesToXmlString: function (nodes, xmlDeclaration) {
          var builder = new Kotlin.StringBuilder();
          {
            var tmp$0 = nodes.iterator();
            while (tmp$0.hasNext()) {
              var n = tmp$0.next();
              builder.append(_.kotlin.dom.toXmlString_0(n, xmlDeclaration));
            }
          }
          return builder.toString();
        },
        plus: function ($receiver, child) {
          if (child != null) {
            $receiver.appendChild(child);
          }
          return $receiver;
        },
        plus_0: function ($receiver, text) {
          return _.kotlin.dom.addText($receiver, text, null);
        },
        plusAssign: function ($receiver, text) {
          return _.kotlin.dom.addText($receiver, text, null);
        },
        createElement: function ($receiver, name, init) {
          var tmp$0;
          var elem = (tmp$0 = $receiver.createElement(name)) != null ? tmp$0 : Kotlin.throwNPE();
          init(elem);
          return elem;
        },
        createElement_0: function ($receiver, name, doc, init) {
          var tmp$0;
          var elem = (tmp$0 = _.kotlin.dom.ownerDocument($receiver, doc).createElement(name)) != null ? tmp$0 : Kotlin.throwNPE();
          init(elem);
          return elem;
        },
        ownerDocument: function ($receiver, doc) {
          var tmp$0;
          if ($receiver.nodeType === Node.DOCUMENT_NODE)
            tmp$0 = $receiver != null ? $receiver : Kotlin.throwNPE();
          else if (doc == null)
            tmp$0 = $receiver.ownerDocument;
          else
            tmp$0 = doc;
          var answer = tmp$0;
          if (answer == null) {
            throw new Kotlin.IllegalArgumentException('Element does not have an ownerDocument and none was provided for: ' + $receiver);
          }
           else {
            return answer;
          }
        },
        addElement: function ($receiver, name, init) {
          var child = _.kotlin.dom.createElement($receiver, name, init);
          $receiver.appendChild(child);
          return child;
        },
        addElement_0: function ($receiver, name, doc, init) {
          var child = _.kotlin.dom.createElement_0($receiver, name, doc, init);
          $receiver.appendChild(child);
          return child;
        },
        addText: function ($receiver, text, doc) {
          if (text != null) {
            var tmp$0;
            var child = (tmp$0 = _.kotlin.dom.ownerDocument($receiver, doc).createTextNode(text)) != null ? tmp$0 : Kotlin.throwNPE();
            $receiver.appendChild(child);
          }
          return $receiver;
        }
      }),
      all_0: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      any_0: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      count_0: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      find_0: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      filter_0: function ($receiver, predicate) {
        return _.kotlin.filterTo_0($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterTo_0: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNot_0: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_0($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterNotTo_0: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      partition_0: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList(0);
        var second = new Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      map_1: function ($receiver, transform) {
        return _.kotlin.mapTo_1($receiver, new Kotlin.ArrayList(0), transform);
      },
      mapTo_1: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      },
      flatMap_0: function ($receiver, transform) {
        return _.kotlin.flatMapTo_0($receiver, new Kotlin.ArrayList(0), transform);
      },
      flatMapTo_0: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      },
      forEach_0: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      fold_0: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      },
      foldRight_0: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      reduce_0: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      },
      reduceRight_0: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      groupBy_0: function ($receiver, toKey) {
        return _.kotlin.groupByTo_0($receiver, new Kotlin.ComplexHashMap(0), toKey);
      },
      f2: function () {
        return new Kotlin.ArrayList(0);
      },
      groupByTo_0: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.f2);
            list.add(element);
          }
        }
        return result;
      },
      drop_0: function ($receiver, n) {
        return _.kotlin.dropWhile_0($receiver, _.kotlin.countTo(n));
      },
      dropWhile_0: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_0($receiver, new Kotlin.ArrayList(0), predicate);
      },
      dropWhileTo_0: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      },
      take_0: function ($receiver, n) {
        return _.kotlin.takeWhile_0($receiver, _.kotlin.countTo(n));
      },
      takeWhile_0: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_0($receiver, new Kotlin.ArrayList(0), predicate);
      },
      takeWhileTo_0: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      },
      toCollection_0: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      },
      reverse_0: function ($receiver) {
        var list = _.kotlin.toCollection_0($receiver, new Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      },
      toLinkedList_0: function ($receiver) {
        return _.kotlin.toCollection_0($receiver, new Kotlin.LinkedList());
      },
      toList_1: function ($receiver) {
        return _.kotlin.toCollection_0($receiver, new Kotlin.ArrayList(0));
      },
      toSet_0: function ($receiver) {
        return _.kotlin.toCollection_0($receiver, new Kotlin.LinkedHashSet());
      },
      toSortedSet_0: function ($receiver) {
        return _.kotlin.toCollection_0($receiver, new Kotlin.TreeSet());
      },
      plus_2: function ($receiver, element) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_0($receiver, answer);
        answer.add(element);
        return answer;
      },
      plus_3: function ($receiver, iterator) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_0($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      },
      plus_4: function ($receiver, collection) {
        return _.kotlin.plus_3($receiver, collection.iterator());
      },
      withIndices_0: function ($receiver) {
        return new _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      },
      f3: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      },
      sortBy_0: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_0($receiver, new Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.f3.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      appendString_0: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      },
      makeString_1: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = new Kotlin.StringBuilder();
        _.kotlin.appendString_0($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      },
      iterator_0: function ($receiver) {
        return Kotlin.createObject(Kotlin.Iterator, null, {
          hasNext: function () {
            return $receiver.hasMoreElements();
          },
          next: function () {
            return $receiver.nextElement();
          }
        });
      },
      toArrayList: function ($receiver) {
        return _.kotlin.toCollection_1($receiver, new Kotlin.ArrayList(0));
      },
      toHashSet: function ($receiver) {
        return _.kotlin.toCollection_1($receiver, new Kotlin.ComplexHashSet());
      },
      to: function ($receiver, that) {
        return new _.kotlin.Pair($receiver, that);
      },
      run: function (f) {
        return f();
      },
      with: function (receiver, f) {
        return f(receiver);
      },
      let: function ($receiver, f) {
        return f($receiver);
      },
      all_1: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      any_1: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      count_1: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      find_1: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      filter_1: function ($receiver, predicate) {
        return _.kotlin.filterTo_1($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterTo_1: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNot_1: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_1($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterNotTo_1: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      partition_1: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList(0);
        var second = new Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      map_2: function ($receiver, transform) {
        return _.kotlin.mapTo_2($receiver, new Kotlin.ArrayList(0), transform);
      },
      mapTo_2: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      },
      flatMap_1: function ($receiver, transform) {
        return _.kotlin.flatMapTo_1($receiver, new Kotlin.ArrayList(0), transform);
      },
      flatMapTo_1: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      },
      forEach_1: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      fold_1: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      },
      foldRight_1: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      reduce_1: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      },
      reduceRight_1: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      groupBy_1: function ($receiver, toKey) {
        return _.kotlin.groupByTo_1($receiver, new Kotlin.ComplexHashMap(0), toKey);
      },
      f4: function () {
        return new Kotlin.ArrayList(0);
      },
      groupByTo_1: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.f4);
            list.add(element);
          }
        }
        return result;
      },
      drop_1: function ($receiver, n) {
        return _.kotlin.dropWhile_1($receiver, _.kotlin.countTo(n));
      },
      dropWhile_1: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_1($receiver, new Kotlin.ArrayList(0), predicate);
      },
      dropWhileTo_1: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      },
      take_1: function ($receiver, n) {
        return _.kotlin.takeWhile_1($receiver, _.kotlin.countTo(n));
      },
      takeWhile_1: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_1($receiver, new Kotlin.ArrayList(0), predicate);
      },
      takeWhileTo_1: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      },
      toCollection_2: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      },
      reverse_1: function ($receiver) {
        var list = _.kotlin.toCollection_2($receiver, new Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      },
      toLinkedList_1: function ($receiver) {
        return _.kotlin.toCollection_2($receiver, new Kotlin.LinkedList());
      },
      toList_2: function ($receiver) {
        return _.kotlin.toCollection_2($receiver, new Kotlin.ArrayList(0));
      },
      toSet_1: function ($receiver) {
        return _.kotlin.toCollection_2($receiver, new Kotlin.LinkedHashSet());
      },
      toSortedSet_1: function ($receiver) {
        return _.kotlin.toCollection_2($receiver, new Kotlin.TreeSet());
      },
      plus_5: function ($receiver, element) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_2($receiver, answer);
        answer.add(element);
        return answer;
      },
      plus_6: function ($receiver, iterator) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_2($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      },
      plus_7: function ($receiver, collection) {
        return _.kotlin.plus_6($receiver, collection.iterator());
      },
      withIndices_1: function ($receiver) {
        return new _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      },
      f5: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      },
      sortBy_1: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_2($receiver, new Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.f5.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      appendString_1: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      },
      makeString_2: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = new Kotlin.StringBuilder();
        _.kotlin.appendString_1($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      },
      all_2: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      any_2: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      count_2: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      find_2: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      filter_3: function ($receiver, predicate) {
        return _.kotlin.filterTo_2($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterTo_2: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNot_2: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_2($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterNotTo_2: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      partition_2: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList(0);
        var second = new Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      map_4: function ($receiver, transform) {
        return _.kotlin.mapTo_3($receiver, new Kotlin.ArrayList(0), transform);
      },
      mapTo_3: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      },
      flatMap_2: function ($receiver, transform) {
        return _.kotlin.flatMapTo_2($receiver, new Kotlin.ArrayList(0), transform);
      },
      flatMapTo_2: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      },
      forEach_2: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      fold_2: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      },
      foldRight_2: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      reduce_2: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      },
      reduceRight_2: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      groupBy_2: function ($receiver, toKey) {
        return _.kotlin.groupByTo_2($receiver, new Kotlin.ComplexHashMap(0), toKey);
      },
      f6: function () {
        return new Kotlin.ArrayList(0);
      },
      groupByTo_2: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.f6);
            list.add(element);
          }
        }
        return result;
      },
      drop_2: function ($receiver, n) {
        return _.kotlin.dropWhile_2($receiver, _.kotlin.countTo(n));
      },
      dropWhile_2: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_2($receiver, new Kotlin.ArrayList(0), predicate);
      },
      dropWhileTo_2: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      },
      take_2: function ($receiver, n) {
        return _.kotlin.takeWhile_2($receiver, _.kotlin.countTo(n));
      },
      takeWhile_2: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_2($receiver, new Kotlin.ArrayList(0), predicate);
      },
      takeWhileTo_2: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      },
      toCollection_3: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      },
      reverse_2: function ($receiver) {
        var list = _.kotlin.toCollection_3($receiver, new Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      },
      toLinkedList_2: function ($receiver) {
        return _.kotlin.toCollection_3($receiver, new Kotlin.LinkedList());
      },
      toList_3: function ($receiver) {
        return _.kotlin.toCollection_3($receiver, new Kotlin.ArrayList(0));
      },
      toSet_2: function ($receiver) {
        return _.kotlin.toCollection_3($receiver, new Kotlin.LinkedHashSet());
      },
      toSortedSet_2: function ($receiver) {
        return _.kotlin.toCollection_3($receiver, new Kotlin.TreeSet());
      },
      plus_8: function ($receiver, element) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_3($receiver, answer);
        answer.add(element);
        return answer;
      },
      plus_9: function ($receiver, iterator) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_3($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      },
      plus_10: function ($receiver, collection) {
        return _.kotlin.plus_9($receiver, collection.iterator());
      },
      withIndices_2: function ($receiver) {
        return new _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      },
      f7: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      },
      sortBy_2: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_3($receiver, new Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.f7.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      appendString_2: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      },
      makeString_3: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = new Kotlin.StringBuilder();
        _.kotlin.appendString_2($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      },
      downTo: function ($receiver, to) {
        return new _.jet.ByteProgression($receiver, to, -1);
      },
      downTo_0: function ($receiver, to) {
        return new _.jet.CharProgression($receiver.toChar(), to, -1);
      },
      downTo_1: function ($receiver, to) {
        return new _.jet.ShortProgression($receiver, to, -1);
      },
      downTo_2: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver, to, -1);
      },
      downTo_3: function ($receiver, to) {
        return new _.jet.LongProgression($receiver.toLong(), to, -(1).toLong());
      },
      downTo_4: function ($receiver, to) {
        return new _.jet.FloatProgression($receiver, to, -1);
      },
      downTo_5: function ($receiver, to) {
        return new _.jet.DoubleProgression($receiver, to, -1.0);
      },
      downTo_6: function ($receiver, to) {
        return new _.jet.CharProgression($receiver, to.toChar(), -1);
      },
      downTo_7: function ($receiver, to) {
        return new _.jet.CharProgression($receiver, to, -1);
      },
      downTo_8: function ($receiver, to) {
        return new _.jet.ShortProgression($receiver.toShort(), to, -1);
      },
      downTo_9: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver.toInt(), to, -1);
      },
      downTo_10: function ($receiver, to) {
        return new _.jet.LongProgression($receiver.toLong(), to, -(1).toLong());
      },
      downTo_11: function ($receiver, to) {
        return new _.jet.FloatProgression($receiver.toFloat(), to, -1);
      },
      downTo_12: function ($receiver, to) {
        return new _.jet.DoubleProgression($receiver.toDouble(), to, -1.0);
      },
      downTo_13: function ($receiver, to) {
        return new _.jet.ShortProgression($receiver, to, -1);
      },
      downTo_14: function ($receiver, to) {
        return new _.jet.ShortProgression($receiver, to.toShort(), -1);
      },
      downTo_15: function ($receiver, to) {
        return new _.jet.ShortProgression($receiver, to, -1);
      },
      downTo_16: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver, to, -1);
      },
      downTo_17: function ($receiver, to) {
        return new _.jet.LongProgression($receiver.toLong(), to, -(1).toLong());
      },
      downTo_18: function ($receiver, to) {
        return new _.jet.FloatProgression($receiver, to, -1);
      },
      downTo_19: function ($receiver, to) {
        return new _.jet.DoubleProgression($receiver, to, -1.0);
      },
      downTo_20: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver, to, -1);
      },
      downTo_21: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver, to.toInt(), -1);
      },
      downTo_22: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver, to, -1);
      },
      downTo_23: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver, to, -1);
      },
      downTo_24: function ($receiver, to) {
        return new _.jet.LongProgression($receiver.toLong(), to, -(1).toLong());
      },
      downTo_25: function ($receiver, to) {
        return new _.jet.FloatProgression($receiver, to, -1);
      },
      downTo_26: function ($receiver, to) {
        return new _.jet.DoubleProgression($receiver, to, -1.0);
      },
      downTo_27: function ($receiver, to) {
        return new _.jet.LongProgression($receiver, to.toLong(), -(1).toLong());
      },
      downTo_28: function ($receiver, to) {
        return new _.jet.LongProgression($receiver, to.toLong(), -(1).toLong());
      },
      downTo_29: function ($receiver, to) {
        return new _.jet.LongProgression($receiver, to.toLong(), -(1).toLong());
      },
      downTo_30: function ($receiver, to) {
        return new _.jet.LongProgression($receiver, to.toLong(), -(1).toLong());
      },
      downTo_31: function ($receiver, to) {
        return new _.jet.LongProgression($receiver, to, -(1).toLong());
      },
      downTo_32: function ($receiver, to) {
        return new _.jet.FloatProgression($receiver.toFloat(), to, -1);
      },
      downTo_33: function ($receiver, to) {
        return new _.jet.DoubleProgression($receiver.toDouble(), to, -1.0);
      },
      downTo_34: function ($receiver, to) {
        return new _.jet.FloatProgression($receiver, to, -1);
      },
      downTo_35: function ($receiver, to) {
        return new _.jet.FloatProgression($receiver, to.toFloat(), -1);
      },
      downTo_36: function ($receiver, to) {
        return new _.jet.FloatProgression($receiver, to, -1);
      },
      downTo_37: function ($receiver, to) {
        return new _.jet.FloatProgression($receiver, to, -1);
      },
      downTo_38: function ($receiver, to) {
        return new _.jet.FloatProgression($receiver, to.toFloat(), -1);
      },
      downTo_39: function ($receiver, to) {
        return new _.jet.FloatProgression($receiver, to, -1);
      },
      downTo_40: function ($receiver, to) {
        return new _.jet.DoubleProgression($receiver, to, -1.0);
      },
      downTo_41: function ($receiver, to) {
        return new _.jet.DoubleProgression($receiver, to, -1.0);
      },
      downTo_42: function ($receiver, to) {
        return new _.jet.DoubleProgression($receiver, to.toDouble(), -1.0);
      },
      downTo_43: function ($receiver, to) {
        return new _.jet.DoubleProgression($receiver, to, -1.0);
      },
      downTo_44: function ($receiver, to) {
        return new _.jet.DoubleProgression($receiver, to, -1.0);
      },
      downTo_45: function ($receiver, to) {
        return new _.jet.DoubleProgression($receiver, to.toDouble(), -1.0);
      },
      downTo_46: function ($receiver, to) {
        return new _.jet.DoubleProgression($receiver, to, -1.0);
      },
      downTo_47: function ($receiver, to) {
        return new _.jet.DoubleProgression($receiver, to, -1.0);
      },
      all_3: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      any_3: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      count_3: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      find_3: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      filter_4: function ($receiver, predicate) {
        return _.kotlin.filterTo_3($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterTo_3: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNot_3: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_3($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterNotTo_3: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      partition_3: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList(0);
        var second = new Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      map_5: function ($receiver, transform) {
        return _.kotlin.mapTo_4($receiver, new Kotlin.ArrayList(0), transform);
      },
      mapTo_4: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      },
      flatMap_3: function ($receiver, transform) {
        return _.kotlin.flatMapTo_3($receiver, new Kotlin.ArrayList(0), transform);
      },
      flatMapTo_3: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      },
      forEach_3: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      fold_3: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      },
      foldRight_3: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      reduce_3: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      },
      reduceRight_3: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      groupBy_3: function ($receiver, toKey) {
        return _.kotlin.groupByTo_3($receiver, new Kotlin.ComplexHashMap(0), toKey);
      },
      f8: function () {
        return new Kotlin.ArrayList(0);
      },
      groupByTo_3: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.f8);
            list.add(element);
          }
        }
        return result;
      },
      drop_3: function ($receiver, n) {
        return _.kotlin.dropWhile_3($receiver, _.kotlin.countTo(n));
      },
      dropWhile_3: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_3($receiver, new Kotlin.ArrayList(0), predicate);
      },
      dropWhileTo_3: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      },
      take_3: function ($receiver, n) {
        return _.kotlin.takeWhile_3($receiver, _.kotlin.countTo(n));
      },
      takeWhile_3: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_3($receiver, new Kotlin.ArrayList(0), predicate);
      },
      takeWhileTo_3: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      },
      toCollection_4: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      },
      reverse_3: function ($receiver) {
        var list = _.kotlin.toCollection_4($receiver, new Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      },
      toLinkedList_3: function ($receiver) {
        return _.kotlin.toCollection_4($receiver, new Kotlin.LinkedList());
      },
      toList_4: function ($receiver) {
        return _.kotlin.toCollection_4($receiver, new Kotlin.ArrayList(0));
      },
      toSet_3: function ($receiver) {
        return _.kotlin.toCollection_4($receiver, new Kotlin.LinkedHashSet());
      },
      toSortedSet_3: function ($receiver) {
        return _.kotlin.toCollection_4($receiver, new Kotlin.TreeSet());
      },
      plus_11: function ($receiver, element) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_4($receiver, answer);
        answer.add(element);
        return answer;
      },
      plus_12: function ($receiver, iterator) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_4($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      },
      plus_13: function ($receiver, collection) {
        return _.kotlin.plus_12($receiver, collection.iterator());
      },
      withIndices_3: function ($receiver) {
        return new _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      },
      f9: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      },
      sortBy_3: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_4($receiver, new Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.f9.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      appendString_3: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      },
      makeString_4: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = new Kotlin.StringBuilder();
        _.kotlin.appendString_3($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      },
      trim: function ($receiver, text) {
        return _.kotlin.trimTrailing(_.kotlin.trimLeading($receiver, text), text);
      },
      trim_0: function ($receiver, prefix, postfix) {
        return _.kotlin.trimTrailing(_.kotlin.trimLeading($receiver, prefix), postfix);
      },
      trimLeading: function ($receiver, prefix) {
        var answer = $receiver;
        if (answer.startsWith(prefix)) {
          answer = answer.substring(prefix.length);
        }
        return answer;
      },
      trimTrailing: function ($receiver, postfix) {
        var answer = $receiver;
        if (answer.endsWith(postfix)) {
          answer = answer.substring(0, $receiver.length - postfix.length);
        }
        return answer;
      },
      isNotEmpty: function ($receiver) {
        return $receiver != null && $receiver.length > 0;
      },
      iterator_1: function ($receiver) {
        return Kotlin.createObject(_.jet.CharIterator, function $fun() {
          $fun.baseInitializer.call(this);
          this.index = 0;
        }, {
          nextChar: function () {
            var tmp$0, tmp$1;
            return $receiver.get((tmp$0 = this.index, tmp$1 = tmp$0, this.index = tmp$0 + 1, tmp$1));
          },
          hasNext: function () {
            return this.index < $receiver.length;
          }
        });
      },
      orEmpty: function ($receiver) {
        return $receiver != null ? $receiver : '';
      },
      get_size: {value: function ($receiver) {
        return $receiver.length;
      }},
      count_4: function ($receiver, predicate) {
        var answer = 0;
        {
          var tmp$0 = _.kotlin.iterator_1($receiver);
          while (tmp$0.hasNext()) {
            var c = tmp$0.next();
            if (predicate(c)) {
              answer++;
            }
          }
        }
        return answer;
      },
      count_5: function ($receiver) {
        if (Kotlin.isType($receiver, _.jet.Collection)) {
          return $receiver.size();
        }
        var number = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var elem = tmp$0.next();
            ++number;
          }
        }
        return number;
      },
      fa: function (count, n, it) {
        ++count.v;
        return count.v <= n;
      },
      countTo: function (n) {
        var count = {v: 0};
        return _.kotlin.fa.bind(null, count, n);
      },
      first: function ($receiver) {
        if (Kotlin.isType($receiver, _.jet.List)) {
          return _.kotlin.first($receiver);
        }
        return $receiver.iterator().next();
      },
      containsItem: function ($receiver, item) {
        if (Kotlin.isType($receiver, Kotlin.AbstractCollection)) {
          return $receiver.contains(item);
        }
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var elem = tmp$0.next();
            if (Kotlin.equals(elem, item)) {
              return true;
            }
          }
        }
        return false;
      },
      sort: function ($receiver) {
        var list = _.kotlin.toCollection_5($receiver, new Kotlin.ArrayList(0));
        Kotlin.collectionsSort(list);
        return list;
      },
      sort_0: function ($receiver, comparator) {
        var list = _.kotlin.toCollection_5($receiver, new Kotlin.ArrayList(0));
        Kotlin.collectionsSort(list, comparator);
        return list;
      },
      all_4: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      any_4: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      count_6: function ($receiver, predicate) {
        var count = 0;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      find_4: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      filter_5: function ($receiver, predicate) {
        return _.kotlin.filterTo_4($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterTo_4: function ($receiver, result, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNot_4: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_4($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterNotTo_4: function ($receiver, result, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      partition_4: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList(0);
        var second = new Kotlin.ArrayList(0);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      map_6: function ($receiver, transform) {
        return _.kotlin.mapTo_5($receiver, new Kotlin.ArrayList(0), transform);
      },
      mapTo_5: function ($receiver, result, transform) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            result.add(transform(item));
          }
        }
        return result;
      },
      flatMap_4: function ($receiver, transform) {
        return _.kotlin.flatMapTo_4($receiver, new Kotlin.ArrayList(0), transform);
      },
      flatMapTo_4: function ($receiver, result, transform) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            var list = transform(element);
            {
              var tmp$3 = list.iterator();
              while (tmp$3.hasNext()) {
                var r = tmp$3.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      },
      forEach_4: function ($receiver, operation) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            operation(element);
          }
        }
      },
      fold_4: function ($receiver, initial, operation) {
        var answer = initial;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            answer = operation(answer, element);
          }
        }
        return answer;
      },
      foldRight_4: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      reduce_4: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      },
      reduceRight_4: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      groupBy_4: function ($receiver, toKey) {
        return _.kotlin.groupByTo_4($receiver, new Kotlin.ComplexHashMap(0), toKey);
      },
      fb: function () {
        return new Kotlin.ArrayList(0);
      },
      groupByTo_4: function ($receiver, result, toKey) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.fb);
            list.add(element);
          }
        }
        return result;
      },
      drop_4: function ($receiver, n) {
        return _.kotlin.dropWhile_4($receiver, _.kotlin.countTo(n));
      },
      dropWhile_4: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_4($receiver, new Kotlin.ArrayList(0), predicate);
      },
      dropWhileTo_4: function ($receiver, result, predicate) {
        var start = true;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      },
      take_4: function ($receiver, n) {
        return _.kotlin.takeWhile_4($receiver, _.kotlin.countTo(n));
      },
      takeWhile_4: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_4($receiver, new Kotlin.ArrayList(0), predicate);
      },
      takeWhileTo_4: function ($receiver, result, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      },
      toCollection_6: function ($receiver, result) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            result.add(element);
          }
        }
        return result;
      },
      reverse_4: function ($receiver) {
        var list = _.kotlin.toCollection_6($receiver, new Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      },
      toLinkedList_4: function ($receiver) {
        return _.kotlin.toCollection_6($receiver, new Kotlin.LinkedList());
      },
      toList_5: function ($receiver) {
        return _.kotlin.toCollection_6($receiver, new Kotlin.ArrayList(0));
      },
      toSet_4: function ($receiver) {
        return _.kotlin.toCollection_6($receiver, new Kotlin.LinkedHashSet());
      },
      toSortedSet_4: function ($receiver) {
        return _.kotlin.toCollection_6($receiver, new Kotlin.TreeSet());
      },
      plus_14: function ($receiver, element) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_6($receiver, answer);
        answer.add(element);
        return answer;
      },
      plus_15: function ($receiver, iterator) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_6($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      },
      plus_16: function ($receiver, collection) {
        return _.kotlin.plus_15($receiver, collection.iterator());
      },
      withIndices_4: function ($receiver) {
        return new _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      },
      fc: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      },
      sortBy_4: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_6($receiver, new Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.fc.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      appendString_4: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      },
      makeString_5: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = new Kotlin.StringBuilder();
        _.kotlin.appendString_4($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      },
      all_5: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      any_5: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      count_7: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      find_5: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      filter_6: function ($receiver, predicate) {
        return _.kotlin.filterTo_5($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterTo_5: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNot_5: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_5($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterNotTo_5: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      partition_5: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList(0);
        var second = new Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      map_7: function ($receiver, transform) {
        return _.kotlin.mapTo_6($receiver, new Kotlin.ArrayList(0), transform);
      },
      mapTo_6: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      },
      flatMap_5: function ($receiver, transform) {
        return _.kotlin.flatMapTo_5($receiver, new Kotlin.ArrayList(0), transform);
      },
      flatMapTo_5: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      },
      forEach_5: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      fold_5: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      },
      foldRight_5: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      reduce_5: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      },
      reduceRight_5: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      groupBy_5: function ($receiver, toKey) {
        return _.kotlin.groupByTo_5($receiver, new Kotlin.ComplexHashMap(0), toKey);
      },
      fd: function () {
        return new Kotlin.ArrayList(0);
      },
      groupByTo_5: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.fd);
            list.add(element);
          }
        }
        return result;
      },
      drop_5: function ($receiver, n) {
        return _.kotlin.dropWhile_5($receiver, _.kotlin.countTo(n));
      },
      dropWhile_5: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_5($receiver, new Kotlin.ArrayList(0), predicate);
      },
      dropWhileTo_5: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      },
      take_5: function ($receiver, n) {
        return _.kotlin.takeWhile_5($receiver, _.kotlin.countTo(n));
      },
      takeWhile_5: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_5($receiver, new Kotlin.ArrayList(0), predicate);
      },
      takeWhileTo_5: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      },
      toCollection_7: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      },
      reverse_5: function ($receiver) {
        var list = _.kotlin.toCollection_7($receiver, new Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      },
      toLinkedList_5: function ($receiver) {
        return _.kotlin.toCollection_7($receiver, new Kotlin.LinkedList());
      },
      toList_6: function ($receiver) {
        return _.kotlin.toCollection_7($receiver, new Kotlin.ArrayList(0));
      },
      toSet_5: function ($receiver) {
        return _.kotlin.toCollection_7($receiver, new Kotlin.LinkedHashSet());
      },
      toSortedSet_5: function ($receiver) {
        return _.kotlin.toCollection_7($receiver, new Kotlin.TreeSet());
      },
      plus_17: function ($receiver, element) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_7($receiver, answer);
        answer.add(element);
        return answer;
      },
      plus_18: function ($receiver, iterator) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_7($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      },
      plus_19: function ($receiver, collection) {
        return _.kotlin.plus_18($receiver, collection.iterator());
      },
      withIndices_5: function ($receiver) {
        return new _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      },
      fe: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      },
      sortBy_5: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_7($receiver, new Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.fe.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      appendString_5: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      },
      makeString_6: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = new Kotlin.StringBuilder();
        _.kotlin.appendString_5($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      },
      get_size_0: {value: function ($receiver) {
        return $receiver.size();
      }},
      get_empty: {value: function ($receiver) {
        return $receiver.isEmpty();
      }},
      set: function ($receiver, key, value) {
        return $receiver.put(key, value);
      },
      orEmpty_0: function ($receiver) {
        var tmp$0;
        return $receiver != null ? $receiver : (tmp$0 = Kotlin.emptyMap()) != null ? tmp$0 : Kotlin.throwNPE();
      },
      get_key: {value: function ($receiver) {
        return $receiver.getKey();
      }},
      get_value: {value: function ($receiver) {
        return $receiver.getValue();
      }},
      component1: function ($receiver) {
        return $receiver.getKey();
      },
      component2: function ($receiver) {
        return $receiver.getValue();
      },
      getOrElse: function ($receiver, key, defaultValue) {
        if ($receiver.containsKey(key)) {
          var tmp$0;
          return (tmp$0 = $receiver.get(key)) != null ? tmp$0 : Kotlin.throwNPE();
        }
         else {
          return defaultValue();
        }
      },
      getOrPut: function ($receiver, key, defaultValue) {
        if ($receiver.containsKey(key)) {
          var tmp$0;
          return (tmp$0 = $receiver.get(key)) != null ? tmp$0 : Kotlin.throwNPE();
        }
         else {
          var answer = defaultValue();
          $receiver.put(key, answer);
          return answer;
        }
      },
      iterator: function ($receiver) {
        var entrySet = $receiver.entrySet();
        return entrySet.iterator();
      },
      mapTo: function ($receiver, result, transform) {
        {
          var tmp$0 = _.kotlin.iterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      },
      mapValuesTo: function ($receiver, result, transform) {
        {
          var tmp$0 = _.kotlin.iterator($receiver);
          while (tmp$0.hasNext()) {
            var e = tmp$0.next();
            var newValue = transform(e);
            result.put(_.kotlin.get_key(e), newValue);
          }
        }
        return result;
      },
      putAll: function ($receiver, values) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = values, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var v = tmp$0[tmp$2];
            $receiver.put(v.first, v.second);
          }
        }
      },
      toMap: function ($receiver, map) {
        map.putAll($receiver);
        return map;
      },
      map_8: function ($receiver, transform) {
        return _.kotlin.mapTo($receiver, new Kotlin.ArrayList(_.kotlin.get_size_0($receiver)), transform);
      },
      mapValues_0: function ($receiver, transform) {
        return _.kotlin.mapValuesTo($receiver, new Kotlin.ComplexHashMap(_.kotlin.get_size_0($receiver)), transform);
      },
      iterate: function (nextFunction) {
        return new _.kotlin.FunctionIterator(nextFunction);
      },
      FilterIterator: Kotlin.createClass(_c.AbstractIterator, function $fun(iterator, predicate) {
        this.iterator = iterator;
        this.predicate = predicate;
        $fun.baseInitializer.call(this);
      }, /** @lends _.kotlin.FilterIterator.prototype */ {
        computeNext: function () {
          while (this.iterator.hasNext()) {
            var next = this.iterator.next();
            if (this.predicate(next)) {
              this.setNext(next);
              return;
            }
          }
          this.done();
        }
      }),
      FilterNotNullIterator: Kotlin.createClass(_c.AbstractIterator, function $fun(iterator) {
        this.iterator = iterator;
        $fun.baseInitializer.call(this);
      }, /** @lends _.kotlin.FilterNotNullIterator.prototype */ {
        computeNext: function () {
          if (this.iterator != null) {
            while (this.iterator.hasNext()) {
              var next = this.iterator.next();
              if (next != null) {
                this.setNext(next);
                return;
              }
            }
          }
          this.done();
        }
      }),
      MapIterator: Kotlin.createClass(_c.AbstractIterator, function $fun(iterator, transform) {
        this.iterator = iterator;
        this.transform = transform;
        $fun.baseInitializer.call(this);
      }, /** @lends _.kotlin.MapIterator.prototype */ {
        computeNext: function () {
          if (this.iterator.hasNext()) {
            this.setNext(this.transform(this.iterator.next()));
          }
           else {
            this.done();
          }
        }
      }),
      FlatMapIterator: Kotlin.createClass(_c.AbstractIterator, function $fun(iterator, transform) {
        this.iterator = iterator;
        this.transform = transform;
        $fun.baseInitializer.call(this);
        this.transformed = _.kotlin.iterate(function () {
          return null;
        });
      }, /** @lends _.kotlin.FlatMapIterator.prototype */ {
        computeNext: function () {
          while (true) {
            if (this.transformed.hasNext()) {
              this.setNext(this.transformed.next());
              return;
            }
            if (this.iterator.hasNext()) {
              this.transformed = this.transform(this.iterator.next());
            }
             else {
              this.done();
              return;
            }
          }
        }
      }),
      TakeWhileIterator: Kotlin.createClass(_c.AbstractIterator, function $fun(iterator, predicate) {
        this.iterator = iterator;
        this.predicate = predicate;
        $fun.baseInitializer.call(this);
      }, /** @lends _.kotlin.TakeWhileIterator.prototype */ {
        computeNext: function () {
          if (this.iterator.hasNext()) {
            var item = this.iterator.next();
            if (this.predicate(item)) {
              this.setNext(item);
              return;
            }
          }
          this.done();
        }
      }),
      FunctionIterator: Kotlin.createClass(_c.AbstractIterator, function $fun(nextFunction) {
        this.nextFunction = nextFunction;
        $fun.baseInitializer.call(this);
      }, /** @lends _.kotlin.FunctionIterator.prototype */ {
        computeNext: function () {
          var next = this.nextFunction();
          if (next == null) {
            this.done();
          }
           else {
            this.setNext(next);
          }
        }
      }),
      CompositeIterator: Kotlin.createClass(_c.AbstractIterator, function $fun(iterators) {
        $fun.baseInitializer.call(this);
        this.iteratorsIter = Kotlin.arrayIterator(iterators);
        this.currentIter = null;
      }, /** @lends _.kotlin.CompositeIterator.prototype */ {
        computeNext: function () {
          while (true) {
            if (this.currentIter == null) {
              if (this.iteratorsIter.hasNext()) {
                this.currentIter = this.iteratorsIter.next();
              }
               else {
                this.done();
                return;
              }
            }
            var iter = this.currentIter;
            if (iter != null) {
              if (iter.hasNext()) {
                this.setNext(iter.next());
                return;
              }
               else {
                this.currentIter = null;
              }
            }
          }
        }
      }),
      SingleIterator: Kotlin.createClass(_c.AbstractIterator, function $fun(value) {
        this.value = value;
        $fun.baseInitializer.call(this);
        this.first = true;
      }, /** @lends _.kotlin.SingleIterator.prototype */ {
        computeNext: function () {
          if (this.first) {
            this.first = false;
            this.setNext(this.value);
          }
           else {
            this.done();
          }
        }
      }),
      IndexIterator: Kotlin.createClass(Kotlin.Iterator, function (iterator) {
        this.iterator = iterator;
        this.index = 0;
      }, /** @lends _.kotlin.IndexIterator.prototype */ {
        next: function () {
          var tmp$0, tmp$1;
          return new _.kotlin.Pair((tmp$0 = this.index, tmp$1 = tmp$0, this.index = tmp$0 + 1, tmp$1), this.iterator.next());
        },
        hasNext: function () {
          return this.iterator.hasNext();
        }
      }),
      all_6: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      any_6: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      count_8: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      find_6: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      filter_7: function ($receiver, predicate) {
        return _.kotlin.filterTo_6($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterTo_6: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNot_6: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_6($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterNotTo_6: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      partition_6: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList(0);
        var second = new Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      map_9: function ($receiver, transform) {
        return _.kotlin.mapTo_7($receiver, new Kotlin.ArrayList(0), transform);
      },
      mapTo_7: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      },
      flatMap_6: function ($receiver, transform) {
        return _.kotlin.flatMapTo_6($receiver, new Kotlin.ArrayList(0), transform);
      },
      flatMapTo_6: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      },
      forEach_6: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      fold_6: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      },
      foldRight_6: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      reduce_6: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      },
      reduceRight_6: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      groupBy_6: function ($receiver, toKey) {
        return _.kotlin.groupByTo_6($receiver, new Kotlin.ComplexHashMap(0), toKey);
      },
      ff: function () {
        return new Kotlin.ArrayList(0);
      },
      groupByTo_6: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.ff);
            list.add(element);
          }
        }
        return result;
      },
      drop_6: function ($receiver, n) {
        return _.kotlin.dropWhile_6($receiver, _.kotlin.countTo(n));
      },
      dropWhile_6: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_6($receiver, new Kotlin.ArrayList(0), predicate);
      },
      dropWhileTo_6: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      },
      take_6: function ($receiver, n) {
        return _.kotlin.takeWhile_6($receiver, _.kotlin.countTo(n));
      },
      takeWhile_6: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_6($receiver, new Kotlin.ArrayList(0), predicate);
      },
      takeWhileTo_6: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      },
      toCollection_8: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      },
      reverse_6: function ($receiver) {
        var list = _.kotlin.toCollection_8($receiver, new Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      },
      toLinkedList_6: function ($receiver) {
        return _.kotlin.toCollection_8($receiver, new Kotlin.LinkedList());
      },
      toList_7: function ($receiver) {
        return _.kotlin.toCollection_8($receiver, new Kotlin.ArrayList(0));
      },
      toSet_6: function ($receiver) {
        return _.kotlin.toCollection_8($receiver, new Kotlin.LinkedHashSet());
      },
      toSortedSet_6: function ($receiver) {
        return _.kotlin.toCollection_8($receiver, new Kotlin.TreeSet());
      },
      plus_20: function ($receiver, element) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_8($receiver, answer);
        answer.add(element);
        return answer;
      },
      plus_21: function ($receiver, iterator) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_8($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      },
      plus_22: function ($receiver, collection) {
        return _.kotlin.plus_21($receiver, collection.iterator());
      },
      withIndices_6: function ($receiver) {
        return new _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      },
      fg: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      },
      sortBy_6: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_8($receiver, new Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.fg.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      appendString_6: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      },
      makeString_7: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = new Kotlin.StringBuilder();
        _.kotlin.appendString_6($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      },
      all_7: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      any_7: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      count_9: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      find_7: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      filterTo_7: function ($receiver, result, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNotTo_7: function ($receiver, result, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNotNullTo: function ($receiver, result) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (element != null)
              result.add(element);
          }
        }
        return result;
      },
      partition_7: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList(0);
        var second = new Kotlin.ArrayList(0);
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      mapTo_8: function ($receiver, result, transform) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      },
      flatMapTo_7: function ($receiver, result, transform) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      },
      forEach_7: function ($receiver, operation) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      fold_7: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      },
      reduce_7: function ($receiver, operation) {
        var iterator = $receiver.iterator();
        if (!iterator.hasNext()) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      },
      groupBy_7: function ($receiver, toKey) {
        return _.kotlin.groupByTo_7($receiver, new Kotlin.ComplexHashMap(0), toKey);
      },
      fh: function () {
        return new Kotlin.ArrayList(0);
      },
      groupByTo_7: function ($receiver, result, toKey) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.fh);
            list.add(element);
          }
        }
        return result;
      },
      drop_7: function ($receiver, n) {
        return _.kotlin.dropWhile_7($receiver, _.kotlin.countTo(n));
      },
      dropWhile_7: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_7($receiver, new Kotlin.ArrayList(0), predicate);
      },
      dropWhileTo_7: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      },
      takeWhileTo_7: function ($receiver, result, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      },
      toCollection_5: function ($receiver, result) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      },
      reverse_7: function ($receiver) {
        var list = _.kotlin.toCollection_5($receiver, new Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      },
      toLinkedList_7: function ($receiver) {
        return _.kotlin.toCollection_5($receiver, new Kotlin.LinkedList());
      },
      toList: function ($receiver) {
        return _.kotlin.toCollection_5($receiver, new Kotlin.ArrayList(0));
      },
      toSet_7: function ($receiver) {
        return _.kotlin.toCollection_5($receiver, new Kotlin.LinkedHashSet());
      },
      toSortedSet_7: function ($receiver) {
        return _.kotlin.toCollection_5($receiver, new Kotlin.TreeSet());
      },
      withIndices_7: function ($receiver) {
        return new _.kotlin.IndexIterator($receiver.iterator());
      },
      fi: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      },
      sortBy_7: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_5($receiver, new Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.fi.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      appendString_7: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      },
      makeString: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = new Kotlin.StringBuilder();
        _.kotlin.appendString_7($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      },
      isNotEmpty_0: function ($receiver) {
        return !_.kotlin.isEmpty($receiver);
      },
      isEmpty: function ($receiver) {
        return $receiver.length === 0;
      },
      get_lastIndex: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_0: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_1: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_2: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_3: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_4: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_5: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_6: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_7: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_size_1: {value: function ($receiver) {
        return $receiver.size();
      }},
      get_empty_0: {value: function ($receiver) {
        return $receiver.isEmpty();
      }},
      get_indices: {value: function ($receiver) {
        return new Kotlin.NumberRange(0, _.kotlin.get_size_1($receiver) - 1);
      }},
      get_indices_0: {value: function ($receiver) {
        return new Kotlin.NumberRange(0, $receiver - 1);
      }},
      isNotEmpty_1: function ($receiver) {
        return !$receiver.isEmpty();
      },
      get_notEmpty: {value: function ($receiver) {
        return _.kotlin.isNotEmpty_1($receiver);
      }},
      orEmpty_1: function ($receiver) {
        var tmp$0;
        return $receiver != null ? $receiver : (tmp$0 = Kotlin.emptyList()) != null ? tmp$0 : Kotlin.throwNPE();
      },
      toSortedList: function ($receiver) {
        return _.kotlin.sort(_.kotlin.toCollection_5($receiver, new Kotlin.ArrayList(0)));
      },
      toSortedList_0: function ($receiver, comparator) {
        return _.kotlin.sort_0(_.kotlin.toList($receiver), comparator);
      },
      orEmpty_2: function ($receiver) {
        var tmp$0;
        return $receiver != null ? $receiver : (tmp$0 = Kotlin.emptyList()) != null ? tmp$0 : Kotlin.throwNPE();
      },
      get_first_0: {value: function ($receiver) {
        return _.kotlin.get_head($receiver);
      }},
      get_last: {value: function ($receiver) {
        var s = _.kotlin.get_size_1($receiver);
        return s > 0 ? $receiver.get(s - 1) : null;
      }},
      get_lastIndex_8: {value: function ($receiver) {
        return _.kotlin.get_size_1($receiver) - 1;
      }},
      get_head: {value: function ($receiver) {
        return $receiver.get(0);
      }},
      get_tail: {value: function ($receiver) {
        return _.kotlin.drop_7($receiver, 1);
      }},
      require: function (value, message) {
        if (!value) {
          throw new Kotlin.IllegalArgumentException(Kotlin.toString(message));
        }
      },
      require_0: function (value, lazyMessage) {
        if (!value) {
          var message = lazyMessage();
          throw new Kotlin.IllegalArgumentException(message.toString());
        }
      },
      requireNotNull: function (value, message) {
        if (value == null) {
          throw new Kotlin.IllegalArgumentException(Kotlin.toString(message));
        }
         else {
          return value;
        }
      },
      check: function (value, message) {
        if (!value) {
          throw new Kotlin.IllegalStateException(Kotlin.toString(message));
        }
      },
      check_0: function (value, lazyMessage) {
        if (!value) {
          var message = lazyMessage();
          throw new Kotlin.IllegalStateException(message.toString());
        }
      },
      checkNotNull: function (value, message) {
        if (value == null) {
          throw new Kotlin.IllegalStateException(message);
        }
         else {
          return value;
        }
      },
      filter_8: function ($receiver, predicate) {
        return new _.kotlin.FilterIterator($receiver, predicate);
      },
      fj: function (predicate, it) {
        return !predicate(it);
      },
      filterNot_7: function ($receiver, predicate) {
        return _.kotlin.filter_8($receiver, _.kotlin.fj.bind(null, predicate));
      },
      filterNotNull: function ($receiver) {
        return new _.kotlin.FilterNotNullIterator($receiver);
      },
      map_10: function ($receiver, transform) {
        return new _.kotlin.MapIterator($receiver, transform);
      },
      flatMap_7: function ($receiver, transform) {
        return new _.kotlin.FlatMapIterator($receiver, transform);
      },
      fk: function (it) {
        if (it == null)
          throw new Kotlin.IllegalArgumentException('null element in iterator ' + $receiver);
        else
          return it;
      },
      requireNoNulls: function ($receiver) {
        return _.kotlin.map_10($receiver, _.kotlin.fk);
      },
      fl: function (count, it) {
        return --count.v >= 0;
      },
      take_7: function ($receiver, n) {
        var count = {v: n};
        return _.kotlin.takeWhile_7($receiver, _.kotlin.fl.bind(null, count));
      },
      takeWhile_7: function ($receiver, predicate) {
        return new _.kotlin.TakeWhileIterator($receiver, predicate);
      },
      plus_23: function ($receiver, element) {
        return new _.kotlin.CompositeIterator([$receiver, new _.kotlin.SingleIterator(element)]);
      },
      plus_24: function ($receiver, iterator) {
        return new _.kotlin.CompositeIterator([$receiver, iterator]);
      },
      plus_25: function ($receiver, collection) {
        return _.kotlin.plus_24($receiver, collection.iterator());
      },
      all_8: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      any_8: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      count_10: function ($receiver, predicate) {
        var count = 0;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      find_8: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      filter_9: function ($receiver, predicate) {
        return _.kotlin.filterTo_8($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterTo_8: function ($receiver, result, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNot_8: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_8($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterNotTo_8: function ($receiver, result, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNotNull_0: function ($receiver) {
        return _.kotlin.filterNotNullTo_0($receiver, new Kotlin.ArrayList(0));
      },
      filterNotNullTo_0: function ($receiver, result) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (element != null)
              result.add(element);
          }
        }
        return result;
      },
      partition_8: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList(0);
        var second = new Kotlin.ArrayList(0);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      map_11: function ($receiver, transform) {
        return _.kotlin.mapTo_9($receiver, new Kotlin.ArrayList(0), transform);
      },
      mapTo_9: function ($receiver, result, transform) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            result.add(transform(item));
          }
        }
        return result;
      },
      flatMap_8: function ($receiver, transform) {
        return _.kotlin.flatMapTo_8($receiver, new Kotlin.ArrayList(0), transform);
      },
      flatMapTo_8: function ($receiver, result, transform) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            var list = transform(element);
            {
              var tmp$3 = list.iterator();
              while (tmp$3.hasNext()) {
                var r = tmp$3.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      },
      forEach_8: function ($receiver, operation) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            operation(element);
          }
        }
      },
      fold_8: function ($receiver, initial, operation) {
        var answer = initial;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            answer = operation(answer, element);
          }
        }
        return answer;
      },
      foldRight_7: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      reduce_8: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      },
      reduceRight_7: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      groupBy_8: function ($receiver, toKey) {
        return _.kotlin.groupByTo_8($receiver, new Kotlin.ComplexHashMap(0), toKey);
      },
      fm: function () {
        return new Kotlin.ArrayList(0);
      },
      groupByTo_8: function ($receiver, result, toKey) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.fm);
            list.add(element);
          }
        }
        return result;
      },
      drop_8: function ($receiver, n) {
        return _.kotlin.dropWhile_8($receiver, _.kotlin.countTo(n));
      },
      dropWhile_8: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_8($receiver, new Kotlin.ArrayList(0), predicate);
      },
      dropWhileTo_8: function ($receiver, result, predicate) {
        var start = true;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      },
      take_8: function ($receiver, n) {
        return _.kotlin.takeWhile_8($receiver, _.kotlin.countTo(n));
      },
      takeWhile_8: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_8($receiver, new Kotlin.ArrayList(0), predicate);
      },
      takeWhileTo_8: function ($receiver, result, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      },
      toCollection_9: function ($receiver, result) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            result.add(element);
          }
        }
        return result;
      },
      reverse_8: function ($receiver) {
        var list = _.kotlin.toCollection_9($receiver, new Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      },
      toLinkedList_8: function ($receiver) {
        return _.kotlin.toCollection_9($receiver, new Kotlin.LinkedList());
      },
      toList_8: function ($receiver) {
        return _.kotlin.toCollection_9($receiver, new Kotlin.ArrayList(0));
      },
      toSet_8: function ($receiver) {
        return _.kotlin.toCollection_9($receiver, new Kotlin.LinkedHashSet());
      },
      toSortedSet_8: function ($receiver) {
        return _.kotlin.toCollection_9($receiver, new Kotlin.TreeSet());
      },
      requireNoNulls_0: function ($receiver) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (element == null) {
              throw new Kotlin.IllegalArgumentException('null element found in ' + $receiver);
            }
          }
        }
        return $receiver != null ? $receiver : Kotlin.throwNPE();
      },
      plus_26: function ($receiver, element) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_9($receiver, answer);
        answer.add(element);
        return answer;
      },
      plus_27: function ($receiver, iterator) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_9($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      },
      plus_28: function ($receiver, collection) {
        return _.kotlin.plus_27($receiver, collection.iterator());
      },
      withIndices_8: function ($receiver) {
        return new _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      },
      fn: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      },
      sortBy_8: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_9($receiver, new Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.fn.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      appendString_8: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      },
      makeString_8: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = new Kotlin.StringBuilder();
        _.kotlin.appendString_8($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      },
      filter_2: function ($receiver, predicate) {
        return _.kotlin.filterTo_7($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterNot_9: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_7($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterNotNull_1: function ($receiver) {
        return _.kotlin.filterNotNullTo($receiver, new Kotlin.ArrayList(0));
      },
      map_3: function ($receiver, transform) {
        return _.kotlin.mapTo_8($receiver, new Kotlin.ArrayList(0), transform);
      },
      flatMap_9: function ($receiver, transform) {
        return _.kotlin.flatMapTo_7($receiver, new Kotlin.ArrayList(0), transform);
      },
      take_9: function ($receiver, n) {
        return _.kotlin.takeWhile_9($receiver, _.kotlin.countTo(n));
      },
      takeWhile_9: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_7($receiver, new Kotlin.ArrayList(0), predicate);
      },
      requireNoNulls_1: function ($receiver) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (element == null) {
              throw new Kotlin.IllegalArgumentException('null element found in ' + $receiver);
            }
          }
        }
        return $receiver != null ? $receiver : Kotlin.throwNPE();
      },
      plus_29: function ($receiver, element) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_5($receiver, answer);
        answer.add(element);
        return answer;
      },
      plus_30: function ($receiver, iterator) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_5($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      },
      plus_31: function ($receiver, collection) {
        return _.kotlin.plus_30($receiver, collection.iterator());
      },
      all_9: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      any_9: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      count_11: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      find_9: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      filterTo_9: function ($receiver, result, predicate) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNotTo_9: function ($receiver, result, predicate) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNotNullTo_1: function ($receiver, result) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (element != null)
              result.add(element);
          }
        }
        return result;
      },
      partition_9: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList(0);
        var second = new Kotlin.ArrayList(0);
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      mapTo_10: function ($receiver, result, transform) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      },
      flatMapTo_9: function ($receiver, result, transform) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      },
      forEach_9: function ($receiver, operation) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      fold_9: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      },
      reduce_9: function ($receiver, operation) {
        var iterator = $receiver;
        if (!iterator.hasNext()) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      },
      groupBy_9: function ($receiver, toKey) {
        return _.kotlin.groupByTo_9($receiver, new Kotlin.ComplexHashMap(0), toKey);
      },
      fo: function () {
        return new Kotlin.ArrayList(0);
      },
      groupByTo_9: function ($receiver, result, toKey) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.fo);
            list.add(element);
          }
        }
        return result;
      },
      drop_9: function ($receiver, n) {
        return _.kotlin.dropWhile_9($receiver, _.kotlin.countTo(n));
      },
      dropWhile_9: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_9($receiver, new Kotlin.ArrayList(0), predicate);
      },
      dropWhileTo_9: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      },
      takeWhileTo_9: function ($receiver, result, predicate) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      },
      toCollection_1: function ($receiver, result) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      },
      reverse_9: function ($receiver) {
        var list = _.kotlin.toCollection_1($receiver, new Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      },
      toLinkedList_9: function ($receiver) {
        return _.kotlin.toCollection_1($receiver, new Kotlin.LinkedList());
      },
      toList_9: function ($receiver) {
        return _.kotlin.toCollection_1($receiver, new Kotlin.ArrayList(0));
      },
      toSet_9: function ($receiver) {
        return _.kotlin.toCollection_1($receiver, new Kotlin.LinkedHashSet());
      },
      toSortedSet_9: function ($receiver) {
        return _.kotlin.toCollection_1($receiver, new Kotlin.TreeSet());
      },
      withIndices_9: function ($receiver) {
        return new _.kotlin.IndexIterator($receiver);
      },
      fp: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      },
      sortBy_9: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_1($receiver, new Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.fp.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      appendString_9: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      },
      makeString_9: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = new Kotlin.StringBuilder();
        _.kotlin.appendString_9($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      },
      support: Kotlin.definePackage(function () {
        this.State = Kotlin.createObject(null, function () {
          this.Ready = 0;
          this.NotReady = 1;
          this.Done = 2;
          this.Failed = 3;
        });
      }, /** @lends _.kotlin.support */ {
        AbstractIterator: _c.AbstractIterator
      })
    }),
    org: Kotlin.definePackage(null, /** @lends _.org */ {
      kevoree: Kotlin.definePackage(null, /** @lends _.org.kevoree */ {
        util: Kotlin.definePackage(function () {
          this.Constants = Kotlin.createObject(null, function () {
            this.UNKNOWN_MUTATION_TYPE_EXCEPTION = 'Unknown mutation type: ';
            this.READ_ONLY_EXCEPTION = 'This model is ReadOnly. Elements are not modifiable.';
            this.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION = 'The list in parameter of the setter cannot be null. Use removeAll to empty a collection.';
            this.ELEMENT_HAS_NO_KEY_IN_COLLECTION = 'Cannot set the collection, because at least one element of it has no key!';
            this.EMPTY_KEY = 'Key empty : please set the attribute key before adding the object.';
            this.KMFQL_CONTAINED = 'contained';
            this.STRING_DEFAULTVAL = '';
            this.INT_DEFAULTVAL = 0;
            this.BOOLEAN_DEFAULTVAL = false;
            this.CHAR_DEFAULTVAL = 'a';
            this.SHORT_DEFAULTVAL = 0;
            this.LONG_DEFAULTVAL = 0.0;
            this.DOUBLE_DEFAULTVAL = 0.0;
            this.FLOAT_DEFAULTVAL = 0.0;
            this.BYTE_DEFAULTVAL = 0;
            this.org_kevoree_Instance = 'org.kevoree.Instance';
            this.Ref_superTypes = 'superTypes';
            this.Att_started = 'started';
            this.org_kevoree_NodeNetwork = 'org.kevoree.NodeNetwork';
            this.org_kevoree_TypedElement = 'org.kevoree.TypedElement';
            this.Ref_hub = 'hub';
            this.Ref_dataTypes = 'dataTypes';
            this.Att_factoryBean = 'factoryBean';
            this.Ref_port = 'port';
            this.Ref_returnType = 'returnType';
            this.Ref_elements = 'elements';
            this.CN_Dictionary = 'Dictionary';
            this.Ref_portTypeRef = 'portTypeRef';
            this.CN_ContainerRoot = 'ContainerRoot';
            this.CN_Operation = 'Operation';
            this.CN_PortType = 'PortType';
            this.Att_networkType = 'networkType';
            this.Ref_values = 'values';
            this.Ref_initBy = 'initBy';
            this.Ref_link = 'link';
            this.org_kevoree_ContainerRoot = 'org.kevoree.ContainerRoot';
            this.CN_Group = 'Group';
            this.Ref_hosts = 'hosts';
            this.Att_interface = 'interface';
            this.org_kevoree_MBinding = 'org.kevoree.MBinding';
            this.Ref_subTypes = 'subTypes';
            this.Ref_groups = 'groups';
            this.org_kevoree_Group = 'org.kevoree.Group';
            this.CN_TypedElement = 'TypedElement';
            this.Att_type = 'type';
            this.Ref_dictionary = 'dictionary';
            this.org_kevoree_DeployUnit = 'org.kevoree.DeployUnit';
            this.Ref_fragmentDictionary = 'fragmentDictionary';
            this.Ref_hubs = 'hubs';
            this.Ref_mappings = 'mappings';
            this.Ref_attributes = 'attributes';
            this.Att_hashcode = 'hashcode';
            this.Att_lowerFragments = 'lowerFragments';
            this.Ref_networkInformation = 'networkInformation';
            this.Att_datatype = 'datatype';
            this.Ref_type = 'type';
            this.Att_abstract = 'abstract';
            this.Att_version = 'version';
            this.CN_Namespace = 'Namespace';
            this.org_kevoree_ContainerNode = 'org.kevoree.ContainerNode';
            this.Ref_components = 'components';
            this.CN_ChannelType = 'ChannelType';
            this.CN_GroupType = 'GroupType';
            this.Ref_typeDefinitions = 'typeDefinitions';
            this.Ref_genericTypes = 'genericTypes';
            this.Ref_requiredLibs = 'requiredLibs';
            this.CN_PortTypeRef = 'PortTypeRef';
            this.org_kevoree_DictionaryValue = 'org.kevoree.DictionaryValue';
            this.Ref_units = 'units';
            this.CN_DeployUnit = 'DeployUnit';
            this.org_kevoree_NodeLink = 'org.kevoree.NodeLink';
            this.org_kevoree_Parameter = 'org.kevoree.Parameter';
            this.org_kevoree_Repository = 'org.kevoree.Repository';
            this.CN_NamedElement = 'NamedElement';
            this.Att_serviceMethodName = 'serviceMethodName';
            this.CN_Instance = 'Instance';
            this.Ref_networkProperties = 'networkProperties';
            this.Att_name = 'name';
            this.CN_Repository = 'Repository';
            this.CN_ComponentType = 'ComponentType';
            this.Att_order = 'order';
            this.Att_lowerBindings = 'lowerBindings';
            this.org_kevoree_GroupType = 'org.kevoree.GroupType';
            this.org_kevoree_Operation = 'org.kevoree.Operation';
            this.CN_Port = 'Port';
            this.Att_optional = 'optional';
            this.CN_FragmentDictionary = 'FragmentDictionary';
            this.Att_metaData = 'metaData';
            this.Att_beanMethodName = 'beanMethodName';
            this.org_kevoree_TypeDefinition = 'org.kevoree.TypeDefinition';
            this.Ref_target = 'target';
            this.org_kevoree_TypeLibrary = 'org.kevoree.TypeLibrary';
            this.Att_paramTypes = 'paramTypes';
            this.CN_MBinding = 'MBinding';
            this.Att_noDependency = 'noDependency';
            this.CN_NodeLink = 'NodeLink';
            this.CN_PortTypeMapping = 'PortTypeMapping';
            this.Ref_provided = 'provided';
            this.Att_defaultValue = 'defaultValue';
            this.org_kevoree_PortTypeMapping = 'org.kevoree.PortTypeMapping';
            this.Ref_dictionaryType = 'dictionaryType';
            this.CN_ComponentInstance = 'ComponentInstance';
            this.Att_zoneID = 'zoneID';
            this.Att_upperBindings = 'upperBindings';
            this.Ref_host = 'host';
            this.CN_TypeLibrary = 'TypeLibrary';
            this.Att_url = 'url';
            this.Ref_namespace = 'namespace';
            this.org_kevoree_NodeType = 'org.kevoree.NodeType';
            this.CN_ServicePortType = 'ServicePortType';
            this.CN_NodeNetwork = 'NodeNetwork';
            this.Att_state = 'state';
            this.Att_fragmentDependant = 'fragmentDependant';
            this.org_kevoree_ServicePortType = 'org.kevoree.ServicePortType';
            this.org_kevoree_PortType = 'org.kevoree.PortType';
            this.CN_MessagePortType = 'MessagePortType';
            this.Ref_operations = 'operations';
            this.CN_DictionaryAttribute = 'DictionaryAttribute';
            this.Att_generated_KMF_ID = 'generated_KMF_ID';
            this.org_kevoree_NamedElement = 'org.kevoree.NamedElement';
            this.CN_TypeDefinition = 'TypeDefinition';
            this.org_kevoree_ComponentType = 'org.kevoree.ComponentType';
            this.Ref_mBindings = 'mBindings';
            this.Ref_subNodes = 'subNodes';
            this.Ref_nodes = 'nodes';
            this.Ref_deployUnit = 'deployUnit';
            this.org_kevoree_ChannelType = 'org.kevoree.ChannelType';
            this.Ref_nodeNetworks = 'nodeNetworks';
            this.Ref_parameters = 'parameters';
            this.Att_estimatedRate = 'estimatedRate';
            this.Att_value = 'value';
            this.org_kevoree_NetworkProperty = 'org.kevoree.NetworkProperty';
            this.org_kevoree_Port = 'org.kevoree.Port';
            this.org_kevoree_ComponentInstance = 'org.kevoree.ComponentInstance';
            this.CN_NetworkInfo = 'NetworkInfo';
            this.org_kevoree_DictionaryAttribute = 'org.kevoree.DictionaryAttribute';
            this.org_kevoree_Namespace = 'org.kevoree.Namespace';
            this.org_kevoree_FragmentDictionary = 'org.kevoree.FragmentDictionary';
            this.Ref_typeDefinition = 'typeDefinition';
            this.org_kevoree_Channel = 'org.kevoree.Channel';
            this.Ref_deployUnits = 'deployUnits';
            this.org_kevoree_Dictionary = 'org.kevoree.Dictionary';
            this.Att_synchrone = 'synchrone';
            this.Ref_repositories = 'repositories';
            this.Ref_required = 'required';
            this.Att_lastCheck = 'lastCheck';
            this.Ref_libraries = 'libraries';
            this.Att_upperFragments = 'upperFragments';
            this.org_kevoree_NetworkInfo = 'org.kevoree.NetworkInfo';
            this.CN_ContainerNode = 'ContainerNode';
            this.Att_groupName = 'groupName';
            this.CN_Parameter = 'Parameter';
            this.CN_DictionaryValue = 'DictionaryValue';
            this.org_kevoree_PortTypeRef = 'org.kevoree.PortTypeRef';
            this.Ref_filters = 'filters';
            this.CN_NetworkProperty = 'NetworkProperty';
            this.org_kevoree_DictionaryType = 'org.kevoree.DictionaryType';
            this.CN_NodeType = 'NodeType';
            this.Att_bean = 'bean';
            this.CN_Channel = 'Channel';
            this.Ref_bindings = 'bindings';
            this.Ref_ref = 'ref';
            this.CN_DictionaryType = 'DictionaryType';
            this.org_kevoree_MessagePortType = 'org.kevoree.MessagePortType';
          });
        }, /** @lends _.org.kevoree.util */ {
        }),
        modeling: Kotlin.definePackage(null, /** @lends _.org.kevoree.modeling */ {
          api: Kotlin.definePackage(null, /** @lends _.org.kevoree.modeling.api */ {
            ModelLoader: _c.ModelLoader,
            ModelSerializer: _c.ModelSerializer,
            util: Kotlin.definePackage(function () {
              this.ByteConverter = Kotlin.createObject(null, null, {
                toChar: function (b) {
                  return b != null ? b : Kotlin.throwNPE();
                },
                fromChar: function (b) {
                  return b != null ? b : Kotlin.throwNPE();
                },
                byteArrayInputStreamFromString: function (str) {
                  var bytes = Kotlin.numberArrayOfSize(str.length);
                  var i = 0;
                  while (i < str.length) {
                    var tmp$0;
                    bytes[i] = (tmp$0 = str.charAt(i)) != null ? tmp$0 : Kotlin.throwNPE();
                    i = i + 1;
                  }
                  return new _.java.io.ByteArrayInputStream(bytes);
                }
              });
              this.AttConverter = Kotlin.createObject(null, null, {
                convFlatAtt: function (value) {
                  if (value == null) {
                    return null;
                  }
                  if (Kotlin.isType(value, Kotlin.ArrayList)) {
                    var isF = true;
                    var buffer = new _.java.lang.StringBuilder();
                    {
                      var tmp$0 = value.iterator();
                      while (tmp$0.hasNext()) {
                        var v = tmp$0.next();
                        if (!isF) {
                          buffer.append('$');
                        }
                        buffer.append(Kotlin.toString(v));
                        isF = false;
                      }
                    }
                    return buffer.toString();
                  }
                   else {
                    return Kotlin.toString(value);
                  }
                },
                convAttFlat: function (value) {
                  return Kotlin.splitString(value.toString(), '$');
                }
              });
            }, /** @lends _.org.kevoree.modeling.api.util */ {
              ModelVisitor: _c.ModelVisitor,
              ElementAttributeType: Kotlin.createClass(Kotlin.Enum, function $fun() {
                $fun.baseInitializer.call(this);
              }, null, /** @lends _.org.kevoree.modeling.api.util.ElementAttributeType */ {
                object_initializer$: function () {
                  return Kotlin.createEnumEntries({
                    ATTRIBUTE: new _.org.kevoree.modeling.api.util.ElementAttributeType(),
                    REFERENCE: new _.org.kevoree.modeling.api.util.ElementAttributeType(),
                    CONTAINMENT: new _.org.kevoree.modeling.api.util.ElementAttributeType()
                  });
                }
              }),
              ActionType: Kotlin.createClass(Kotlin.Enum, function $fun() {
                $fun.baseInitializer.call(this);
              }, null, /** @lends _.org.kevoree.modeling.api.util.ActionType */ {
                object_initializer$: function () {
                  return Kotlin.createEnumEntries({
                    SET: new _.org.kevoree.modeling.api.util.ActionType(),
                    ADD: new _.org.kevoree.modeling.api.util.ActionType(),
                    REMOVE: new _.org.kevoree.modeling.api.util.ActionType(),
                    ADD_ALL: new _.org.kevoree.modeling.api.util.ActionType(),
                    REMOVE_ALL: new _.org.kevoree.modeling.api.util.ActionType(),
                    RENEW_INDEX: new _.org.kevoree.modeling.api.util.ActionType()
                  });
                }
              }),
              ModelAttributeVisitor: _c.ModelAttributeVisitor,
              ModelTracker: Kotlin.createClass(_c.ModelElementListener, function (compare) {
                this.compare = compare;
                this.convertor = new _.org.kevoree.modeling.api.trace.Event2Trace(this.compare);
                this.currentModel = null;
                this.invertedTraceSequence = null;
                this.traceSequence = null;
                this.activated = true;
              }, /** @lends _.org.kevoree.modeling.api.util.ModelTracker.prototype */ {
                elementChanged: function (evt) {
                  if (this.activated) {
                    var tmp$0, tmp$1;
                    ((tmp$0 = this.traceSequence) != null ? tmp$0 : Kotlin.throwNPE()).append(this.convertor.convert(evt));
                    ((tmp$1 = this.invertedTraceSequence) != null ? tmp$1 : Kotlin.throwNPE()).append(this.convertor.inverse(evt));
                  }
                },
                track: function (model) {
                  this.currentModel = model;
                  var tmp$0;
                  ((tmp$0 = this.currentModel) != null ? tmp$0 : Kotlin.throwNPE()).addModelTreeListener(this);
                  this.traceSequence = this.compare.createSequence();
                  this.invertedTraceSequence = this.compare.createSequence();
                },
                untrack: function () {
                  var tmp$0;
                  (tmp$0 = this.currentModel) != null ? tmp$0.removeModelTreeListener(this) : null;
                },
                redo: function () {
                  if (this.currentModel != null && this.traceSequence != null) {
                    this.activated = false;
                    try {
                      var tmp$0, tmp$1;
                      ((tmp$0 = this.traceSequence) != null ? tmp$0 : Kotlin.throwNPE()).applyOn((tmp$1 = this.currentModel) != null ? tmp$1 : Kotlin.throwNPE());
                    }
                    finally {
                      this.activated = true;
                    }
                  }
                },
                undo: function () {
                  if (this.currentModel != null && this.invertedTraceSequence != null) {
                    this.activated = false;
                    var tmp$0;
                    ((tmp$0 = this.invertedTraceSequence) != null ? tmp$0 : Kotlin.throwNPE()).reverse();
                    try {
                      var tmp$1, tmp$2;
                      ((tmp$1 = this.invertedTraceSequence) != null ? tmp$1 : Kotlin.throwNPE()).applyOn((tmp$2 = this.currentModel) != null ? tmp$2 : Kotlin.throwNPE());
                    }
                    finally {
                      var tmp$3;
                      ((tmp$3 = this.invertedTraceSequence) != null ? tmp$3 : Kotlin.throwNPE()).reverse();
                      this.activated = true;
                    }
                  }
                },
                reset: function () {
                  this.traceSequence = this.compare.createSequence();
                  this.invertedTraceSequence = this.compare.createSequence();
                }
              })
            }),
            persistence: Kotlin.definePackage(null, /** @lends _.org.kevoree.modeling.api.persistence */ {
              DataStore: _c.DataStore,
              MemoryDataStore: Kotlin.createClass(_c.DataStore, function () {
                this.maps = new Kotlin.PrimitiveHashMap(0);
              }, /** @lends _.org.kevoree.modeling.api.persistence.MemoryDataStore.prototype */ {
                sync: function () {
                },
                getOrCreateSegment: function (segment) {
                  if (!this.maps.containsKey(segment)) {
                    this.maps.put(segment, new Kotlin.PrimitiveHashMap(0));
                  }
                  var tmp$0;
                  return (tmp$0 = this.maps.get(segment)) != null ? tmp$0 : Kotlin.throwNPE();
                },
                put: function (segment, key, value) {
                  this.getOrCreateSegment(segment).put(key, value);
                },
                get: function (segment, key) {
                  return this.getOrCreateSegment(segment).get(key);
                },
                remove: function (segment, key) {
                  this.getOrCreateSegment(segment).remove(key);
                },
                dump: function () {
                  {
                    var tmp$0 = _.kotlin.iterator(this.maps);
                    while (tmp$0.hasNext()) {
                      var k = tmp$0.next();
                      Kotlin.println('Map ' + _.kotlin.get_key(k));
                      {
                        var tmp$1 = _.kotlin.iterator(_.kotlin.get_value(k));
                        while (tmp$1.hasNext()) {
                          var t = tmp$1.next();
                          Kotlin.println(_.kotlin.get_key(t) + '->' + _.kotlin.get_value(t));
                        }
                      }
                    }
                  }
                }
              }),
              Batch: Kotlin.createClass(_c.ModelVisitor, function $fun() {
                $fun.baseInitializer.call(this);
                this.elements = new Kotlin.ArrayList(0);
              }, /** @lends _.org.kevoree.modeling.api.persistence.Batch.prototype */ {
                visit: function (elem, refNameInParent, parent) {
                  if (Kotlin.isType(elem, _c.KMFContainerProxy)) {
                    if (!elem.isResolved) {
                      this.noChildrenVisit();
                      this.noReferencesVisit();
                    }
                     else {
                      this.elements.add(elem);
                    }
                  }
                   else {
                    this.elements.add(elem);
                  }
                },
                addElement: function (e) {
                  this.elements.add(e);
                  return this;
                },
                addElementAndReachable: function (e) {
                  this.elements.add(e);
                  e.visit(this, true, true, true);
                  return this;
                }
              }),
              KMFContainerProxy: _c.KMFContainerProxy
            }),
            time: Kotlin.definePackage(null, /** @lends _.org.kevoree.modeling.api.time */ {
              RelativeTimeStrategy: Kotlin.createClass(Kotlin.Enum, function $fun() {
                $fun.baseInitializer.call(this);
              }, null, /** @lends _.org.kevoree.modeling.api.time.RelativeTimeStrategy */ {
                object_initializer$: function () {
                  return Kotlin.createEnumEntries({
                    RELATIVE_FIRST: new _.org.kevoree.modeling.api.time.RelativeTimeStrategy(),
                    BEGINNING_OF_TIME_FIRST: new _.org.kevoree.modeling.api.time.RelativeTimeStrategy(),
                    LATEST_FIRST: new _.org.kevoree.modeling.api.time.RelativeTimeStrategy()
                  });
                }
              }),
              TimeAwareKMFContainer: _c.TimeAwareKMFContainer,
              TimeSegment: Kotlin.createClass(Kotlin.Enum, function $fun() {
                $fun.baseInitializer.call(this);
              }, null, /** @lends _.org.kevoree.modeling.api.time.TimeSegment */ {
                object_initializer$: function () {
                  return Kotlin.createEnumEntries({
                    LATEST: new _.org.kevoree.modeling.api.time.TimeSegment(),
                    RAW: new _.org.kevoree.modeling.api.time.TimeSegment(),
                    TYPE: new _.org.kevoree.modeling.api.time.TimeSegment()
                  });
                }
              }),
              TimePoint: Kotlin.createClass(null, function (timestamp, sequenceNumber) {
                this.timestamp = timestamp;
                this.sequenceNumber = sequenceNumber;
              }, /** @lends _.org.kevoree.modeling.api.time.TimePoint.prototype */ {
                compareTo: function (other) {
                  if (Kotlin.equals(this, other)) {
                    return 0;
                  }
                  if (this.timestamp === other.timestamp) {
                    return this.sequenceNumber.compareTo(other.sequenceNumber);
                  }
                   else {
                    return this.timestamp.compareTo(other.timestamp);
                  }
                },
                shift: function (timeOffset) {
                  return new _.org.kevoree.modeling.api.time.TimePoint(this.timestamp + timeOffset, 0.0);
                },
                toString: function () {
                  return this.timestamp.toString() + ':' + this.sequenceNumber;
                }
              }, /** @lends _.org.kevoree.modeling.api.time.TimePoint */ {
                object_initializer$: function () {
                  return Kotlin.createObject(null, null, {
                    create: function (v) {
                      var vv = Kotlin.splitString(v, ':');
                      var tmp$0, tmp$1;
                      return new _.org.kevoree.modeling.api.time.TimePoint((tmp$0 = vv[0]) != null ? tmp$0 : Kotlin.throwNPE(), (tmp$1 = vv[1]) != null ? tmp$1 : Kotlin.throwNPE());
                    }
                  });
                }
              })
            }),
            xmi: Kotlin.definePackage(function () {
              this.Token = Kotlin.createObject(null, function () {
                this.XML_HEADER = 0;
                this.END_DOCUMENT = 1;
                this.START_TAG = 2;
                this.END_TAG = 3;
                this.COMMENT = 4;
                this.SINGLETON_TAG = 5;
              });
            }, /** @lends _.org.kevoree.modeling.api.xmi */ {
              XmlParser: Kotlin.createClass(null, function (inputStream) {
                this.inputStream = inputStream;
                this.bytes = this.inputStream.readBytes();
                this.index = -1;
                this.currentChar = null;
                this.xmlVersion = null;
                this.xmlCharset = null;
                this.tagName = '';
                this.tagPrefix = null;
                this.attributesNames = new Kotlin.ArrayList(0);
                this.attributesPrefixes = new Kotlin.ArrayList(0);
                this.attributesValues = new Kotlin.ArrayList(0);
                this.attributeName = new _.java.lang.StringBuilder();
                this.attributePrefix = null;
                this.attributeValue = new _.java.lang.StringBuilder();
                this.readSingleton = false;
              }, /** @lends _.org.kevoree.modeling.api.xmi.XmlParser.prototype */ {
                hasNext: function () {
                  return this.bytes.length - this.index > 2;
                },
                getLocalName: function () {
                  return this.tagName;
                },
                getAttributeCount: function () {
                  return this.attributesNames.size();
                },
                getAttributeLocalName: function (i) {
                  return this.attributesNames.get(i);
                },
                getAttributePrefix: function (i) {
                  return this.attributesPrefixes.get(i);
                },
                getAttributeValue: function (i) {
                  return this.attributesValues.get(i);
                },
                readChar: function () {
                  return _.org.kevoree.modeling.api.util.ByteConverter.toChar(this.bytes[this.index = this.index + 1, this.index]);
                },
                next: function () {
                  if (this.readSingleton) {
                    this.readSingleton = false;
                    return _.org.kevoree.modeling.api.xmi.Token.END_TAG;
                  }
                  if (!this.hasNext()) {
                    return _.org.kevoree.modeling.api.xmi.Token.END_DOCUMENT;
                  }
                  this.attributesNames.clear();
                  this.attributesPrefixes.clear();
                  this.attributesValues.clear();
                  this.read_lessThan();
                  this.currentChar = this.readChar();
                  if (this.currentChar === '?') {
                    this.currentChar = this.readChar();
                    this.read_xmlHeader();
                    return _.org.kevoree.modeling.api.xmi.Token.XML_HEADER;
                  }
                   else if (this.currentChar === '!') {
                    do {
                      this.currentChar = this.readChar();
                    }
                     while (this.currentChar !== '>');
                    return _.org.kevoree.modeling.api.xmi.Token.COMMENT;
                  }
                   else if (this.currentChar === '/') {
                    this.currentChar = this.readChar();
                    this.read_closingTag();
                    return _.org.kevoree.modeling.api.xmi.Token.END_TAG;
                  }
                   else {
                    this.read_openTag();
                    if (this.currentChar === '/') {
                      this.read_upperThan();
                      this.readSingleton = true;
                    }
                    return _.org.kevoree.modeling.api.xmi.Token.START_TAG;
                  }
                },
                read_lessThan: function () {
                  do {
                    this.currentChar = this.readChar();
                  }
                   while (this.currentChar !== '<');
                },
                read_upperThan: function () {
                  while (this.currentChar !== '>') {
                    this.currentChar = this.readChar();
                  }
                },
                read_xmlHeader: function () {
                  this.read_tagName();
                  this.read_attributes();
                  this.read_upperThan();
                },
                read_closingTag: function () {
                  this.read_tagName();
                  this.read_upperThan();
                },
                read_openTag: function () {
                  this.read_tagName();
                  if (this.currentChar !== '>' && this.currentChar !== '/') {
                    this.read_attributes();
                  }
                },
                read_tagName: function () {
                  this.tagName = '' + this.currentChar;
                  this.tagPrefix = null;
                  this.currentChar = this.readChar();
                  while (this.currentChar !== ' ' && this.currentChar !== '>' && this.currentChar !== '/') {
                    if (this.currentChar === ':') {
                      this.tagPrefix = this.tagName;
                      this.tagName = '';
                    }
                     else {
                      this.tagName = this.tagName + this.currentChar;
                    }
                    this.currentChar = this.readChar();
                  }
                },
                read_attributes: function () {
                  var end_of_tag = false;
                  while (this.currentChar === ' ') {
                    this.currentChar = this.readChar();
                  }
                  while (!end_of_tag) {
                    while (this.currentChar !== '=') {
                      if (this.currentChar === ':') {
                        this.attributePrefix = this.attributeName.toString();
                        this.attributeName.delete(0, this.attributeName.length());
                      }
                       else {
                        var tmp$0;
                        this.attributeName.append_0((tmp$0 = this.currentChar) != null ? tmp$0 : Kotlin.throwNPE());
                      }
                      this.currentChar = this.readChar();
                    }
                    do {
                      this.currentChar = this.readChar();
                    }
                     while (this.currentChar !== '"');
                    this.currentChar = this.readChar();
                    while (this.currentChar !== '"') {
                      var tmp$1;
                      this.attributeValue.append_0((tmp$1 = this.currentChar) != null ? tmp$1 : Kotlin.throwNPE());
                      this.currentChar = this.readChar();
                    }
                    this.attributesNames.add(this.attributeName.toString());
                    this.attributesPrefixes.add(this.attributePrefix);
                    this.attributesValues.add(this.attributeValue.toString());
                    this.attributeName.delete(0, this.attributeName.length());
                    this.attributePrefix = null;
                    this.attributeValue.delete(0, this.attributeValue.length());
                    do {
                      this.currentChar = this.readChar();
                      if (this.currentChar === '?' || this.currentChar === '/' || this.currentChar === '-' || this.currentChar === '>') {
                        end_of_tag = true;
                      }
                    }
                     while (!end_of_tag && this.currentChar === ' ');
                  }
                }
              }),
              XMIModelLoader: _c.XMIModelLoader,
              LoadingContext: Kotlin.createClass(null, function () {
                this.xmiReader = null;
                this.loadedRoots = new Kotlin.ArrayList(0);
                this.map = new Kotlin.PrimitiveHashMap(0);
                this.elementsCount = new Kotlin.PrimitiveHashMap(0);
                this.resolvers = new Kotlin.ArrayList(0);
                this.stats = new Kotlin.PrimitiveHashMap(0);
                this.oppositesAlreadySet = new Kotlin.PrimitiveHashMap(0);
              }, /** @lends _.org.kevoree.modeling.api.xmi.LoadingContext.prototype */ {
                isOppositeAlreadySet: function (localRef, oppositeRef) {
                  var res = this.oppositesAlreadySet.get(oppositeRef + '_' + localRef) != null || this.oppositesAlreadySet.get(localRef + '_' + oppositeRef) != null;
                  return res;
                },
                storeOppositeRelation: function (localRef, oppositeRef) {
                  this.oppositesAlreadySet.put(localRef + '_' + oppositeRef, true);
                }
              }),
              XMIResolveCommand: Kotlin.createClass(null, function (context, target, mutatorType, refName, ref, resourceSet) {
                this.context = context;
                this.target = target;
                this.mutatorType = mutatorType;
                this.refName = refName;
                this.ref = ref;
                this.resourceSet = resourceSet;
              }, /** @lends _.org.kevoree.modeling.api.xmi.XMIResolveCommand.prototype */ {
                run: function () {
                  var referencedElement = this.context.map.get(this.ref);
                  if (referencedElement != null) {
                    this.target.reflexiveMutator(this.mutatorType, this.refName, referencedElement, true, false);
                    return;
                  }
                  if (Kotlin.equals(this.ref, '/0/') || Kotlin.equals(this.ref, '/')) {
                    referencedElement = this.context.map.get('/0');
                    if (referencedElement != null) {
                      this.target.reflexiveMutator(this.mutatorType, this.refName, referencedElement, true, false);
                      return;
                    }
                  }
                  if (this.resourceSet != null) {
                    referencedElement = this.resourceSet.resolveObject(this.ref);
                    if (referencedElement != null) {
                      this.target.reflexiveMutator(this.mutatorType, this.refName, referencedElement, true, false);
                      return;
                    }
                  }
                  throw new Error('KMF Load error : reference ' + this.ref + ' not found in map when trying to  ' + this.mutatorType + ' ' + this.refName + '  on ' + this.target.metaClassName() + '(path:' + this.target.path() + ')');
                }
              }),
              ReferencesVisitor: Kotlin.createClass(_c.ModelVisitor, function $fun(ostream, addressTable, elementsCount, resourceSet) {
                this.ostream = ostream;
                this.addressTable = addressTable;
                this.elementsCount = elementsCount;
                this.resourceSet = resourceSet;
                $fun.baseInitializer.call(this);
                this.value = null;
              }, /** @lends _.org.kevoree.modeling.api.xmi.ReferencesVisitor.prototype */ {
                beginVisitElem: function (elem) {
                },
                endVisitElem: function (elem) {
                },
                beginVisitRef: function (refName, refType) {
                },
                endVisitRef: function (refName) {
                  if (this.value != null) {
                    this.ostream.print(' ' + refName + '="' + Kotlin.toString(this.value) + '"');
                    this.value = null;
                  }
                },
                visit: function (elem, refNameInParent, parent) {
                  var tmp$0;
                  var adjustedAddress = (tmp$0 = this.resourceSet) != null ? tmp$0.objToAddr(elem) : null;
                  if (adjustedAddress == null) {
                    adjustedAddress = this.addressTable.get(elem);
                  }
                  if (this.value == null) {
                    this.value = adjustedAddress;
                  }
                   else {
                    this.value = _.jet.plus(this.value, ' ');
                    this.value = _.jet.plus(this.value, Kotlin.toString(adjustedAddress));
                  }
                }
              }),
              AttributesVisitor: Kotlin.createClass(_c.ModelAttributeVisitor, function (ostream, ignoreGeneratedID) {
                this.ostream = ostream;
                this.ignoreGeneratedID = ignoreGeneratedID;
              }, /** @lends _.org.kevoree.modeling.api.xmi.AttributesVisitor.prototype */ {
                visit: function (value, name, parent) {
                  if (value != null && !Kotlin.equals(value, '')) {
                    if (this.ignoreGeneratedID && Kotlin.equals(name, 'generated_KMF_ID')) {
                      return;
                    }
                    this.ostream.print(' ' + name + '="');
                    if (Kotlin.isType(value, Date)) {
                      this.escapeXml(this.ostream, '' + value.getTime());
                    }
                     else {
                      this.escapeXml(this.ostream, _.org.kevoree.modeling.api.util.AttConverter.convFlatAtt(value));
                    }
                    this.ostream.print('"');
                  }
                },
                escapeXml: function (ostream, chain) {
                  if (chain == null) {
                    return;
                  }
                  var i = 0;
                  var max = chain.length;
                  while (i < max) {
                    var c = chain.charAt(i);
                    if (c === '"') {
                      ostream.print('&quot;');
                    }
                     else if (c === '&') {
                      ostream.print('&amp;');
                    }
                     else if (c === "'") {
                      ostream.print('&apos;');
                    }
                     else if (c === '<') {
                      ostream.print('&lt;');
                    }
                     else if (c === '>') {
                      ostream.print('&gt;');
                    }
                     else {
                      ostream.print_0(c);
                    }
                    i = i + 1;
                  }
                }
              }),
              ModelSerializationVisitor: Kotlin.createClass(_c.ModelVisitor, function $fun(ostream, addressTable, elementsCount, resourceSet, ignoreGeneratedID) {
                this.ostream = ostream;
                this.addressTable = addressTable;
                this.elementsCount = elementsCount;
                this.resourceSet = resourceSet;
                $fun.baseInitializer.call(this);
                this.attributeVisitor = new _.org.kevoree.modeling.api.xmi.AttributesVisitor(this.ostream, ignoreGeneratedID);
                this.referenceVisitor = new _.org.kevoree.modeling.api.xmi.ReferencesVisitor(this.ostream, this.addressTable, this.elementsCount, this.resourceSet);
              }, /** @lends _.org.kevoree.modeling.api.xmi.ModelSerializationVisitor.prototype */ {
                beginVisitElem: function (elem) {
                },
                endVisitElem: function (elem) {
                },
                beginVisitRef: function (refName, refType) {
                },
                endVisitRef: function (refName) {
                },
                visit: function (elem, refNameInParent, parent) {
                  this.ostream.print_0('<');
                  this.ostream.print(refNameInParent);
                  this.ostream.print(' xsi:type="' + this.formatMetaClassName(elem.metaClassName()) + '"');
                  elem.visitAttributes(this.attributeVisitor);
                  elem.visit(this.referenceVisitor, false, false, true);
                  this.ostream.println_1('>');
                  elem.visit(this, false, true, false);
                  this.ostream.print('<\/');
                  this.ostream.print(refNameInParent);
                  this.ostream.print_0('>');
                  this.ostream.println();
                },
                formatMetaClassName: function (metaClassName) {
                  var lastPoint = _.js.lastIndexOf(metaClassName, '.');
                  var pack = metaClassName.substring(0, lastPoint);
                  var cls = metaClassName.substring(lastPoint + 1);
                  return pack + ':' + cls;
                }
              }),
              ModelAddressVisitor: Kotlin.createClass(_c.ModelVisitor, function $fun(addressTable, elementsCount, packageList) {
                this.addressTable = addressTable;
                this.elementsCount = elementsCount;
                this.packageList = packageList;
                $fun.baseInitializer.call(this);
              }, /** @lends _.org.kevoree.modeling.api.xmi.ModelAddressVisitor.prototype */ {
                beginVisitElem: function (elem) {
                },
                endVisitElem: function (elem) {
                },
                beginVisitRef: function (refName, refType) {
                },
                endVisitRef: function (refName) {
                },
                visit: function (elem, refNameInParent, parent) {
                  var tmp$0, tmp$1;
                  var parentXmiAddress = (tmp$0 = this.addressTable.get(parent)) != null ? tmp$0 : Kotlin.throwNPE();
                  var i = (tmp$1 = this.elementsCount.get(parentXmiAddress + '/@' + refNameInParent)) != null ? tmp$1 : 0;
                  this.addressTable.put(elem, parentXmiAddress + '/@' + refNameInParent + '.' + i);
                  this.elementsCount.put(parentXmiAddress + '/@' + refNameInParent, i + 1);
                  var pack = elem.metaClassName().substring(0, _.js.lastIndexOf(elem.metaClassName(), '.'));
                  if (!this.packageList.contains(pack))
                    this.packageList.add(pack);
                }
              }),
              XMIModelSerializer: _c.XMIModelSerializer,
              ResourceSet: Kotlin.createClass(null, function () {
                this.resources = new Kotlin.PrimitiveHashMap(0);
                this.invertedResources = new Kotlin.ComplexHashMap(0);
              }, /** @lends _.org.kevoree.modeling.api.xmi.ResourceSet.prototype */ {
                registerXmiAddrMappedObjects: function (nsuri, xmiAddrs) {
                  this.resources.put(nsuri, xmiAddrs);
                  {
                    var tmp$0 = _.kotlin.iterator(xmiAddrs);
                    while (tmp$0.hasNext()) {
                      var ad = tmp$0.next();
                      if (this.invertedResources.containsKey(_.kotlin.get_value(ad))) {
                        var alreadyVal = this.invertedResources.get(_.kotlin.get_value(ad));
                        if ((alreadyVal != null ? alreadyVal : Kotlin.throwNPE()).addr.contains('@')) {
                          this.invertedResources.put(_.kotlin.get_value(ad), new _.org.kevoree.modeling.api.xmi.XmiObjAddr(nsuri, _.kotlin.get_key(ad)));
                        }
                      }
                       else {
                        this.invertedResources.put(_.kotlin.get_value(ad), new _.org.kevoree.modeling.api.xmi.XmiObjAddr(nsuri, _.kotlin.get_key(ad)));
                      }
                    }
                  }
                },
                resolveObject: function (xmiAddr) {
                  var typeAndAddr = Kotlin.splitString(xmiAddr, ' ');
                  if (typeAndAddr.length > 1) {
                    var addrs = Kotlin.splitString(typeAndAddr[1], '#');
                    if (addrs.length === 2) {
                      var resolvedAddrs = this.resources.get(addrs[0]);
                      var addr = addrs[1];
                      addr = '#' + addr;
                      addr = addr.replace('#//', '/0/');
                      return resolvedAddrs.get(addr);
                    }
                  }
                  return null;
                },
                objToAddr: function (obj) {
                  var resolved = this.invertedResources.get(obj);
                  if (resolved != null) {
                    var packName = this.formatMetaClassName(obj.metaClassName());
                    var nsURI = resolved.nsuri;
                    var addr = resolved.addr;
                    addr = addr.replace('/0/', '#//');
                    return packName + ' ' + nsURI + addr;
                  }
                  return null;
                },
                formatMetaClassName: function (metaClassName) {
                  var lastPoint = _.js.lastIndexOf(metaClassName, '.');
                  var pack = metaClassName.substring(0, lastPoint);
                  var cls = metaClassName.substring(lastPoint + 1);
                  return pack + ':' + cls;
                }
              }),
              XmiObjAddr: Kotlin.createClass(null, function (nsuri, addr) {
                this.nsuri = nsuri;
                this.addr = addr;
              })
            }),
            trace: Kotlin.definePackage(null, /** @lends _.org.kevoree.modeling.api.trace */ {
              ModelAddTrace: Kotlin.createClass(_c.ModelTrace, function (srcPath, refName, previousPath, typeName) {
                this.srcPath = srcPath;
                this.refName = refName;
                this.previousPath = previousPath;
                this.typeName = typeName;
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelAddTrace.prototype */ {
                toString: function () {
                  var buffer = new _.java.lang.StringBuilder();
                  buffer.append('{ "traceType" : "' + _.org.kevoree.modeling.api.util.ActionType.object.ADD + '" , "src" : "' + this.srcPath + '", "refname" : "' + this.refName + '"');
                  if (this.previousPath != null) {
                    buffer.append(', "previouspath" : "' + this.previousPath + '"');
                  }
                  if (this.typeName != null) {
                    buffer.append(', "typename" : "' + this.typeName + '"');
                  }
                  buffer.append('}');
                  return buffer.toString();
                }
              }),
              ModelAddAllTrace: Kotlin.createClass(_c.ModelTrace, function (srcPath, refName, previousPath, typeName) {
                this.srcPath = srcPath;
                this.refName = refName;
                this.previousPath = previousPath;
                this.typeName = typeName;
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelAddAllTrace.prototype */ {
                mkString: function (ss) {
                  if (ss == null) {
                    return null;
                  }
                  var buffer = new _.java.lang.StringBuilder();
                  var isFirst = true;
                  {
                    var tmp$0 = ss.iterator();
                    while (tmp$0.hasNext()) {
                      var s = tmp$0.next();
                      if (!isFirst) {
                        buffer.append(',');
                      }
                      buffer.append(s);
                      isFirst = false;
                    }
                  }
                  return buffer.toString();
                },
                toString: function () {
                  var buffer = new _.java.lang.StringBuilder();
                  buffer.append('{ "traceType" : "' + _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL + '" , "src" : "' + this.srcPath + '", "refname" : "' + this.refName + '"');
                  if (this.previousPath != null) {
                    buffer.append(', "previouspath" : "' + this.mkString(this.previousPath) + '"');
                  }
                  if (this.typeName != null) {
                    buffer.append(', "typename" : "' + this.mkString(this.typeName) + '"');
                  }
                  buffer.append('}');
                  return buffer.toString();
                }
              }),
              ModelRemoveTrace: Kotlin.createClass(_c.ModelTrace, function (srcPath, refName, objPath) {
                this.srcPath = srcPath;
                this.refName = refName;
                this.objPath = objPath;
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelRemoveTrace.prototype */ {
                toString: function () {
                  return '{ "traceType" : "' + _.org.kevoree.modeling.api.util.ActionType.object.REMOVE + '" , "src" : "' + this.srcPath + '", "refname" : "' + this.refName + '", "objpath" : "' + this.objPath + '" }';
                }
              }),
              ModelRemoveAllTrace: Kotlin.createClass(_c.ModelTrace, function (srcPath, refName) {
                this.srcPath = srcPath;
                this.refName = refName;
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelRemoveAllTrace.prototype */ {
                toString: function () {
                  return '{ "traceType" : "' + _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL + '" , "src" : "' + this.srcPath + '", "refname" : "' + this.refName + '" }';
                }
              }),
              ModelSetTrace: Kotlin.createClass(_c.ModelTrace, function (srcPath, refName, objPath, content, typeName) {
                this.srcPath = srcPath;
                this.refName = refName;
                this.objPath = objPath;
                this.content = content;
                this.typeName = typeName;
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelSetTrace.prototype */ {
                toString: function () {
                  var buffer = new _.java.lang.StringBuilder();
                  buffer.append('{ "traceType" : "' + _.org.kevoree.modeling.api.util.ActionType.object.SET + '" , "src" : "' + this.srcPath + '", "refname" : "' + this.refName + '"');
                  if (this.objPath != null) {
                    buffer.append(', "objpath" : "' + this.objPath + '"');
                  }
                  if (this.content != null) {
                    buffer.append(', "content" : "' + this.content + '"');
                  }
                  if (this.typeName != null) {
                    buffer.append(', "typename" : "' + this.typeName + '"');
                  }
                  buffer.append('}');
                  return buffer.toString();
                }
              }),
              DefaultTraceConverter: Kotlin.createClass(_c.TraceConverter, function () {
                this.metaClassNameEquivalence_1 = new Kotlin.PrimitiveHashMap(0);
                this.metaClassNameEquivalence_2 = new Kotlin.PrimitiveHashMap(0);
                this.attNameEquivalence_1 = new Kotlin.PrimitiveHashMap(0);
                this.attNameEquivalence_2 = new Kotlin.PrimitiveHashMap(0);
              }, /** @lends _.org.kevoree.modeling.api.trace.DefaultTraceConverter.prototype */ {
                addMetaClassEquivalence: function (name1, name2) {
                  this.metaClassNameEquivalence_1.put(name1, name2);
                  this.metaClassNameEquivalence_2.put(name2, name2);
                },
                addAttEquivalence: function (name1, name2) {
                  var fqnArray_1 = Kotlin.splitString(name1, '#');
                  var fqnArray_2 = Kotlin.splitString(name1, '#');
                  this.attNameEquivalence_1.put(name1, name2);
                  this.attNameEquivalence_2.put(name2, name2);
                },
                convert: function (trace) {
                  if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelAddTrace)) {
                    var addTrace = trace != null ? trace : Kotlin.throwNPE();
                    var newTrace = new _.org.kevoree.modeling.api.trace.ModelAddTrace(addTrace.srcPath, addTrace.refName, addTrace.previousPath, this.tryConvertClassName(addTrace.typeName));
                    return newTrace;
                  }
                   else if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelSetTrace)) {
                    var setTrace = trace != null ? trace : Kotlin.throwNPE();
                    var newTrace_0 = new _.org.kevoree.modeling.api.trace.ModelSetTrace(setTrace.srcPath, setTrace.refName, setTrace.objPath, setTrace.content, this.tryConvertClassName(setTrace.typeName));
                    return newTrace_0;
                  }
                   else {
                    return trace;
                  }
                },
                tryConvertPath: function (previousPath) {
                  if (previousPath == null) {
                    return null;
                  }
                  return previousPath;
                },
                tryConvertClassName: function (previousClassName) {
                  if (previousClassName == null) {
                    return null;
                  }
                  if (this.metaClassNameEquivalence_1.containsKey(previousClassName)) {
                    var tmp$0;
                    return (tmp$0 = this.metaClassNameEquivalence_1.get(previousClassName)) != null ? tmp$0 : Kotlin.throwNPE();
                  }
                  if (this.metaClassNameEquivalence_2.containsKey(previousClassName)) {
                    var tmp$1;
                    return (tmp$1 = this.metaClassNameEquivalence_2.get(previousClassName)) != null ? tmp$1 : Kotlin.throwNPE();
                  }
                  return previousClassName;
                },
                tryConvertAttName: function (previousAttName) {
                  if (previousAttName == null) {
                    return null;
                  }
                  var FQNattName = previousAttName;
                  if (this.attNameEquivalence_1.containsKey(FQNattName)) {
                    var tmp$0;
                    return (tmp$0 = this.attNameEquivalence_1.get(FQNattName)) != null ? tmp$0 : Kotlin.throwNPE();
                  }
                  if (this.attNameEquivalence_2.containsKey(FQNattName)) {
                    var tmp$1;
                    return (tmp$1 = this.attNameEquivalence_2.get(FQNattName)) != null ? tmp$1 : Kotlin.throwNPE();
                  }
                  return previousAttName;
                }
              }),
              ModelTraceApplicator: Kotlin.createClass(null, function (targetModel, factory) {
                this.targetModel = targetModel;
                this.factory = factory;
                this.pendingObj = null;
                this.pendingParent = null;
                this.pendingParentRefName = null;
                this.pendingObjPath = null;
                this.fireEvents = true;
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelTraceApplicator.prototype */ {
                tryClosePending: function (srcPath) {
                  if (this.pendingObj != null && !Kotlin.equals(this.pendingObjPath, srcPath)) {
                    var tmp$0, tmp$1;
                    ((tmp$0 = this.pendingParent) != null ? tmp$0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, (tmp$1 = this.pendingParentRefName) != null ? tmp$1 : Kotlin.throwNPE(), this.pendingObj, true, this.fireEvents);
                    this.pendingObj = null;
                    this.pendingObjPath = null;
                    this.pendingParentRefName = null;
                    this.pendingParent = null;
                  }
                },
                createOrAdd: function (previousPath, target, refName, potentialTypeName) {
                  var tmp$0;
                  if (previousPath != null) {
                    tmp$0 = this.targetModel.findByPath(previousPath);
                  }
                   else {
                    tmp$0 = null;
                  }
                  var targetElem = tmp$0;
                  if (targetElem != null) {
                    target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, refName, targetElem, true, this.fireEvents);
                  }
                   else {
                    this.pendingObj = this.factory.create(potentialTypeName != null ? potentialTypeName : Kotlin.throwNPE());
                    this.pendingObjPath = previousPath;
                    this.pendingParentRefName = refName;
                    this.pendingParent = target;
                  }
                },
                applyTraceOnModel: function (traceSeq) {
                  {
                    var tmp$0 = traceSeq.traces.iterator();
                    while (tmp$0.hasNext()) {
                      var trace = tmp$0.next();
                      var target = this.targetModel;
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelAddTrace)) {
                        this.tryClosePending(null);
                        if (!Kotlin.equals(trace.srcPath, '')) {
                          var tmp$1;
                          target = (tmp$1 = this.targetModel.findByPath(trace.srcPath)) != null ? tmp$1 : Kotlin.throwNPE();
                        }
                        this.createOrAdd(trace.previousPath, target, trace.refName, trace.typeName);
                      }
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelAddAllTrace)) {
                        this.tryClosePending(null);
                        var i = 0;
                        var tmp$2;
                        {
                          var tmp$3 = ((tmp$2 = trace.previousPath) != null ? tmp$2 : Kotlin.throwNPE()).iterator();
                          while (tmp$3.hasNext()) {
                            var path = tmp$3.next();
                            var tmp$4;
                            this.createOrAdd(path, target, trace.refName, ((tmp$4 = trace.typeName) != null ? tmp$4 : Kotlin.throwNPE()).get(i));
                            i++;
                          }
                        }
                      }
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelRemoveTrace)) {
                        this.tryClosePending(trace.srcPath);
                        var tempTarget = this.targetModel;
                        if (!Kotlin.equals(trace.srcPath, '')) {
                          tempTarget = this.targetModel.findByPath(trace.srcPath);
                        }
                        if (tempTarget != null) {
                          (tempTarget != null ? tempTarget : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, trace.refName, this.targetModel.findByPath(trace.objPath), true, this.fireEvents);
                        }
                      }
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelRemoveAllTrace)) {
                        this.tryClosePending(trace.srcPath);
                        var tempTarget_0 = this.targetModel;
                        if (!Kotlin.equals(trace.srcPath, '')) {
                          tempTarget_0 = this.targetModel.findByPath(trace.srcPath);
                        }
                        if (tempTarget_0 != null) {
                          (tempTarget_0 != null ? tempTarget_0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, trace.refName, null, true, this.fireEvents);
                        }
                      }
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelSetTrace)) {
                        this.tryClosePending(trace.srcPath);
                        if (!Kotlin.equals(trace.srcPath, '') && !Kotlin.equals(trace.srcPath, this.pendingObjPath)) {
                          var tempObject = this.targetModel.findByPath(trace.srcPath);
                          if (tempObject == null) {
                            throw new Error('Set Trace source not found for path : ' + trace.srcPath + ' pending ' + this.pendingObjPath + '\n' + trace.toString());
                          }
                          target = tempObject != null ? tempObject : Kotlin.throwNPE();
                        }
                         else {
                          if (Kotlin.equals(trace.srcPath, this.pendingObjPath) && this.pendingObj != null) {
                            var tmp$5;
                            target = (tmp$5 = this.pendingObj) != null ? tmp$5 : Kotlin.throwNPE();
                          }
                        }
                        if (trace.content != null) {
                          target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, trace.refName, trace.content, true, this.fireEvents);
                        }
                         else {
                          var tmp$6;
                          if (trace.objPath != null) {
                            tmp$6 = this.targetModel.findByPath(trace.objPath);
                          }
                           else {
                            tmp$6 = null;
                          }
                          var targetContentPath = tmp$6;
                          if (targetContentPath != null) {
                            target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, trace.refName, targetContentPath, true, this.fireEvents);
                          }
                           else {
                            if (trace.typeName != null && !Kotlin.equals(trace.typeName, '')) {
                              this.createOrAdd(trace.objPath, target, trace.refName, trace.typeName);
                            }
                             else {
                              target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, trace.refName, targetContentPath, true, this.fireEvents);
                            }
                          }
                        }
                      }
                    }
                  }
                  this.tryClosePending(null);
                }
              }),
              Event2Trace: Kotlin.createClass(null, function (compare) {
                this.compare = compare;
              }, /** @lends _.org.kevoree.modeling.api.trace.Event2Trace.prototype */ {
                convert: function (event) {
                  var result = new Kotlin.ArrayList(0);
                  var tmp$0 = event.getType();
                  if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                    var tmp$1, tmp$2, tmp$3;
                    result.add(new _.org.kevoree.modeling.api.trace.ModelRemoveTrace((tmp$1 = event.getSourcePath()) != null ? tmp$1 : Kotlin.throwNPE(), event.getElementAttributeName(), (tmp$3 = ((tmp$2 = event.getValue()) != null ? tmp$2 : Kotlin.throwNPE()).path()) != null ? tmp$3 : Kotlin.throwNPE()));
                  }
                   else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                    var tmp$4;
                    result.add(new _.org.kevoree.modeling.api.trace.ModelRemoveAllTrace((tmp$4 = event.getSourcePath()) != null ? tmp$4 : Kotlin.throwNPE(), event.getElementAttributeName()));
                  }
                   else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                    var tmp$5, tmp$6;
                    var casted = (tmp$5 = event.getValue()) != null ? tmp$5 : Kotlin.throwNPE();
                    var traces = this.compare.inter(casted, casted);
                    result.add(new _.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$6 = event.getSourcePath()) != null ? tmp$6 : Kotlin.throwNPE(), event.getElementAttributeName(), casted.path(), casted.metaClassName()));
                    result.addAll(traces.traces);
                  }
                   else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                    var tmp$7;
                    var casted_0 = (tmp$7 = event.getValue()) != null ? tmp$7 : Kotlin.throwNPE();
                    {
                      var tmp$8 = (casted_0 != null ? casted_0 : Kotlin.throwNPE()).iterator();
                      while (tmp$8.hasNext()) {
                        var elem = tmp$8.next();
                        var elemCasted = elem != null ? elem : Kotlin.throwNPE();
                        var traces_0 = this.compare.inter(elemCasted, elemCasted);
                        var tmp$9;
                        result.add(new _.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$9 = event.getSourcePath()) != null ? tmp$9 : Kotlin.throwNPE(), event.getElementAttributeName(), elemCasted.path(), elemCasted.metaClassName()));
                        result.addAll(traces_0.traces);
                      }
                    }
                  }
                   else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                    if (Kotlin.equals(event.getElementAttributeType(), _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE)) {
                      var tmp$10;
                      result.add(new _.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$10 = event.getSourcePath()) != null ? tmp$10 : Kotlin.throwNPE(), event.getElementAttributeName(), null, _.org.kevoree.modeling.api.util.AttConverter.convFlatAtt(event.getValue()), null));
                    }
                     else {
                      var tmp$11, tmp$12;
                      result.add(new _.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$11 = event.getSourcePath()) != null ? tmp$11 : Kotlin.throwNPE(), event.getElementAttributeName(), (tmp$12 = event.getValue()) != null ? tmp$12.path() : null, null, null));
                    }
                  }
                   else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  }
                   else {
                    throw new Error("Can't convert event : " + event);
                  }
                  return this.compare.createSequence().populate(result);
                },
                inverse: function (event) {
                  var result = new Kotlin.ArrayList(0);
                  var tmp$0 = event.getType();
                  if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                    var tmp$1, tmp$2, tmp$3, tmp$4;
                    result.add(new _.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$1 = event.getSourcePath()) != null ? tmp$1 : Kotlin.throwNPE(), event.getElementAttributeName(), (tmp$3 = ((tmp$2 = event.getValue()) != null ? tmp$2 : Kotlin.throwNPE()).path()) != null ? tmp$3 : Kotlin.throwNPE(), ((tmp$4 = event.getValue()) != null ? tmp$4 : Kotlin.throwNPE()).metaClassName()));
                  }
                   else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                    var tmp$5;
                    var casted = (tmp$5 = event.getValue()) != null ? tmp$5 : Kotlin.throwNPE();
                    {
                      var tmp$6 = (casted != null ? casted : Kotlin.throwNPE()).iterator();
                      while (tmp$6.hasNext()) {
                        var elem = tmp$6.next();
                        var elemCasted = elem != null ? elem : Kotlin.throwNPE();
                        var traces = this.compare.inter(elemCasted, elemCasted);
                        var tmp$7;
                        result.add(new _.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$7 = event.getSourcePath()) != null ? tmp$7 : Kotlin.throwNPE(), event.getElementAttributeName(), elemCasted.path(), elemCasted.metaClassName()));
                        result.addAll(traces.traces);
                      }
                    }
                  }
                   else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                    var tmp$8, tmp$9, tmp$10;
                    var casted_0 = (tmp$8 = event.getValue()) != null ? tmp$8 : Kotlin.throwNPE();
                    var traces_0 = this.compare.inter(casted_0, casted_0);
                    result.add(new _.org.kevoree.modeling.api.trace.ModelRemoveTrace((tmp$9 = event.getSourcePath()) != null ? tmp$9 : Kotlin.throwNPE(), event.getElementAttributeName(), (tmp$10 = casted_0.path()) != null ? tmp$10 : Kotlin.throwNPE()));
                    result.addAll(traces_0.traces);
                  }
                   else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                    var tmp$11;
                    var casted_1 = (tmp$11 = event.getValue()) != null ? tmp$11 : Kotlin.throwNPE();
                    {
                      var tmp$12 = (casted_1 != null ? casted_1 : Kotlin.throwNPE()).iterator();
                      while (tmp$12.hasNext()) {
                        var elem_0 = tmp$12.next();
                        var elemCasted_0 = elem_0 != null ? elem_0 : Kotlin.throwNPE();
                        var traces_1 = this.compare.inter(elemCasted_0, elemCasted_0);
                        var tmp$13, tmp$14;
                        result.add(new _.org.kevoree.modeling.api.trace.ModelRemoveTrace((tmp$13 = event.getSourcePath()) != null ? tmp$13 : Kotlin.throwNPE(), event.getElementAttributeName(), (tmp$14 = elemCasted_0.path()) != null ? tmp$14 : Kotlin.throwNPE()));
                        result.addAll(traces_1.traces);
                      }
                    }
                  }
                   else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                    if (Kotlin.equals(event.getElementAttributeType(), _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE)) {
                      var tmp$15;
                      result.add(new _.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$15 = event.getSourcePath()) != null ? tmp$15 : Kotlin.throwNPE(), event.getElementAttributeName(), null, _.org.kevoree.modeling.api.util.AttConverter.convFlatAtt(event.getPreviousValue()), null));
                    }
                     else {
                      var tmp$16, tmp$17;
                      result.add(new _.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$16 = event.getSourcePath()) != null ? tmp$16 : Kotlin.throwNPE(), event.getElementAttributeName(), (tmp$17 = event.getPreviousValue()) != null ? tmp$17.path() : null, null, null));
                    }
                  }
                   else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  }
                   else {
                    throw new Error("Can't convert event : " + event);
                  }
                  return this.compare.createSequence().populate(result);
                }
              }),
              TraceSequence: _c.TraceSequence
            }),
            json: Kotlin.definePackage(function () {
              this.Type = Kotlin.createObject(null, function () {
                this.VALUE = 0;
                this.LEFT_BRACE = 1;
                this.RIGHT_BRACE = 2;
                this.LEFT_BRACKET = 3;
                this.RIGHT_BRACKET = 4;
                this.COMMA = 5;
                this.COLON = 6;
                this.EOF = 42;
              });
            }, /** @lends _.org.kevoree.modeling.api.json */ {
              JSONModelLoader: _c.JSONModelLoader,
              ResolveCommand: Kotlin.createClass(null, function (roots, ref, currentRootElem, refName) {
                this.roots = roots;
                this.ref = ref;
                this.currentRootElem = currentRootElem;
                this.refName = refName;
              }, /** @lends _.org.kevoree.modeling.api.json.ResolveCommand.prototype */ {
                run: function () {
                  var referencedElement = null;
                  var i = 0;
                  while (referencedElement == null && i < this.roots.size()) {
                    referencedElement = this.roots.get(i++).findByPath(this.ref);
                  }
                  if (referencedElement != null) {
                    this.currentRootElem.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, this.refName, referencedElement, false, false);
                  }
                   else {
                    throw new Error('Unresolved ' + this.ref);
                  }
                }
              }),
              Token: Kotlin.createClass(null, function (tokenType, value) {
                this.tokenType = tokenType;
                this.value = value;
              }, /** @lends _.org.kevoree.modeling.api.json.Token.prototype */ {
                toString: function () {
                  var tmp$0;
                  if (this.value != null) {
                    tmp$0 = ' (' + this.value + ')';
                  }
                   else {
                    tmp$0 = '';
                  }
                  var v = tmp$0;
                  var result = Kotlin.toString(this.tokenType) + v;
                  return result;
                }
              }),
              Lexer: Kotlin.createClass(null, function (inputStream) {
                this.inputStream = inputStream;
                this.bytes = this.inputStream.readBytes();
                this.EOF = new _.org.kevoree.modeling.api.json.Token(_.org.kevoree.modeling.api.json.Type.EOF, null);
                this.index = 0;
                this.BOOLEAN_LETTERS = null;
                this.DIGIT = null;
              }, /** @lends _.org.kevoree.modeling.api.json.Lexer.prototype */ {
                isSpace: function (c) {
                  return c === ' ' || c === '\r' || c === '\n' || c === '\t';
                },
                nextChar: function () {
                  var tmp$0, tmp$1;
                  return _.org.kevoree.modeling.api.util.ByteConverter.toChar(this.bytes[tmp$0 = this.index, tmp$1 = tmp$0, this.index = tmp$0 + 1, tmp$1]);
                },
                peekChar: function () {
                  return _.org.kevoree.modeling.api.util.ByteConverter.toChar(this.bytes[this.index]);
                },
                isDone: function () {
                  return this.index >= this.bytes.length;
                },
                isBooleanLetter: function (c) {
                  if (this.BOOLEAN_LETTERS == null) {
                    this.BOOLEAN_LETTERS = new Kotlin.PrimitiveHashSet();
                    var tmp$0, tmp$1, tmp$2, tmp$3, tmp$4, tmp$5, tmp$6, tmp$7;
                    ((tmp$0 = this.BOOLEAN_LETTERS) != null ? tmp$0 : Kotlin.throwNPE()).add('f');
                    ((tmp$1 = this.BOOLEAN_LETTERS) != null ? tmp$1 : Kotlin.throwNPE()).add('a');
                    ((tmp$2 = this.BOOLEAN_LETTERS) != null ? tmp$2 : Kotlin.throwNPE()).add('l');
                    ((tmp$3 = this.BOOLEAN_LETTERS) != null ? tmp$3 : Kotlin.throwNPE()).add('s');
                    ((tmp$4 = this.BOOLEAN_LETTERS) != null ? tmp$4 : Kotlin.throwNPE()).add('e');
                    ((tmp$5 = this.BOOLEAN_LETTERS) != null ? tmp$5 : Kotlin.throwNPE()).add('t');
                    ((tmp$6 = this.BOOLEAN_LETTERS) != null ? tmp$6 : Kotlin.throwNPE()).add('r');
                    ((tmp$7 = this.BOOLEAN_LETTERS) != null ? tmp$7 : Kotlin.throwNPE()).add('u');
                  }
                  var tmp$8;
                  return ((tmp$8 = this.BOOLEAN_LETTERS) != null ? tmp$8 : Kotlin.throwNPE()).contains(c);
                },
                isDigit: function (c) {
                  if (this.DIGIT == null) {
                    this.DIGIT = new Kotlin.PrimitiveHashSet();
                    var tmp$0, tmp$1, tmp$2, tmp$3, tmp$4, tmp$5, tmp$6, tmp$7, tmp$8, tmp$9;
                    ((tmp$0 = this.DIGIT) != null ? tmp$0 : Kotlin.throwNPE()).add('0');
                    ((tmp$1 = this.DIGIT) != null ? tmp$1 : Kotlin.throwNPE()).add('1');
                    ((tmp$2 = this.DIGIT) != null ? tmp$2 : Kotlin.throwNPE()).add('2');
                    ((tmp$3 = this.DIGIT) != null ? tmp$3 : Kotlin.throwNPE()).add('3');
                    ((tmp$4 = this.DIGIT) != null ? tmp$4 : Kotlin.throwNPE()).add('4');
                    ((tmp$5 = this.DIGIT) != null ? tmp$5 : Kotlin.throwNPE()).add('5');
                    ((tmp$6 = this.DIGIT) != null ? tmp$6 : Kotlin.throwNPE()).add('6');
                    ((tmp$7 = this.DIGIT) != null ? tmp$7 : Kotlin.throwNPE()).add('7');
                    ((tmp$8 = this.DIGIT) != null ? tmp$8 : Kotlin.throwNPE()).add('8');
                    ((tmp$9 = this.DIGIT) != null ? tmp$9 : Kotlin.throwNPE()).add('9');
                  }
                  var tmp$10;
                  return ((tmp$10 = this.DIGIT) != null ? tmp$10 : Kotlin.throwNPE()).contains(c);
                },
                isValueLetter: function (c) {
                  return c === '-' || c === '+' || c === '.' || this.isDigit(c) || this.isBooleanLetter(c);
                },
                nextToken: function () {
                  if (this.isDone()) {
                    return this.EOF;
                  }
                  var tokenType = _.org.kevoree.modeling.api.json.Type.EOF;
                  var c = this.nextChar();
                  var currentValue = new _.java.lang.StringBuilder();
                  var jsonValue = null;
                  while (!this.isDone() && this.isSpace(c)) {
                    c = this.nextChar();
                  }
                  if ('"' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.VALUE;
                    if (!this.isDone()) {
                      c = this.nextChar();
                      while (this.index < this.bytes.length && c !== '"') {
                        currentValue.append_0(c);
                        if (c === '\\' && this.index < this.bytes.length) {
                          c = this.nextChar();
                          currentValue.append_0(c);
                        }
                        c = this.nextChar();
                      }
                      jsonValue = currentValue.toString();
                    }
                     else {
                      throw new Kotlin.RuntimeException('Unterminated string');
                    }
                  }
                   else if ('{' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.LEFT_BRACE;
                  }
                   else if ('}' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.RIGHT_BRACE;
                  }
                   else if ('[' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.LEFT_BRACKET;
                  }
                   else if (']' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.RIGHT_BRACKET;
                  }
                   else if (':' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.COLON;
                  }
                   else if (',' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.COMMA;
                  }
                   else if (!this.isDone()) {
                    while (this.isValueLetter(c)) {
                      currentValue.append_0(c);
                      if (!this.isValueLetter(this.peekChar())) {
                        break;
                      }
                       else {
                        c = this.nextChar();
                      }
                    }
                    var v = currentValue.toString();
                    if (Kotlin.equals('true', v.toLowerCase())) {
                      jsonValue = true;
                    }
                     else if (Kotlin.equals('false', v.toLowerCase())) {
                      jsonValue = false;
                    }
                     else {
                      jsonValue = v.toLowerCase();
                    }
                    tokenType = _.org.kevoree.modeling.api.json.Type.VALUE;
                  }
                   else {
                    tokenType = _.org.kevoree.modeling.api.json.Type.EOF;
                  }
                  return new _.org.kevoree.modeling.api.json.Token(tokenType, jsonValue);
                }
              }),
              ModelReferenceVisitor: Kotlin.createClass(_c.ModelVisitor, function $fun(out) {
                this.out = out;
                $fun.baseInitializer.call(this);
                this.isFirst = true;
              }, /** @lends _.org.kevoree.modeling.api.json.ModelReferenceVisitor.prototype */ {
                beginVisitRef: function (refName, refType) {
                  this.out.print(',"' + refName + '":[');
                  this.isFirst = true;
                },
                endVisitRef: function (refName) {
                  this.out.print(']');
                },
                visit: function (elem, refNameInParent, parent) {
                  if (!this.isFirst) {
                    this.out.print(',');
                  }
                   else {
                    this.isFirst = false;
                  }
                  this.out.print('"' + elem.path() + '"');
                }
              }),
              JSONModelSerializer: _c.JSONModelSerializer
            }),
            events: Kotlin.definePackage(null, /** @lends _.org.kevoree.modeling.api.events */ {
              ModelEvent: Kotlin.createClass(null, function (internal_sourcePath, internal_etype, internal_elementAttributeType, internal_elementAttributeName, internal_value, internal_previous_value) {
                this.internal_sourcePath = internal_sourcePath;
                this.internal_etype = internal_etype;
                this.internal_elementAttributeType = internal_elementAttributeType;
                this.internal_elementAttributeName = internal_elementAttributeName;
                this.internal_value = internal_value;
                this.internal_previous_value = internal_previous_value;
              }, /** @lends _.org.kevoree.modeling.api.events.ModelEvent.prototype */ {
                getSourcePath: function () {
                  return this.internal_sourcePath;
                },
                getType: function () {
                  return this.internal_etype;
                },
                getElementAttributeType: function () {
                  return this.internal_elementAttributeType;
                },
                getElementAttributeName: function () {
                  return this.internal_elementAttributeName;
                },
                getValue: function () {
                  return this.internal_value;
                },
                getPreviousValue: function () {
                  return this.internal_previous_value;
                },
                toString: function () {
                  return 'ModelEvent[src:' + this.getSourcePath() + ', type:' + this.getType() + ', elementAttributeType:' + this.getElementAttributeType() + ', elementAttributeName:' + this.getElementAttributeName() + ', value:' + this.getValue() + ']';
                }
              })
            })
          })
        }),
        factory: Kotlin.definePackage(function () {
          this.Package = Kotlin.createObject(null, function () {
            this.ORG_KEVOREE = 0;
          }, {
            getPackageForName: function (metaClassName) {
              if (metaClassName.startsWith('org.kevoree')) {
                return 0;
              }
              return -1;
            }
          });
        }, /** @lends _.org.kevoree.factory */ {
          MainFactory: Kotlin.createClass(_c.KMFFactory, function () {
            this.factories = Kotlin.arrayFromFun(1, function (i) {
              return null;
            });
            this.factories[_.org.kevoree.factory.Package.ORG_KEVOREE] = new _.org.kevoree.impl.DefaultKevoreeFactory();
          }, /** @lends _.org.kevoree.factory.MainFactory.prototype */ {
            getFactoryForPackage: function (pack) {
              return this.factories[pack];
            },
            getKevoreeFactory: function () {
              var tmp$0;
              return (tmp$0 = this.factories[_.org.kevoree.factory.Package.ORG_KEVOREE]) != null ? tmp$0 : Kotlin.throwNPE();
            },
            setKevoreeFactory: function (fct) {
              this.factories[_.org.kevoree.factory.Package.ORG_KEVOREE] = fct;
            },
            create: function (metaClassName) {
              var pack = _.org.kevoree.factory.Package.getPackageForName(metaClassName);
              if (pack !== -1) {
                var tmp$0;
                return (tmp$0 = this.getFactoryForPackage(pack)) != null ? tmp$0.create(metaClassName) : null;
              }
               else {
                var tmp$1, tmp$2, tmp$3, tmp$4;
                {
                  tmp$1 = Kotlin.arrayIndices(this.factories), tmp$2 = tmp$1.start, tmp$3 = tmp$1.end, tmp$4 = tmp$1.increment;
                  for (var i = tmp$2; i <= tmp$3; i += tmp$4) {
                    var tmp$5;
                    var obj = ((tmp$5 = this.factories[i]) != null ? tmp$5 : Kotlin.throwNPE()).create(metaClassName);
                    if (obj != null) {
                      return obj;
                    }
                  }
                }
                return null;
              }
            }
          })
        }),
        serializer: Kotlin.definePackage(null, /** @lends _.org.kevoree.serializer */ {
          XMIModelSerializer: Kotlin.createClass(_c.XMIModelSerializer, function $fun() {
            $fun.baseInitializer.call(this);
          }),
          JSONModelSerializer: Kotlin.createClass(_c.JSONModelSerializer, function $fun() {
            $fun.baseInitializer.call(this);
          })
        }),
        cloner: Kotlin.definePackage(null, /** @lends _.org.kevoree.cloner */ {
          DefaultModelCloner: Kotlin.createClass(_c.ModelCloner, function () {
            this.mainFactory = new _.org.kevoree.factory.MainFactory();
          }, /** @lends _.org.kevoree.cloner.DefaultModelCloner.prototype */ {
            createContext: function () {
              return new Kotlin.ComplexHashMap(0);
            }
          })
        }),
        compare: Kotlin.definePackage(null, /** @lends _.org.kevoree.compare */ {
          DefaultModelCompare: Kotlin.createClass(_c.ModelCompare, null, /** @lends _.org.kevoree.compare.DefaultModelCompare.prototype */ {
            createSequence: function () {
              return new _.org.kevoree.trace.DefaultTraceSequence();
            }
          })
        }),
        impl: Kotlin.definePackage(null, /** @lends _.org.kevoree.impl */ {
          TypeLibraryImpl: Kotlin.createClass([_c.TypeLibrary, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$name = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this._subTypes = new Kotlin.PrimitiveHashMap(0);
          }, /** @lends _.org.kevoree.impl.TypeLibraryImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              var tmp$1;
              (tmp$1 = this._subTypes) != null ? tmp$1.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name;
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path(), null));
                }
              }
            },
            subTypes: {
              get: function () {
                return _.kotlin.toList(this._subTypes.values());
              },
              set: function (subTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (subTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_subTypes(subTypesP, true, true);
              }
            },
            internal_subTypes: function (subTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._subTypes.values(), subTypesP)) {
                var kmf_previousVal = this._subTypes;
                this._subTypes.clear();
                {
                  var tmp$0 = subTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._subTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_subTypes, subTypesP, kmf_previousVal));
                }
              }
            },
            doAddSubTypes: function (subTypesP) {
              var _key_ = (subTypesP != null ? subTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._subTypes.containsKey(_key_)) {
                this._subTypes.put(_key_, subTypesP);
              }
            },
            addSubTypes: function (subTypesP) {
              this.internal_addSubTypes(subTypesP, true, true);
            },
            addAllSubTypes: function (subTypesP) {
              this.internal_addAllSubTypes(subTypesP, true, true);
            },
            internal_addSubTypes: function (subTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSubTypes(subTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_subTypes, subTypesP, null));
              }
            },
            internal_addAllSubTypes: function (subTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = subTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSubTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = subTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSubTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_subTypes, subTypesP, null));
              }
            },
            removeSubTypes: function (subTypesP) {
              this.internal_removeSubTypes(subTypesP, true, true);
            },
            removeAllSubTypes: function () {
              this.internal_removeAllSubTypes(true, true);
            },
            internal_removeSubTypes: function (subTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._subTypes.size() !== 0 && this._subTypes.containsKey((subTypesP != null ? subTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._subTypes.remove((subTypesP != null ? subTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_subTypes, subTypesP, null));
                }
              }
            },
            internal_removeAllSubTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.subTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._subTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_subTypes, temp_els, null));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_subTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addSubTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllSubTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeSubTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllSubTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._subTypes.size() !== 0 && this._subTypes.containsKey(value)) {
                    var obj = this._subTypes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._subTypes.remove(value);
                    this._subTypes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(this.name);
              }
              return this.key_cache;
            },
            findSubTypesByID: function (key) {
              return this._subTypes.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_subTypes) {
                return this.findSubTypesByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_subTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$0 = this._subTypes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._subTypes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_subTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_subTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_TypeLibrary;
            }
          }),
          ComponentInstanceImpl: Kotlin.createClass([_c.ComponentInstance, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$name = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$metaData = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$started = true;
            this._fragmentDictionary = new Kotlin.PrimitiveHashMap(0);
            this.removeAllFragmentDictionaryCurrentlyProcessing = false;
            this._provided = new Kotlin.PrimitiveHashMap(0);
            this.removeAllProvidedCurrentlyProcessing = false;
            this.$typeDefinition = null;
            this.$dictionary = null;
            this._required = new Kotlin.PrimitiveHashMap(0);
            this.removeAllRequiredCurrentlyProcessing = false;
            this.$namespace = null;
          }, /** @lends _.org.kevoree.impl.ComponentInstanceImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              this.typeDefinition = null;
              this.dictionary = null;
              var tmp$1, tmp$2, tmp$3;
              (tmp$1 = this._fragmentDictionary) != null ? tmp$1.clear() : null;
              (tmp$2 = this._provided) != null ? tmp$2.clear() : null;
              (tmp$3 = this._required) != null ? tmp$3.clear() : null;
              this.namespace = null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name;
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path(), null));
                }
              }
            },
            metaData: {
              get: function () {
                return this.$metaData;
              },
              set: function (iP) {
                this.internal_metaData(iP, true);
              }
            },
            internal_metaData: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.metaData)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$metaData;
                this.$metaData = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_metaData, this.metaData, kmf_previousVal));
                }
              }
            },
            started: {
              get: function () {
                return this.$started;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$started;
                this.$started = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started, kmf_previousVal));
                }
              }
            },
            fragmentDictionary: {
              get: function () {
                return _.kotlin.toList(this._fragmentDictionary.values());
              },
              set: function (fragmentDictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (fragmentDictionaryP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_fragmentDictionary(fragmentDictionaryP, true, true);
              }
            },
            internal_fragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._fragmentDictionary.values(), fragmentDictionaryP)) {
                var kmf_previousVal = this._fragmentDictionary;
                this._fragmentDictionary.clear();
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._fragmentDictionary.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, el), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, kmf_previousVal));
                }
              }
            },
            doAddFragmentDictionary: function (fragmentDictionaryP) {
              var _key_ = (fragmentDictionaryP != null ? fragmentDictionaryP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._fragmentDictionary.containsKey(_key_)) {
                this._fragmentDictionary.put(_key_, fragmentDictionaryP);
                (fragmentDictionaryP != null ? fragmentDictionaryP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
              }
            },
            addFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addFragmentDictionary(fragmentDictionaryP, true, true);
            },
            addAllFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addAllFragmentDictionary(fragmentDictionaryP, true, true);
            },
            internal_addFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddFragmentDictionary(fragmentDictionaryP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null));
              }
            },
            internal_addAllFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddFragmentDictionary(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = fragmentDictionaryP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddFragmentDictionary(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null));
              }
            },
            removeFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_removeFragmentDictionary(fragmentDictionaryP, true, true);
            },
            removeAllFragmentDictionary: function () {
              this.internal_removeAllFragmentDictionary(true, true);
            },
            internal_removeFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey((fragmentDictionaryP != null ? fragmentDictionaryP : Kotlin.throwNPE()).internalGetKey())) {
                this._fragmentDictionary.remove((fragmentDictionaryP != null ? fragmentDictionaryP : Kotlin.throwNPE()).internalGetKey());
                ((fragmentDictionaryP != null ? fragmentDictionaryP : Kotlin.throwNPE()) != null ? fragmentDictionaryP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllFragmentDictionaryCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null));
                }
              }
            },
            internal_removeAllFragmentDictionary: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllFragmentDictionaryCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.fragmentDictionary) != null ? tmp$0 : Kotlin.throwNPE();
              this._fragmentDictionary.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, temp_els, null));
                this.removeAllFragmentDictionaryCurrentlyProcessing = false;
              }
            },
            provided: {
              get: function () {
                return _.kotlin.toList(this._provided.values());
              },
              set: function (providedP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (providedP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_provided(providedP, true, true);
              }
            },
            internal_provided: function (providedP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._provided.values(), providedP)) {
                var kmf_previousVal = this._provided;
                this._provided.clear();
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._provided.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_provided, el), _.org.kevoree.util.Constants.Ref_provided);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP, kmf_previousVal));
                }
              }
            },
            doAddProvided: function (providedP) {
              var _key_ = (providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._provided.containsKey(_key_)) {
                this._provided.put(_key_, providedP);
                (providedP != null ? providedP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_provided, providedP), _.org.kevoree.util.Constants.Ref_provided);
              }
            },
            addProvided: function (providedP) {
              this.internal_addProvided(providedP, true, true);
            },
            addAllProvided: function (providedP) {
              this.internal_addAllProvided(providedP, true, true);
            },
            internal_addProvided: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddProvided(providedP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP, null));
              }
            },
            internal_addAllProvided: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddProvided(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = providedP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddProvided(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP, null));
              }
            },
            removeProvided: function (providedP) {
              this.internal_removeProvided(providedP, true, true);
            },
            removeAllProvided: function () {
              this.internal_removeAllProvided(true, true);
            },
            internal_removeProvided: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._provided.size() !== 0 && this._provided.containsKey((providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey())) {
                this._provided.remove((providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey());
                ((providedP != null ? providedP : Kotlin.throwNPE()) != null ? providedP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllProvidedCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP, null));
                }
              }
            },
            internal_removeAllProvided: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllProvidedCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.provided) != null ? tmp$0 : Kotlin.throwNPE();
              this._provided.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, temp_els, null));
                this.removeAllProvidedCurrentlyProcessing = false;
              }
            },
            typeDefinition: {
              get: function () {
                return this.$typeDefinition;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition, typeDefinitionP)) {
                var kmf_previousVal = this.$typeDefinition;
                this.$typeDefinition = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP, kmf_previousVal));
                }
              }
            },
            dictionary: {
              get: function () {
                return this.$dictionary;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary, dictionaryP)) {
                if (this.$dictionary != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionary) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                var kmf_previousVal = this.$dictionary;
                this.$dictionary = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP, kmf_previousVal));
                }
              }
            },
            required: {
              get: function () {
                return _.kotlin.toList(this._required.values());
              },
              set: function (requiredP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (requiredP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_required(requiredP, true, true);
              }
            },
            internal_required: function (requiredP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._required.values(), requiredP)) {
                var kmf_previousVal = this._required;
                this._required.clear();
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._required.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_required, el), _.org.kevoree.util.Constants.Ref_required);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP, kmf_previousVal));
                }
              }
            },
            doAddRequired: function (requiredP) {
              var _key_ = (requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._required.containsKey(_key_)) {
                this._required.put(_key_, requiredP);
                (requiredP != null ? requiredP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_required, requiredP), _.org.kevoree.util.Constants.Ref_required);
              }
            },
            addRequired: function (requiredP) {
              this.internal_addRequired(requiredP, true, true);
            },
            addAllRequired: function (requiredP) {
              this.internal_addAllRequired(requiredP, true, true);
            },
            internal_addRequired: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddRequired(requiredP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP, null));
              }
            },
            internal_addAllRequired: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddRequired(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = requiredP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddRequired(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP, null));
              }
            },
            removeRequired: function (requiredP) {
              this.internal_removeRequired(requiredP, true, true);
            },
            removeAllRequired: function () {
              this.internal_removeAllRequired(true, true);
            },
            internal_removeRequired: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._required.size() !== 0 && this._required.containsKey((requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey())) {
                this._required.remove((requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey());
                ((requiredP != null ? requiredP : Kotlin.throwNPE()) != null ? requiredP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllRequiredCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP, null));
                }
              }
            },
            internal_removeAllRequired: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllRequiredCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.required) != null ? tmp$0 : Kotlin.throwNPE();
              this._required.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, temp_els, null));
                this.removeAllRequiredCurrentlyProcessing = false;
              }
            },
            namespace: {
              get: function () {
                return this.$namespace;
              },
              set: function (namespaceP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_namespace(namespaceP, true, true);
              }
            },
            internal_namespace: function (namespaceP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$namespace, namespaceP)) {
                var kmf_previousVal = this.$namespace;
                this.$namespace = namespaceP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_namespace, namespaceP, kmf_previousVal));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_metaData) {
                this.internal_metaData(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_started) {
                this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_typeDefinition(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_dictionary(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllFragmentDictionary();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey(value)) {
                    var obj = this._fragmentDictionary.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._fragmentDictionary.remove(value);
                    this._fragmentDictionary.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_provided) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllProvided();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._provided.size() !== 0 && this._provided.containsKey(value)) {
                    var obj_0 = this._provided.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._provided.remove(value);
                    this._provided.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_required) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllRequired();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._required.size() !== 0 && this._required.containsKey(value)) {
                    var obj_1 = this._required.get(value);
                    var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_1 == null) {
                      throw new Error('Key newed to null ' + obj_1);
                    }
                    this._required.remove(value);
                    this._required.put(objNewKey_1, obj_1);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_namespace) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_namespace(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_namespace(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_namespace(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(this.name);
              }
              return this.key_cache;
            },
            findFragmentDictionaryByID: function (key) {
              return this._fragmentDictionary.get(key);
            },
            findProvidedByID: function (key) {
              return this._provided.get(key);
            },
            findRequiredByID: function (key) {
              return this._required.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                var objFound = this.typeDefinition;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                var objFound_0 = this.dictionary;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                return this.findFragmentDictionaryByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_provided) {
                return this.findProvidedByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_required) {
                return this.findRequiredByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_namespace) {
                var objFound_1 = this.namespace;
                if (objFound_1 != null && Kotlin.equals((objFound_1 != null ? objFound_1 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_1;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary);
                this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary, _.org.kevoree.util.Constants.org_kevoree_FragmentDictionary);
                {
                  var tmp$0 = this._fragmentDictionary.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._fragmentDictionary.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_provided, _.org.kevoree.util.Constants.org_kevoree_Port);
                {
                  var tmp$1 = this._provided.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._provided.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_provided);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_provided);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_required, _.org.kevoree.util.Constants.org_kevoree_Port);
                {
                  var tmp$2 = this._required.keySet().iterator();
                  while (tmp$2.hasNext()) {
                    var KMFLoopEntryKey_1 = tmp$2.next();
                    this.internal_visit(visitor, this._required.get(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_required);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_required);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_namespace, _.org.kevoree.util.Constants.org_kevoree_Namespace);
                this.internal_visit(visitor, this.namespace, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_namespace);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_namespace);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
              visitor.visit(this.metaData, _.org.kevoree.util.Constants.Att_metaData, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ComponentInstance;
            }
          }),
          RepositoryImpl: Kotlin.createClass([_c.Repository, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$url = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this._units = new Kotlin.PrimitiveHashMap(0);
          }, /** @lends _.org.kevoree.impl.RepositoryImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              var tmp$1;
              (tmp$1 = this._units) != null ? tmp$1.clear() : null;
            },
            url: {
              get: function () {
                return this.$url;
              },
              set: function (iP) {
                this.internal_url(iP, true);
              }
            },
            internal_url: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.url)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$url;
                this.$url = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_url, this.url, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_url, this.path(), null));
                }
              }
            },
            units: {
              get: function () {
                return _.kotlin.toList(this._units.values());
              },
              set: function (unitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (unitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_units(unitsP, true, true);
              }
            },
            internal_units: function (unitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._units.values(), unitsP)) {
                var kmf_previousVal = this._units;
                this._units.clear();
                {
                  var tmp$0 = unitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._units.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_units, unitsP, kmf_previousVal));
                }
              }
            },
            doAddUnits: function (unitsP) {
              var _key_ = (unitsP != null ? unitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._units.containsKey(_key_)) {
                this._units.put(_key_, unitsP);
              }
            },
            addUnits: function (unitsP) {
              this.internal_addUnits(unitsP, true, true);
            },
            addAllUnits: function (unitsP) {
              this.internal_addAllUnits(unitsP, true, true);
            },
            internal_addUnits: function (unitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddUnits(unitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_units, unitsP, null));
              }
            },
            internal_addAllUnits: function (unitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = unitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = unitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_units, unitsP, null));
              }
            },
            removeUnits: function (unitsP) {
              this.internal_removeUnits(unitsP, true, true);
            },
            removeAllUnits: function () {
              this.internal_removeAllUnits(true, true);
            },
            internal_removeUnits: function (unitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._units.size() !== 0 && this._units.containsKey((unitsP != null ? unitsP : Kotlin.throwNPE()).internalGetKey())) {
                this._units.remove((unitsP != null ? unitsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_units, unitsP, null));
                }
              }
            },
            internal_removeAllUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.units) != null ? tmp$0 : Kotlin.throwNPE();
              this._units.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_units, temp_els, null));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_url) {
                this.internal_url(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_units) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._units.size() !== 0 && this._units.containsKey(value)) {
                    var obj = this._units.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._units.remove(value);
                    this._units.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(this.url);
              }
              return this.key_cache;
            },
            findUnitsByID: function (key) {
              return this._units.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_units) {
                return this.findUnitsByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_units, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$0 = this._units.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._units.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_units);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_units);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.url, _.org.kevoree.util.Constants.Att_url, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Repository;
            }
          }),
          PortImpl: Kotlin.createClass([_c.Port, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$generated_KMF_ID = '' + Math.random() + (new Date()).getTime();
            this._bindings = new Kotlin.PrimitiveHashMap(0);
            this.$portTypeRef = null;
          }, /** @lends _.org.kevoree.impl.PortImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              var tmp$1;
              (tmp$1 = this._bindings) != null ? tmp$1.clear() : null;
              this.portTypeRef = null;
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$generated_KMF_ID;
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path(), null));
                }
              }
            },
            bindings: {
              get: function () {
                return _.kotlin.toList(this._bindings.values());
              },
              set: function (bindingsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (bindingsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_bindings(bindingsP, true, true);
              }
            },
            internal_bindings: function (bindingsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._bindings.values(), bindingsP)) {
                var kmf_previousVal = this._bindings;
                this.internal_removeAllBindings(true, false);
                {
                  var tmp$0 = bindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._bindings.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_port, this, false, fireEvents);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP, kmf_previousVal));
                }
              }
            },
            doAddBindings: function (bindingsP) {
              var _key_ = (bindingsP != null ? bindingsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._bindings.containsKey(_key_)) {
                this._bindings.put(_key_, bindingsP);
              }
            },
            addBindings: function (bindingsP) {
              this.internal_addBindings(bindingsP, true, true);
            },
            addAllBindings: function (bindingsP) {
              this.internal_addAllBindings(bindingsP, true, true);
            },
            internal_addBindings: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddBindings(bindingsP);
              if (setOpposite) {
                (bindingsP != null ? bindingsP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_port, this, false, fireEvents);
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP, null));
              }
            },
            internal_addAllBindings: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = bindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddBindings(el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_port, this, false, fireEvents);
                  }
                }
              }
               else {
                {
                  var tmp$1 = bindingsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddBindings(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP, null));
              }
            },
            removeBindings: function (bindingsP) {
              this.internal_removeBindings(bindingsP, true, true);
            },
            removeAllBindings: function () {
              this.internal_removeAllBindings(true, true);
            },
            internal_removeBindings: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._bindings.size() !== 0 && this._bindings.containsKey((bindingsP != null ? bindingsP : Kotlin.throwNPE()).internalGetKey())) {
                this._bindings.remove((bindingsP != null ? bindingsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP, null));
                }
                if (setOpposite) {
                  (bindingsP != null ? bindingsP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_port, null, false, fireEvents);
                }
              }
            },
            internal_removeAllBindings: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.bindings) != null ? tmp$0 : Kotlin.throwNPE();
              if (setOpposite) {
                {
                  var tmp$1 = (temp_els != null ? temp_els : Kotlin.throwNPE()).iterator();
                  while (tmp$1.hasNext()) {
                    var el = tmp$1.next();
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_port, null, false, fireEvents);
                  }
                }
              }
              this._bindings.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, temp_els, null));
              }
            },
            portTypeRef: {
              get: function () {
                return this.$portTypeRef;
              },
              set: function (portTypeRefP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_portTypeRef(portTypeRefP, true, true);
              }
            },
            internal_portTypeRef: function (portTypeRefP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$portTypeRef, portTypeRefP)) {
                var kmf_previousVal = this.$portTypeRef;
                this.$portTypeRef = portTypeRefP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypeRef, portTypeRefP, kmf_previousVal));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_bindings) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.internal_removeAllBindings(setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._bindings.size() !== 0 && this._bindings.containsKey(value)) {
                    var obj = this._bindings.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._bindings.remove(value);
                    this._bindings.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_portTypeRef) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_portTypeRef(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_portTypeRef(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_portTypeRef(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = this.generated_KMF_ID;
              }
              return this.key_cache;
            },
            findBindingsByID: function (key) {
              return this._bindings.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_bindings) {
                return this.findBindingsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_portTypeRef) {
                var objFound = this.portTypeRef;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_bindings, _.org.kevoree.util.Constants.org_kevoree_MBinding);
                {
                  var tmp$0 = this._bindings.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._bindings.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_bindings);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_bindings);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_portTypeRef, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef);
                this.internal_visit(visitor, this.portTypeRef, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_portTypeRef);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_portTypeRef);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Port;
            }
          }),
          TypedElementImpl: Kotlin.createClass([_c.TypedElement, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$name = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this._genericTypes = new Kotlin.PrimitiveHashMap(0);
          }, /** @lends _.org.kevoree.impl.TypedElementImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              var tmp$1;
              (tmp$1 = this._genericTypes) != null ? tmp$1.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name;
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path(), null));
                }
              }
            },
            genericTypes: {
              get: function () {
                return _.kotlin.toList(this._genericTypes.values());
              },
              set: function (genericTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (genericTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_genericTypes(genericTypesP, true, true);
              }
            },
            internal_genericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._genericTypes.values(), genericTypesP)) {
                var kmf_previousVal = this._genericTypes;
                this._genericTypes.clear();
                {
                  var tmp$0 = genericTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._genericTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP, kmf_previousVal));
                }
              }
            },
            doAddGenericTypes: function (genericTypesP) {
              var _key_ = (genericTypesP != null ? genericTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._genericTypes.containsKey(_key_)) {
                this._genericTypes.put(_key_, genericTypesP);
              }
            },
            addGenericTypes: function (genericTypesP) {
              this.internal_addGenericTypes(genericTypesP, true, true);
            },
            addAllGenericTypes: function (genericTypesP) {
              this.internal_addAllGenericTypes(genericTypesP, true, true);
            },
            internal_addGenericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddGenericTypes(genericTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP, null));
              }
            },
            internal_addAllGenericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = genericTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddGenericTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = genericTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddGenericTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP, null));
              }
            },
            removeGenericTypes: function (genericTypesP) {
              this.internal_removeGenericTypes(genericTypesP, true, true);
            },
            removeAllGenericTypes: function () {
              this.internal_removeAllGenericTypes(true, true);
            },
            internal_removeGenericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._genericTypes.size() !== 0 && this._genericTypes.containsKey((genericTypesP != null ? genericTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._genericTypes.remove((genericTypesP != null ? genericTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP, null));
                }
              }
            },
            internal_removeAllGenericTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.genericTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._genericTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, temp_els, null));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_genericTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllGenericTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._genericTypes.size() !== 0 && this._genericTypes.containsKey(value)) {
                    var obj = this._genericTypes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._genericTypes.remove(value);
                    this._genericTypes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(this.name);
              }
              return this.key_cache;
            },
            findGenericTypesByID: function (key) {
              return this._genericTypes.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_genericTypes) {
                return this.findGenericTypesByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_genericTypes, _.org.kevoree.util.Constants.org_kevoree_TypedElement);
                {
                  var tmp$0 = this._genericTypes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._genericTypes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_genericTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_genericTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_TypedElement;
            }
          }),
          NetworkInfoImpl: Kotlin.createClass([_c.NetworkInfo, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$name = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this._values = new Kotlin.PrimitiveHashMap(0);
            this.removeAllValuesCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.NetworkInfoImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              var tmp$1;
              (tmp$1 = this._values) != null ? tmp$1.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name;
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path(), null));
                }
              }
            },
            values: {
              get: function () {
                return _.kotlin.toList(this._values.values());
              },
              set: function (valuesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (valuesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_values(valuesP, true, true);
              }
            },
            internal_values: function (valuesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._values.values(), valuesP)) {
                var kmf_previousVal = this._values;
                this._values.clear();
                {
                  var tmp$0 = valuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._values.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_values, el), _.org.kevoree.util.Constants.Ref_values);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, kmf_previousVal));
                }
              }
            },
            doAddValues: function (valuesP) {
              var _key_ = (valuesP != null ? valuesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._values.containsKey(_key_)) {
                this._values.put(_key_, valuesP);
                (valuesP != null ? valuesP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_values, valuesP), _.org.kevoree.util.Constants.Ref_values);
              }
            },
            addValues: function (valuesP) {
              this.internal_addValues(valuesP, true, true);
            },
            addAllValues: function (valuesP) {
              this.internal_addAllValues(valuesP, true, true);
            },
            internal_addValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddValues(valuesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, null));
              }
            },
            internal_addAllValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = valuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddValues(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = valuesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddValues(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, null));
              }
            },
            removeValues: function (valuesP) {
              this.internal_removeValues(valuesP, true, true);
            },
            removeAllValues: function () {
              this.internal_removeAllValues(true, true);
            },
            internal_removeValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._values.size() !== 0 && this._values.containsKey((valuesP != null ? valuesP : Kotlin.throwNPE()).internalGetKey())) {
                this._values.remove((valuesP != null ? valuesP : Kotlin.throwNPE()).internalGetKey());
                ((valuesP != null ? valuesP : Kotlin.throwNPE()) != null ? valuesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllValuesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, null));
                }
              }
            },
            internal_removeAllValues: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllValuesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.values) != null ? tmp$0 : Kotlin.throwNPE();
              this._values.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, temp_els, null));
                this.removeAllValuesCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_values) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllValues();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._values.size() !== 0 && this._values.containsKey(value)) {
                    var obj = this._values.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._values.remove(value);
                    this._values.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(this.name);
              }
              return this.key_cache;
            },
            findValuesByID: function (key) {
              return this._values.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_values) {
                return this.findValuesByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_values, _.org.kevoree.util.Constants.org_kevoree_NetworkProperty);
                {
                  var tmp$0 = this._values.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._values.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_values);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_values);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_NetworkInfo;
            }
          }),
          ContainerNodeImpl: Kotlin.createClass([_c.ContainerNode, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$name = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$metaData = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$started = true;
            this.$host = null;
            this._fragmentDictionary = new Kotlin.PrimitiveHashMap(0);
            this.removeAllFragmentDictionaryCurrentlyProcessing = false;
            this._hosts = new Kotlin.PrimitiveHashMap(0);
            this.$typeDefinition = null;
            this._components = new Kotlin.PrimitiveHashMap(0);
            this.removeAllComponentsCurrentlyProcessing = false;
            this.$dictionary = null;
            this._networkInformation = new Kotlin.PrimitiveHashMap(0);
            this.removeAllNetworkInformationCurrentlyProcessing = false;
            this._groups = new Kotlin.PrimitiveHashMap(0);
          }, /** @lends _.org.kevoree.impl.ContainerNodeImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              this.typeDefinition = null;
              this.dictionary = null;
              var tmp$1, tmp$2, tmp$3, tmp$4, tmp$5;
              (tmp$1 = this._fragmentDictionary) != null ? tmp$1.clear() : null;
              (tmp$2 = this._components) != null ? tmp$2.clear() : null;
              (tmp$3 = this._hosts) != null ? tmp$3.clear() : null;
              this.host = null;
              (tmp$4 = this._groups) != null ? tmp$4.clear() : null;
              (tmp$5 = this._networkInformation) != null ? tmp$5.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name;
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path(), null));
                }
              }
            },
            metaData: {
              get: function () {
                return this.$metaData;
              },
              set: function (iP) {
                this.internal_metaData(iP, true);
              }
            },
            internal_metaData: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.metaData)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$metaData;
                this.$metaData = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_metaData, this.metaData, kmf_previousVal));
                }
              }
            },
            started: {
              get: function () {
                return this.$started;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$started;
                this.$started = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started, kmf_previousVal));
                }
              }
            },
            host: {
              get: function () {
                return this.$host;
              },
              set: function (hostP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_host(hostP, true, true);
              }
            },
            internal_host: function (hostP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$host, hostP)) {
                if (setOpposite) {
                  if (this.$host != null) {
                    var tmp$0;
                    ((tmp$0 = this.$host) != null ? tmp$0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_hosts, this, false, fireEvents);
                  }
                  if (hostP != null) {
                    hostP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.util.Constants.Ref_hosts, this, false, fireEvents);
                  }
                }
                var kmf_previousVal = this.$host;
                this.$host = hostP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_host, hostP, kmf_previousVal));
                }
              }
            },
            fragmentDictionary: {
              get: function () {
                return _.kotlin.toList(this._fragmentDictionary.values());
              },
              set: function (fragmentDictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (fragmentDictionaryP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_fragmentDictionary(fragmentDictionaryP, true, true);
              }
            },
            internal_fragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._fragmentDictionary.values(), fragmentDictionaryP)) {
                var kmf_previousVal = this._fragmentDictionary;
                this._fragmentDictionary.clear();
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._fragmentDictionary.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, el), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, kmf_previousVal));
                }
              }
            },
            doAddFragmentDictionary: function (fragmentDictionaryP) {
              var _key_ = (fragmentDictionaryP != null ? fragmentDictionaryP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._fragmentDictionary.containsKey(_key_)) {
                this._fragmentDictionary.put(_key_, fragmentDictionaryP);
                (fragmentDictionaryP != null ? fragmentDictionaryP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
              }
            },
            addFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addFragmentDictionary(fragmentDictionaryP, true, true);
            },
            addAllFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addAllFragmentDictionary(fragmentDictionaryP, true, true);
            },
            internal_addFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddFragmentDictionary(fragmentDictionaryP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null));
              }
            },
            internal_addAllFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddFragmentDictionary(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = fragmentDictionaryP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddFragmentDictionary(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null));
              }
            },
            removeFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_removeFragmentDictionary(fragmentDictionaryP, true, true);
            },
            removeAllFragmentDictionary: function () {
              this.internal_removeAllFragmentDictionary(true, true);
            },
            internal_removeFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey((fragmentDictionaryP != null ? fragmentDictionaryP : Kotlin.throwNPE()).internalGetKey())) {
                this._fragmentDictionary.remove((fragmentDictionaryP != null ? fragmentDictionaryP : Kotlin.throwNPE()).internalGetKey());
                ((fragmentDictionaryP != null ? fragmentDictionaryP : Kotlin.throwNPE()) != null ? fragmentDictionaryP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllFragmentDictionaryCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null));
                }
              }
            },
            internal_removeAllFragmentDictionary: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllFragmentDictionaryCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.fragmentDictionary) != null ? tmp$0 : Kotlin.throwNPE();
              this._fragmentDictionary.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, temp_els, null));
                this.removeAllFragmentDictionaryCurrentlyProcessing = false;
              }
            },
            hosts: {
              get: function () {
                return _.kotlin.toList(this._hosts.values());
              },
              set: function (hostsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (hostsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_hosts(hostsP, true, true);
              }
            },
            internal_hosts: function (hostsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._hosts.values(), hostsP)) {
                var kmf_previousVal = this._hosts;
                this.internal_removeAllHosts(true, false);
                {
                  var tmp$0 = hostsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._hosts.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_host, this, false, fireEvents);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, hostsP, kmf_previousVal));
                }
              }
            },
            doAddHosts: function (hostsP) {
              var _key_ = (hostsP != null ? hostsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._hosts.containsKey(_key_)) {
                this._hosts.put(_key_, hostsP);
              }
            },
            addHosts: function (hostsP) {
              this.internal_addHosts(hostsP, true, true);
            },
            addAllHosts: function (hostsP) {
              this.internal_addAllHosts(hostsP, true, true);
            },
            internal_addHosts: function (hostsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddHosts(hostsP);
              if (setOpposite) {
                (hostsP != null ? hostsP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_host, this, false, fireEvents);
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, hostsP, null));
              }
            },
            internal_addAllHosts: function (hostsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = hostsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddHosts(el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_host, this, false, fireEvents);
                  }
                }
              }
               else {
                {
                  var tmp$1 = hostsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddHosts(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, hostsP, null));
              }
            },
            removeHosts: function (hostsP) {
              this.internal_removeHosts(hostsP, true, true);
            },
            removeAllHosts: function () {
              this.internal_removeAllHosts(true, true);
            },
            internal_removeHosts: function (hostsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._hosts.size() !== 0 && this._hosts.containsKey((hostsP != null ? hostsP : Kotlin.throwNPE()).internalGetKey())) {
                this._hosts.remove((hostsP != null ? hostsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, hostsP, null));
                }
                if (setOpposite) {
                  (hostsP != null ? hostsP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_host, null, false, fireEvents);
                }
              }
            },
            internal_removeAllHosts: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.hosts) != null ? tmp$0 : Kotlin.throwNPE();
              if (setOpposite) {
                {
                  var tmp$1 = (temp_els != null ? temp_els : Kotlin.throwNPE()).iterator();
                  while (tmp$1.hasNext()) {
                    var el = tmp$1.next();
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_host, null, false, fireEvents);
                  }
                }
              }
              this._hosts.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, temp_els, null));
              }
            },
            typeDefinition: {
              get: function () {
                return this.$typeDefinition;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition, typeDefinitionP)) {
                var kmf_previousVal = this.$typeDefinition;
                this.$typeDefinition = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP, kmf_previousVal));
                }
              }
            },
            components: {
              get: function () {
                return _.kotlin.toList(this._components.values());
              },
              set: function (componentsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (componentsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_components(componentsP, true, true);
              }
            },
            internal_components: function (componentsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._components.values(), componentsP)) {
                var kmf_previousVal = this._components;
                this._components.clear();
                {
                  var tmp$0 = componentsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._components.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_components, el), _.org.kevoree.util.Constants.Ref_components);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, componentsP, kmf_previousVal));
                }
              }
            },
            doAddComponents: function (componentsP) {
              var _key_ = (componentsP != null ? componentsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._components.containsKey(_key_)) {
                this._components.put(_key_, componentsP);
                (componentsP != null ? componentsP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_components, componentsP), _.org.kevoree.util.Constants.Ref_components);
              }
            },
            addComponents: function (componentsP) {
              this.internal_addComponents(componentsP, true, true);
            },
            addAllComponents: function (componentsP) {
              this.internal_addAllComponents(componentsP, true, true);
            },
            internal_addComponents: function (componentsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddComponents(componentsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, componentsP, null));
              }
            },
            internal_addAllComponents: function (componentsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = componentsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddComponents(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = componentsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddComponents(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, componentsP, null));
              }
            },
            removeComponents: function (componentsP) {
              this.internal_removeComponents(componentsP, true, true);
            },
            removeAllComponents: function () {
              this.internal_removeAllComponents(true, true);
            },
            internal_removeComponents: function (componentsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._components.size() !== 0 && this._components.containsKey((componentsP != null ? componentsP : Kotlin.throwNPE()).internalGetKey())) {
                this._components.remove((componentsP != null ? componentsP : Kotlin.throwNPE()).internalGetKey());
                ((componentsP != null ? componentsP : Kotlin.throwNPE()) != null ? componentsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllComponentsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, componentsP, null));
                }
              }
            },
            internal_removeAllComponents: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllComponentsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.components) != null ? tmp$0 : Kotlin.throwNPE();
              this._components.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, temp_els, null));
                this.removeAllComponentsCurrentlyProcessing = false;
              }
            },
            dictionary: {
              get: function () {
                return this.$dictionary;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary, dictionaryP)) {
                if (this.$dictionary != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionary) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                var kmf_previousVal = this.$dictionary;
                this.$dictionary = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP, kmf_previousVal));
                }
              }
            },
            networkInformation: {
              get: function () {
                return _.kotlin.toList(this._networkInformation.values());
              },
              set: function (networkInformationP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (networkInformationP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_networkInformation(networkInformationP, true, true);
              }
            },
            internal_networkInformation: function (networkInformationP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._networkInformation.values(), networkInformationP)) {
                var kmf_previousVal = this._networkInformation;
                this._networkInformation.clear();
                {
                  var tmp$0 = networkInformationP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._networkInformation.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_networkInformation, el), _.org.kevoree.util.Constants.Ref_networkInformation);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkInformation, networkInformationP, kmf_previousVal));
                }
              }
            },
            doAddNetworkInformation: function (networkInformationP) {
              var _key_ = (networkInformationP != null ? networkInformationP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._networkInformation.containsKey(_key_)) {
                this._networkInformation.put(_key_, networkInformationP);
                (networkInformationP != null ? networkInformationP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_networkInformation, networkInformationP), _.org.kevoree.util.Constants.Ref_networkInformation);
              }
            },
            addNetworkInformation: function (networkInformationP) {
              this.internal_addNetworkInformation(networkInformationP, true, true);
            },
            addAllNetworkInformation: function (networkInformationP) {
              this.internal_addAllNetworkInformation(networkInformationP, true, true);
            },
            internal_addNetworkInformation: function (networkInformationP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddNetworkInformation(networkInformationP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkInformation, networkInformationP, null));
              }
            },
            internal_addAllNetworkInformation: function (networkInformationP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = networkInformationP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddNetworkInformation(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = networkInformationP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddNetworkInformation(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkInformation, networkInformationP, null));
              }
            },
            removeNetworkInformation: function (networkInformationP) {
              this.internal_removeNetworkInformation(networkInformationP, true, true);
            },
            removeAllNetworkInformation: function () {
              this.internal_removeAllNetworkInformation(true, true);
            },
            internal_removeNetworkInformation: function (networkInformationP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._networkInformation.size() !== 0 && this._networkInformation.containsKey((networkInformationP != null ? networkInformationP : Kotlin.throwNPE()).internalGetKey())) {
                this._networkInformation.remove((networkInformationP != null ? networkInformationP : Kotlin.throwNPE()).internalGetKey());
                ((networkInformationP != null ? networkInformationP : Kotlin.throwNPE()) != null ? networkInformationP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllNetworkInformationCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkInformation, networkInformationP, null));
                }
              }
            },
            internal_removeAllNetworkInformation: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllNetworkInformationCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.networkInformation) != null ? tmp$0 : Kotlin.throwNPE();
              this._networkInformation.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkInformation, temp_els, null));
                this.removeAllNetworkInformationCurrentlyProcessing = false;
              }
            },
            groups: {
              get: function () {
                return _.kotlin.toList(this._groups.values());
              },
              set: function (groupsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (groupsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_groups(groupsP, true, true);
              }
            },
            internal_groups: function (groupsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._groups.values(), groupsP)) {
                var kmf_previousVal = this._groups;
                this.internal_removeAllGroups(true, false);
                {
                  var tmp$0 = groupsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._groups.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.util.Constants.Ref_subNodes, this, false, fireEvents);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_groups, groupsP, kmf_previousVal));
                }
              }
            },
            doAddGroups: function (groupsP) {
              var _key_ = (groupsP != null ? groupsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._groups.containsKey(_key_)) {
                this._groups.put(_key_, groupsP);
              }
            },
            addGroups: function (groupsP) {
              this.internal_addGroups(groupsP, true, true);
            },
            addAllGroups: function (groupsP) {
              this.internal_addAllGroups(groupsP, true, true);
            },
            internal_addGroups: function (groupsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddGroups(groupsP);
              if (setOpposite) {
                (groupsP != null ? groupsP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.util.Constants.Ref_subNodes, this, false, fireEvents);
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_groups, groupsP, null));
              }
            },
            internal_addAllGroups: function (groupsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = groupsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddGroups(el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.util.Constants.Ref_subNodes, this, false, fireEvents);
                  }
                }
              }
               else {
                {
                  var tmp$1 = groupsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddGroups(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_groups, groupsP, null));
              }
            },
            removeGroups: function (groupsP) {
              this.internal_removeGroups(groupsP, true, true);
            },
            removeAllGroups: function () {
              this.internal_removeAllGroups(true, true);
            },
            internal_removeGroups: function (groupsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._groups.size() !== 0 && this._groups.containsKey((groupsP != null ? groupsP : Kotlin.throwNPE()).internalGetKey())) {
                this._groups.remove((groupsP != null ? groupsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_groups, groupsP, null));
                }
                if (setOpposite) {
                  (groupsP != null ? groupsP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_subNodes, this, false, fireEvents);
                }
              }
            },
            internal_removeAllGroups: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.groups) != null ? tmp$0 : Kotlin.throwNPE();
              if (setOpposite) {
                {
                  var tmp$1 = (temp_els != null ? temp_els : Kotlin.throwNPE()).iterator();
                  while (tmp$1.hasNext()) {
                    var el = tmp$1.next();
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_subNodes, this, false, fireEvents);
                  }
                }
              }
              this._groups.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_groups, temp_els, null));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_metaData) {
                this.internal_metaData(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_started) {
                this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_typeDefinition(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_dictionary(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllFragmentDictionary();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey(value)) {
                    var obj = this._fragmentDictionary.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._fragmentDictionary.remove(value);
                    this._fragmentDictionary.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_components) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addComponents(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllComponents(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeComponents(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllComponents();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._components.size() !== 0 && this._components.containsKey(value)) {
                    var obj_0 = this._components.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._components.remove(value);
                    this._components.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_hosts) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addHosts(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllHosts(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeHosts(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.internal_removeAllHosts(setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._hosts.size() !== 0 && this._hosts.containsKey(value)) {
                    var obj_1 = this._hosts.get(value);
                    var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_1 == null) {
                      throw new Error('Key newed to null ' + obj_1);
                    }
                    this._hosts.remove(value);
                    this._hosts.put(objNewKey_1, obj_1);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_host) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_host(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_host(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_host(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_groups) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addGroups(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllGroups(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeGroups(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.internal_removeAllGroups(setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._groups.size() !== 0 && this._groups.containsKey(value)) {
                    var obj_2 = this._groups.get(value);
                    var objNewKey_2 = (obj_2 != null ? obj_2 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_2 == null) {
                      throw new Error('Key newed to null ' + obj_2);
                    }
                    this._groups.remove(value);
                    this._groups.put(objNewKey_2, obj_2);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_networkInformation) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addNetworkInformation(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllNetworkInformation(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeNetworkInformation(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllNetworkInformation();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._networkInformation.size() !== 0 && this._networkInformation.containsKey(value)) {
                    var obj_3 = this._networkInformation.get(value);
                    var objNewKey_3 = (obj_3 != null ? obj_3 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_3 == null) {
                      throw new Error('Key newed to null ' + obj_3);
                    }
                    this._networkInformation.remove(value);
                    this._networkInformation.put(objNewKey_3, obj_3);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(this.name);
              }
              return this.key_cache;
            },
            findFragmentDictionaryByID: function (key) {
              return this._fragmentDictionary.get(key);
            },
            findComponentsByID: function (key) {
              return this._components.get(key);
            },
            findHostsByID: function (key) {
              return this._hosts.get(key);
            },
            findGroupsByID: function (key) {
              return this._groups.get(key);
            },
            findNetworkInformationByID: function (key) {
              return this._networkInformation.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                var objFound = this.typeDefinition;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                var objFound_0 = this.dictionary;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                return this.findFragmentDictionaryByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_components) {
                return this.findComponentsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_hosts) {
                return this.findHostsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_host) {
                var objFound_1 = this.host;
                if (objFound_1 != null && Kotlin.equals((objFound_1 != null ? objFound_1 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_1;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_groups) {
                return this.findGroupsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_networkInformation) {
                return this.findNetworkInformationByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary);
                this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary, _.org.kevoree.util.Constants.org_kevoree_FragmentDictionary);
                {
                  var tmp$0 = this._fragmentDictionary.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._fragmentDictionary.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_components, _.org.kevoree.util.Constants.org_kevoree_ComponentInstance);
                {
                  var tmp$1 = this._components.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._components.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_components);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_components);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_networkInformation, _.org.kevoree.util.Constants.org_kevoree_NetworkInfo);
                {
                  var tmp$2 = this._networkInformation.keySet().iterator();
                  while (tmp$2.hasNext()) {
                    var KMFLoopEntryKey_1 = tmp$2.next();
                    this.internal_visit(visitor, this._networkInformation.get(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_networkInformation);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_networkInformation);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_hosts, _.org.kevoree.util.Constants.org_kevoree_ContainerNode);
                {
                  var tmp$3 = this._hosts.keySet().iterator();
                  while (tmp$3.hasNext()) {
                    var KMFLoopEntryKey_2 = tmp$3.next();
                    this.internal_visit(visitor, this._hosts.get(KMFLoopEntryKey_2), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_hosts);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_hosts);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_host, _.org.kevoree.util.Constants.org_kevoree_ContainerNode);
                this.internal_visit(visitor, this.host, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_host);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_host);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_groups, _.org.kevoree.util.Constants.org_kevoree_Group);
                {
                  var tmp$4 = this._groups.keySet().iterator();
                  while (tmp$4.hasNext()) {
                    var KMFLoopEntryKey_3 = tmp$4.next();
                    this.internal_visit(visitor, this._groups.get(KMFLoopEntryKey_3), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_groups);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_groups);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
              visitor.visit(this.metaData, _.org.kevoree.util.Constants.Att_metaData, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ContainerNode;
            }
          }),
          PortTypeRefImpl: Kotlin.createClass([_c.PortTypeRef, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$name = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$optional = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$noDependency = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$ref = null;
            this._mappings = new Kotlin.PrimitiveHashMap(0);
            this.removeAllMappingsCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.PortTypeRefImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              this.ref = null;
              var tmp$1;
              (tmp$1 = this._mappings) != null ? tmp$1.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name;
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path(), null));
                }
              }
            },
            optional: {
              get: function () {
                return this.$optional;
              },
              set: function (iP) {
                this.internal_optional(iP, true);
              }
            },
            internal_optional: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.optional)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$optional;
                this.$optional = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_optional, this.optional, kmf_previousVal));
                }
              }
            },
            noDependency: {
              get: function () {
                return this.$noDependency;
              },
              set: function (iP) {
                this.internal_noDependency(iP, true);
              }
            },
            internal_noDependency: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.noDependency)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$noDependency;
                this.$noDependency = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_noDependency, this.noDependency, kmf_previousVal));
                }
              }
            },
            ref: {
              get: function () {
                return this.$ref;
              },
              set: function (refP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_ref(refP, true, true);
              }
            },
            internal_ref: function (refP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$ref, refP)) {
                var kmf_previousVal = this.$ref;
                this.$ref = refP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_ref, refP, kmf_previousVal));
                }
              }
            },
            mappings: {
              get: function () {
                return _.kotlin.toList(this._mappings.values());
              },
              set: function (mappingsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (mappingsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_mappings(mappingsP, true, true);
              }
            },
            internal_mappings: function (mappingsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._mappings.values(), mappingsP)) {
                var kmf_previousVal = this._mappings;
                this._mappings.clear();
                {
                  var tmp$0 = mappingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._mappings.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_mappings, el), _.org.kevoree.util.Constants.Ref_mappings);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, mappingsP, kmf_previousVal));
                }
              }
            },
            doAddMappings: function (mappingsP) {
              var _key_ = (mappingsP != null ? mappingsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._mappings.containsKey(_key_)) {
                this._mappings.put(_key_, mappingsP);
                (mappingsP != null ? mappingsP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_mappings, mappingsP), _.org.kevoree.util.Constants.Ref_mappings);
              }
            },
            addMappings: function (mappingsP) {
              this.internal_addMappings(mappingsP, true, true);
            },
            addAllMappings: function (mappingsP) {
              this.internal_addAllMappings(mappingsP, true, true);
            },
            internal_addMappings: function (mappingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMappings(mappingsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, mappingsP, null));
              }
            },
            internal_addAllMappings: function (mappingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = mappingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMappings(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = mappingsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMappings(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, mappingsP, null));
              }
            },
            removeMappings: function (mappingsP) {
              this.internal_removeMappings(mappingsP, true, true);
            },
            removeAllMappings: function () {
              this.internal_removeAllMappings(true, true);
            },
            internal_removeMappings: function (mappingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._mappings.size() !== 0 && this._mappings.containsKey((mappingsP != null ? mappingsP : Kotlin.throwNPE()).internalGetKey())) {
                this._mappings.remove((mappingsP != null ? mappingsP : Kotlin.throwNPE()).internalGetKey());
                ((mappingsP != null ? mappingsP : Kotlin.throwNPE()) != null ? mappingsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllMappingsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, mappingsP, null));
                }
              }
            },
            internal_removeAllMappings: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMappingsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.mappings) != null ? tmp$0 : Kotlin.throwNPE();
              this._mappings.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, temp_els, null));
                this.removeAllMappingsCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_optional) {
                this.internal_optional(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_noDependency) {
                this.internal_noDependency(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_ref) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_ref(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_ref(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_ref(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_mappings) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addMappings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllMappings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeMappings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllMappings();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._mappings.size() !== 0 && this._mappings.containsKey(value)) {
                    var obj = this._mappings.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._mappings.remove(value);
                    this._mappings.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(this.name);
              }
              return this.key_cache;
            },
            findMappingsByID: function (key) {
              return this._mappings.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_ref) {
                var objFound = this.ref;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_mappings) {
                return this.findMappingsByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_mappings, _.org.kevoree.util.Constants.org_kevoree_PortTypeMapping);
                {
                  var tmp$0 = this._mappings.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._mappings.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_mappings);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_mappings);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_ref, _.org.kevoree.util.Constants.org_kevoree_PortType);
                this.internal_visit(visitor, this.ref, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_ref);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_ref);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.noDependency, _.org.kevoree.util.Constants.Att_noDependency, this);
              visitor.visit(this.optional, _.org.kevoree.util.Constants.Att_optional, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_PortTypeRef;
            }
          }),
          DeployUnitImpl: Kotlin.createClass([_c.DeployUnit, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$name = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$groupName = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$version = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$url = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$hashcode = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$type = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this._requiredLibs = new Kotlin.PrimitiveHashMap(0);
          }, /** @lends _.org.kevoree.impl.DeployUnitImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              var tmp$1;
              (tmp$1 = this._requiredLibs) != null ? tmp$1.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name;
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path(), null));
                }
              }
            },
            groupName: {
              get: function () {
                return this.$groupName;
              },
              set: function (iP) {
                this.internal_groupName(iP, true);
              }
            },
            internal_groupName: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.groupName)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$groupName;
                this.$groupName = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_groupName, this.groupName, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_groupName, this.path(), null));
                }
              }
            },
            version: {
              get: function () {
                return this.$version;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$version;
                this.$version = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_version, this.path(), null));
                }
              }
            },
            url: {
              get: function () {
                return this.$url;
              },
              set: function (iP) {
                this.internal_url(iP, true);
              }
            },
            internal_url: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.url)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$url;
                this.$url = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_url, this.url, kmf_previousVal));
                }
              }
            },
            hashcode: {
              get: function () {
                return this.$hashcode;
              },
              set: function (iP) {
                this.internal_hashcode(iP, true);
              }
            },
            internal_hashcode: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.hashcode)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$hashcode;
                this.$hashcode = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_hashcode, this.hashcode, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_hashcode, this.path(), null));
                }
              }
            },
            type: {
              get: function () {
                return this.$type;
              },
              set: function (iP) {
                this.internal_type(iP, true);
              }
            },
            internal_type: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.type)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$type;
                this.$type = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_type, this.type, kmf_previousVal));
                }
              }
            },
            requiredLibs: {
              get: function () {
                return _.kotlin.toList(this._requiredLibs.values());
              },
              set: function (requiredLibsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (requiredLibsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_requiredLibs(requiredLibsP, true, true);
              }
            },
            internal_requiredLibs: function (requiredLibsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._requiredLibs.values(), requiredLibsP)) {
                var kmf_previousVal = this._requiredLibs;
                this._requiredLibs.clear();
                {
                  var tmp$0 = requiredLibsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._requiredLibs.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, requiredLibsP, kmf_previousVal));
                }
              }
            },
            doAddRequiredLibs: function (requiredLibsP) {
              var _key_ = (requiredLibsP != null ? requiredLibsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._requiredLibs.containsKey(_key_)) {
                this._requiredLibs.put(_key_, requiredLibsP);
              }
            },
            addRequiredLibs: function (requiredLibsP) {
              this.internal_addRequiredLibs(requiredLibsP, true, true);
            },
            addAllRequiredLibs: function (requiredLibsP) {
              this.internal_addAllRequiredLibs(requiredLibsP, true, true);
            },
            internal_addRequiredLibs: function (requiredLibsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddRequiredLibs(requiredLibsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, requiredLibsP, null));
              }
            },
            internal_addAllRequiredLibs: function (requiredLibsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = requiredLibsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddRequiredLibs(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = requiredLibsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddRequiredLibs(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, requiredLibsP, null));
              }
            },
            removeRequiredLibs: function (requiredLibsP) {
              this.internal_removeRequiredLibs(requiredLibsP, true, true);
            },
            removeAllRequiredLibs: function () {
              this.internal_removeAllRequiredLibs(true, true);
            },
            internal_removeRequiredLibs: function (requiredLibsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._requiredLibs.size() !== 0 && this._requiredLibs.containsKey((requiredLibsP != null ? requiredLibsP : Kotlin.throwNPE()).internalGetKey())) {
                this._requiredLibs.remove((requiredLibsP != null ? requiredLibsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, requiredLibsP, null));
                }
              }
            },
            internal_removeAllRequiredLibs: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.requiredLibs) != null ? tmp$0 : Kotlin.throwNPE();
              this._requiredLibs.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, temp_els, null));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_groupName) {
                this.internal_groupName(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_version) {
                this.internal_version(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_url) {
                this.internal_url(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_hashcode) {
                this.internal_hashcode(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_type) {
                this.internal_type(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_requiredLibs) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addRequiredLibs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllRequiredLibs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeRequiredLibs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllRequiredLibs();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._requiredLibs.size() !== 0 && this._requiredLibs.containsKey(value)) {
                    var obj = this._requiredLibs.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._requiredLibs.remove(value);
                    this._requiredLibs.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(this.groupName) + '/' + Kotlin.toString(this.hashcode) + '/' + Kotlin.toString(this.name) + '/' + Kotlin.toString(this.version);
              }
              return this.key_cache;
            },
            findRequiredLibsByID: function (key) {
              return this._requiredLibs.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_requiredLibs) {
                return this.findRequiredLibsByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_requiredLibs, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$0 = this._requiredLibs.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._requiredLibs.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_requiredLibs);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_requiredLibs);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.groupName, _.org.kevoree.util.Constants.Att_groupName, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.hashcode, _.org.kevoree.util.Constants.Att_hashcode, this);
              visitor.visit(this.type, _.org.kevoree.util.Constants.Att_type, this);
              visitor.visit(this.url, _.org.kevoree.util.Constants.Att_url, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_DeployUnit;
            }
          }),
          FragmentDictionaryImpl: Kotlin.createClass([_c.FragmentDictionary, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$generated_KMF_ID = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$name = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this._values = new Kotlin.PrimitiveHashMap(0);
            this.removeAllValuesCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.FragmentDictionaryImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              var tmp$1;
              (tmp$1 = this._values) != null ? tmp$1.clear() : null;
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$generated_KMF_ID;
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path(), null));
                }
              }
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name;
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path(), null));
                }
              }
            },
            values: {
              get: function () {
                return _.kotlin.toList(this._values.values());
              },
              set: function (valuesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (valuesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_values(valuesP, true, true);
              }
            },
            internal_values: function (valuesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._values.values(), valuesP)) {
                var kmf_previousVal = this._values;
                this._values.clear();
                {
                  var tmp$0 = valuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._values.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_values, el), _.org.kevoree.util.Constants.Ref_values);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, kmf_previousVal));
                }
              }
            },
            doAddValues: function (valuesP) {
              var _key_ = (valuesP != null ? valuesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._values.containsKey(_key_)) {
                this._values.put(_key_, valuesP);
                (valuesP != null ? valuesP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_values, valuesP), _.org.kevoree.util.Constants.Ref_values);
              }
            },
            addValues: function (valuesP) {
              this.internal_addValues(valuesP, true, true);
            },
            addAllValues: function (valuesP) {
              this.internal_addAllValues(valuesP, true, true);
            },
            internal_addValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddValues(valuesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, null));
              }
            },
            internal_addAllValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = valuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddValues(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = valuesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddValues(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, null));
              }
            },
            removeValues: function (valuesP) {
              this.internal_removeValues(valuesP, true, true);
            },
            removeAllValues: function () {
              this.internal_removeAllValues(true, true);
            },
            internal_removeValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._values.size() !== 0 && this._values.containsKey((valuesP != null ? valuesP : Kotlin.throwNPE()).internalGetKey())) {
                this._values.remove((valuesP != null ? valuesP : Kotlin.throwNPE()).internalGetKey());
                ((valuesP != null ? valuesP : Kotlin.throwNPE()) != null ? valuesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllValuesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, null));
                }
              }
            },
            internal_removeAllValues: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllValuesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.values) != null ? tmp$0 : Kotlin.throwNPE();
              this._values.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, temp_els, null));
                this.removeAllValuesCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_values) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllValues();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._values.size() !== 0 && this._values.containsKey(value)) {
                    var obj = this._values.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._values.remove(value);
                    this._values.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(this.name);
              }
              return this.key_cache;
            },
            findValuesByID: function (key) {
              return this._values.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_values) {
                return this.findValuesByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_values, _.org.kevoree.util.Constants.org_kevoree_DictionaryValue);
                {
                  var tmp$0 = this._values.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._values.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_values);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_values);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_FragmentDictionary;
            }
          }),
          NetworkPropertyImpl: Kotlin.createClass([_c.NetworkProperty, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$name = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$value = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
          }, /** @lends _.org.kevoree.impl.NetworkPropertyImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name;
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path(), null));
                }
              }
            },
            value: {
              get: function () {
                return this.$value;
              },
              set: function (iP) {
                this.internal_value(iP, true);
              }
            },
            internal_value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.value)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$value;
                this.$value = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_value, this.value, kmf_previousVal));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_value) {
                this.internal_value(value, fireEvents);
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(this.name) + '/' + Kotlin.toString(this.name);
              }
              return this.key_cache;
            },
            findByID: function (relationName, idP) {
              {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.value, _.org.kevoree.util.Constants.Att_value, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_NetworkProperty;
            }
          }),
          GroupTypeImpl: Kotlin.createClass([_c.GroupType, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$name = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$version = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$factoryBean = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$bean = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$abstract = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$dictionaryType = null;
            this.$deployUnit = null;
            this._superTypes = new Kotlin.PrimitiveHashMap(0);
          }, /** @lends _.org.kevoree.impl.GroupTypeImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              this.deployUnit = null;
              this.dictionaryType = null;
              var tmp$1;
              (tmp$1 = this._superTypes) != null ? tmp$1.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name;
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path(), null));
                }
              }
            },
            version: {
              get: function () {
                return this.$version;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$version;
                this.$version = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_version, this.path(), null));
                }
              }
            },
            factoryBean: {
              get: function () {
                return this.$factoryBean;
              },
              set: function (iP) {
                this.internal_factoryBean(iP, true);
              }
            },
            internal_factoryBean: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.factoryBean)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$factoryBean;
                this.$factoryBean = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_factoryBean, this.factoryBean, kmf_previousVal));
                }
              }
            },
            bean: {
              get: function () {
                return this.$bean;
              },
              set: function (iP) {
                this.internal_bean(iP, true);
              }
            },
            internal_bean: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.bean)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$bean;
                this.$bean = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_bean, this.bean, kmf_previousVal));
                }
              }
            },
            abstract: {
              get: function () {
                return this.$abstract;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$abstract;
                this.$abstract = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract, kmf_previousVal));
                }
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType, dictionaryTypeP)) {
                if (this.$dictionaryType != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                var kmf_previousVal = this.$dictionaryType;
                this.$dictionaryType = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP, kmf_previousVal));
                }
              }
            },
            deployUnit: {
              get: function () {
                return this.$deployUnit;
              },
              set: function (deployUnitP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_deployUnit(deployUnitP, true, true);
              }
            },
            internal_deployUnit: function (deployUnitP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$deployUnit, deployUnitP)) {
                var kmf_previousVal = this.$deployUnit;
                this.$deployUnit = deployUnitP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnit, deployUnitP, kmf_previousVal));
                }
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                var kmf_previousVal = this._superTypes;
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, kmf_previousVal));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = (superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey(_key_)) {
                this._superTypes.put(_key_, superTypesP);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._superTypes.remove((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.superTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els, null));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_version) {
                this.internal_version(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_factoryBean) {
                this.internal_factoryBean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_bean) {
                this.internal_bean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnit) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_deployUnit(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_deployUnit(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_deployUnit(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_dictionaryType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllSuperTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._superTypes.size() !== 0 && this._superTypes.containsKey(value)) {
                    var obj = this._superTypes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._superTypes.remove(value);
                    this._superTypes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(this.name) + '/' + Kotlin.toString(this.version);
              }
              return this.key_cache;
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_deployUnit) {
                var objFound = this.deployUnit;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                var objFound_0 = this.dictionaryType;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                return this.findSuperTypesByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType);
                this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnit, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                this.internal_visit(visitor, this.deployUnit, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnit);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnit);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$0 = this._superTypes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._superTypes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.bean, _.org.kevoree.util.Constants.Att_bean, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.factoryBean, _.org.kevoree.util.Constants.Att_factoryBean, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_GroupType;
            }
          }),
          DictionaryAttributeImpl: Kotlin.createClass([_c.DictionaryAttribute, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$name = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$optional = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$state = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$datatype = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$fragmentDependant = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$defaultValue = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this._genericTypes = new Kotlin.PrimitiveHashMap(0);
          }, /** @lends _.org.kevoree.impl.DictionaryAttributeImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              var tmp$1;
              (tmp$1 = this._genericTypes) != null ? tmp$1.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name;
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path(), null));
                }
              }
            },
            optional: {
              get: function () {
                return this.$optional;
              },
              set: function (iP) {
                this.internal_optional(iP, true);
              }
            },
            internal_optional: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.optional)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$optional;
                this.$optional = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_optional, this.optional, kmf_previousVal));
                }
              }
            },
            state: {
              get: function () {
                return this.$state;
              },
              set: function (iP) {
                this.internal_state(iP, true);
              }
            },
            internal_state: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.state)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$state;
                this.$state = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_state, this.state, kmf_previousVal));
                }
              }
            },
            datatype: {
              get: function () {
                return this.$datatype;
              },
              set: function (iP) {
                this.internal_datatype(iP, true);
              }
            },
            internal_datatype: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.datatype)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$datatype;
                this.$datatype = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_datatype, this.datatype, kmf_previousVal));
                }
              }
            },
            fragmentDependant: {
              get: function () {
                return this.$fragmentDependant;
              },
              set: function (iP) {
                this.internal_fragmentDependant(iP, true);
              }
            },
            internal_fragmentDependant: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.fragmentDependant)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$fragmentDependant;
                this.$fragmentDependant = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_fragmentDependant, this.fragmentDependant, kmf_previousVal));
                }
              }
            },
            defaultValue: {
              get: function () {
                return this.$defaultValue;
              },
              set: function (iP) {
                this.internal_defaultValue(iP, true);
              }
            },
            internal_defaultValue: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.defaultValue)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$defaultValue;
                this.$defaultValue = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_defaultValue, this.defaultValue, kmf_previousVal));
                }
              }
            },
            genericTypes: {
              get: function () {
                return _.kotlin.toList(this._genericTypes.values());
              },
              set: function (genericTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (genericTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_genericTypes(genericTypesP, true, true);
              }
            },
            internal_genericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._genericTypes.values(), genericTypesP)) {
                var kmf_previousVal = this._genericTypes;
                this._genericTypes.clear();
                {
                  var tmp$0 = genericTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._genericTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP, kmf_previousVal));
                }
              }
            },
            doAddGenericTypes: function (genericTypesP) {
              var _key_ = (genericTypesP != null ? genericTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._genericTypes.containsKey(_key_)) {
                this._genericTypes.put(_key_, genericTypesP);
              }
            },
            addGenericTypes: function (genericTypesP) {
              this.internal_addGenericTypes(genericTypesP, true, true);
            },
            addAllGenericTypes: function (genericTypesP) {
              this.internal_addAllGenericTypes(genericTypesP, true, true);
            },
            internal_addGenericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddGenericTypes(genericTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP, null));
              }
            },
            internal_addAllGenericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = genericTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddGenericTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = genericTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddGenericTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP, null));
              }
            },
            removeGenericTypes: function (genericTypesP) {
              this.internal_removeGenericTypes(genericTypesP, true, true);
            },
            removeAllGenericTypes: function () {
              this.internal_removeAllGenericTypes(true, true);
            },
            internal_removeGenericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._genericTypes.size() !== 0 && this._genericTypes.containsKey((genericTypesP != null ? genericTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._genericTypes.remove((genericTypesP != null ? genericTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP, null));
                }
              }
            },
            internal_removeAllGenericTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.genericTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._genericTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, temp_els, null));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_optional) {
                this.internal_optional(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_state) {
                this.internal_state(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_datatype) {
                this.internal_datatype(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_fragmentDependant) {
                this.internal_fragmentDependant(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_defaultValue) {
                this.internal_defaultValue(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_genericTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllGenericTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._genericTypes.size() !== 0 && this._genericTypes.containsKey(value)) {
                    var obj = this._genericTypes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._genericTypes.remove(value);
                    this._genericTypes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(this.name);
              }
              return this.key_cache;
            },
            findGenericTypesByID: function (key) {
              return this._genericTypes.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_genericTypes) {
                return this.findGenericTypesByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_genericTypes, _.org.kevoree.util.Constants.org_kevoree_TypedElement);
                {
                  var tmp$0 = this._genericTypes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._genericTypes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_genericTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_genericTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.fragmentDependant, _.org.kevoree.util.Constants.Att_fragmentDependant, this);
              visitor.visit(this.optional, _.org.kevoree.util.Constants.Att_optional, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.state, _.org.kevoree.util.Constants.Att_state, this);
              visitor.visit(this.datatype, _.org.kevoree.util.Constants.Att_datatype, this);
              visitor.visit(this.defaultValue, _.org.kevoree.util.Constants.Att_defaultValue, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_DictionaryAttribute;
            }
          }),
          InstanceImpl: Kotlin.createClass([_c.Instance, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$name = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$metaData = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$started = true;
            this._fragmentDictionary = new Kotlin.PrimitiveHashMap(0);
            this.removeAllFragmentDictionaryCurrentlyProcessing = false;
            this.$typeDefinition = null;
            this.$dictionary = null;
          }, /** @lends _.org.kevoree.impl.InstanceImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              this.typeDefinition = null;
              this.dictionary = null;
              var tmp$1;
              (tmp$1 = this._fragmentDictionary) != null ? tmp$1.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name;
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path(), null));
                }
              }
            },
            metaData: {
              get: function () {
                return this.$metaData;
              },
              set: function (iP) {
                this.internal_metaData(iP, true);
              }
            },
            internal_metaData: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.metaData)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$metaData;
                this.$metaData = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_metaData, this.metaData, kmf_previousVal));
                }
              }
            },
            started: {
              get: function () {
                return this.$started;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$started;
                this.$started = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started, kmf_previousVal));
                }
              }
            },
            fragmentDictionary: {
              get: function () {
                return _.kotlin.toList(this._fragmentDictionary.values());
              },
              set: function (fragmentDictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (fragmentDictionaryP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_fragmentDictionary(fragmentDictionaryP, true, true);
              }
            },
            internal_fragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._fragmentDictionary.values(), fragmentDictionaryP)) {
                var kmf_previousVal = this._fragmentDictionary;
                this._fragmentDictionary.clear();
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._fragmentDictionary.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, el), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, kmf_previousVal));
                }
              }
            },
            doAddFragmentDictionary: function (fragmentDictionaryP) {
              var _key_ = (fragmentDictionaryP != null ? fragmentDictionaryP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._fragmentDictionary.containsKey(_key_)) {
                this._fragmentDictionary.put(_key_, fragmentDictionaryP);
                (fragmentDictionaryP != null ? fragmentDictionaryP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
              }
            },
            addFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addFragmentDictionary(fragmentDictionaryP, true, true);
            },
            addAllFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addAllFragmentDictionary(fragmentDictionaryP, true, true);
            },
            internal_addFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddFragmentDictionary(fragmentDictionaryP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null));
              }
            },
            internal_addAllFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddFragmentDictionary(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = fragmentDictionaryP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddFragmentDictionary(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null));
              }
            },
            removeFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_removeFragmentDictionary(fragmentDictionaryP, true, true);
            },
            removeAllFragmentDictionary: function () {
              this.internal_removeAllFragmentDictionary(true, true);
            },
            internal_removeFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey((fragmentDictionaryP != null ? fragmentDictionaryP : Kotlin.throwNPE()).internalGetKey())) {
                this._fragmentDictionary.remove((fragmentDictionaryP != null ? fragmentDictionaryP : Kotlin.throwNPE()).internalGetKey());
                ((fragmentDictionaryP != null ? fragmentDictionaryP : Kotlin.throwNPE()) != null ? fragmentDictionaryP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllFragmentDictionaryCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null));
                }
              }
            },
            internal_removeAllFragmentDictionary: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllFragmentDictionaryCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.fragmentDictionary) != null ? tmp$0 : Kotlin.throwNPE();
              this._fragmentDictionary.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, temp_els, null));
                this.removeAllFragmentDictionaryCurrentlyProcessing = false;
              }
            },
            typeDefinition: {
              get: function () {
                return this.$typeDefinition;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition, typeDefinitionP)) {
                var kmf_previousVal = this.$typeDefinition;
                this.$typeDefinition = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP, kmf_previousVal));
                }
              }
            },
            dictionary: {
              get: function () {
                return this.$dictionary;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary, dictionaryP)) {
                if (this.$dictionary != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionary) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                var kmf_previousVal = this.$dictionary;
                this.$dictionary = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP, kmf_previousVal));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_metaData) {
                this.internal_metaData(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_started) {
                this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_typeDefinition(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_dictionary(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllFragmentDictionary();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey(value)) {
                    var obj = this._fragmentDictionary.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._fragmentDictionary.remove(value);
                    this._fragmentDictionary.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(this.name);
              }
              return this.key_cache;
            },
            findFragmentDictionaryByID: function (key) {
              return this._fragmentDictionary.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                var objFound = this.typeDefinition;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                var objFound_0 = this.dictionary;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                return this.findFragmentDictionaryByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary);
                this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary, _.org.kevoree.util.Constants.org_kevoree_FragmentDictionary);
                {
                  var tmp$0 = this._fragmentDictionary.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._fragmentDictionary.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
              visitor.visit(this.metaData, _.org.kevoree.util.Constants.Att_metaData, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Instance;
            }
          }),
          ChannelTypeImpl: Kotlin.createClass([_c.ChannelType, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$name = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$version = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$factoryBean = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$bean = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$abstract = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$lowerBindings = _.org.kevoree.util.Constants.INT_DEFAULTVAL;
            this.$upperBindings = _.org.kevoree.util.Constants.INT_DEFAULTVAL;
            this.$lowerFragments = _.org.kevoree.util.Constants.INT_DEFAULTVAL;
            this.$upperFragments = _.org.kevoree.util.Constants.INT_DEFAULTVAL;
            this.$dictionaryType = null;
            this.$deployUnit = null;
            this._superTypes = new Kotlin.PrimitiveHashMap(0);
          }, /** @lends _.org.kevoree.impl.ChannelTypeImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              this.deployUnit = null;
              this.dictionaryType = null;
              var tmp$1;
              (tmp$1 = this._superTypes) != null ? tmp$1.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name;
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path(), null));
                }
              }
            },
            version: {
              get: function () {
                return this.$version;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$version;
                this.$version = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_version, this.path(), null));
                }
              }
            },
            factoryBean: {
              get: function () {
                return this.$factoryBean;
              },
              set: function (iP) {
                this.internal_factoryBean(iP, true);
              }
            },
            internal_factoryBean: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.factoryBean)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$factoryBean;
                this.$factoryBean = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_factoryBean, this.factoryBean, kmf_previousVal));
                }
              }
            },
            bean: {
              get: function () {
                return this.$bean;
              },
              set: function (iP) {
                this.internal_bean(iP, true);
              }
            },
            internal_bean: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.bean)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$bean;
                this.$bean = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_bean, this.bean, kmf_previousVal));
                }
              }
            },
            abstract: {
              get: function () {
                return this.$abstract;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$abstract;
                this.$abstract = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract, kmf_previousVal));
                }
              }
            },
            lowerBindings: {
              get: function () {
                return this.$lowerBindings;
              },
              set: function (iP) {
                this.internal_lowerBindings(iP, true);
              }
            },
            internal_lowerBindings: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.lowerBindings) {
                var oldPath = this.path();
                var kmf_previousVal = this.$lowerBindings;
                this.$lowerBindings = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_lowerBindings, this.lowerBindings, kmf_previousVal));
                }
              }
            },
            upperBindings: {
              get: function () {
                return this.$upperBindings;
              },
              set: function (iP) {
                this.internal_upperBindings(iP, true);
              }
            },
            internal_upperBindings: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.upperBindings) {
                var oldPath = this.path();
                var kmf_previousVal = this.$upperBindings;
                this.$upperBindings = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_upperBindings, this.upperBindings, kmf_previousVal));
                }
              }
            },
            lowerFragments: {
              get: function () {
                return this.$lowerFragments;
              },
              set: function (iP) {
                this.internal_lowerFragments(iP, true);
              }
            },
            internal_lowerFragments: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.lowerFragments) {
                var oldPath = this.path();
                var kmf_previousVal = this.$lowerFragments;
                this.$lowerFragments = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_lowerFragments, this.lowerFragments, kmf_previousVal));
                }
              }
            },
            upperFragments: {
              get: function () {
                return this.$upperFragments;
              },
              set: function (iP) {
                this.internal_upperFragments(iP, true);
              }
            },
            internal_upperFragments: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.upperFragments) {
                var oldPath = this.path();
                var kmf_previousVal = this.$upperFragments;
                this.$upperFragments = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_upperFragments, this.upperFragments, kmf_previousVal));
                }
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType, dictionaryTypeP)) {
                if (this.$dictionaryType != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                var kmf_previousVal = this.$dictionaryType;
                this.$dictionaryType = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP, kmf_previousVal));
                }
              }
            },
            deployUnit: {
              get: function () {
                return this.$deployUnit;
              },
              set: function (deployUnitP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_deployUnit(deployUnitP, true, true);
              }
            },
            internal_deployUnit: function (deployUnitP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$deployUnit, deployUnitP)) {
                var kmf_previousVal = this.$deployUnit;
                this.$deployUnit = deployUnitP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnit, deployUnitP, kmf_previousVal));
                }
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                var kmf_previousVal = this._superTypes;
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, kmf_previousVal));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = (superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey(_key_)) {
                this._superTypes.put(_key_, superTypesP);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._superTypes.remove((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.superTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els, null));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_version) {
                this.internal_version(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_factoryBean) {
                this.internal_factoryBean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_bean) {
                this.internal_bean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_lowerBindings) {
                this.internal_lowerBindings(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_upperBindings) {
                this.internal_upperBindings(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_lowerFragments) {
                this.internal_lowerFragments(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_upperFragments) {
                this.internal_upperFragments(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnit) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_deployUnit(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_deployUnit(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_deployUnit(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_dictionaryType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllSuperTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._superTypes.size() !== 0 && this._superTypes.containsKey(value)) {
                    var obj = this._superTypes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._superTypes.remove(value);
                    this._superTypes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(this.name) + '/' + Kotlin.toString(this.version);
              }
              return this.key_cache;
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_deployUnit) {
                var objFound = this.deployUnit;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                var objFound_0 = this.dictionaryType;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                return this.findSuperTypesByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType);
                this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnit, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                this.internal_visit(visitor, this.deployUnit, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnit);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnit);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$0 = this._superTypes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._superTypes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.upperFragments, _.org.kevoree.util.Constants.Att_upperFragments, this);
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.upperBindings, _.org.kevoree.util.Constants.Att_upperBindings, this);
              visitor.visit(this.lowerBindings, _.org.kevoree.util.Constants.Att_lowerBindings, this);
              visitor.visit(this.bean, _.org.kevoree.util.Constants.Att_bean, this);
              visitor.visit(this.lowerFragments, _.org.kevoree.util.Constants.Att_lowerFragments, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.factoryBean, _.org.kevoree.util.Constants.Att_factoryBean, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ChannelType;
            }
          }),
          NodeNetworkImpl: Kotlin.createClass([_c.NodeNetwork, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$generated_KMF_ID = '' + Math.random() + (new Date()).getTime();
            this.$initBy = null;
            this._link = new Kotlin.PrimitiveHashMap(0);
            this.removeAllLinkCurrentlyProcessing = false;
            this.$target = null;
          }, /** @lends _.org.kevoree.impl.NodeNetworkImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              var tmp$1;
              (tmp$1 = this._link) != null ? tmp$1.clear() : null;
              this.initBy = null;
              this.target = null;
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$generated_KMF_ID;
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path(), null));
                }
              }
            },
            initBy: {
              get: function () {
                return this.$initBy;
              },
              set: function (initByP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_initBy(initByP, true, true);
              }
            },
            internal_initBy: function (initByP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$initBy, initByP)) {
                var kmf_previousVal = this.$initBy;
                this.$initBy = initByP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_initBy, initByP, kmf_previousVal));
                }
              }
            },
            link: {
              get: function () {
                return _.kotlin.toList(this._link.values());
              },
              set: function (linkP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (linkP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_link(linkP, true, true);
              }
            },
            internal_link: function (linkP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._link.values(), linkP)) {
                var kmf_previousVal = this._link;
                this._link.clear();
                {
                  var tmp$0 = linkP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._link.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_link, el), _.org.kevoree.util.Constants.Ref_link);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_link, linkP, kmf_previousVal));
                }
              }
            },
            doAddLink: function (linkP) {
              var _key_ = (linkP != null ? linkP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._link.containsKey(_key_)) {
                this._link.put(_key_, linkP);
                (linkP != null ? linkP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_link, linkP), _.org.kevoree.util.Constants.Ref_link);
              }
            },
            addLink: function (linkP) {
              this.internal_addLink(linkP, true, true);
            },
            addAllLink: function (linkP) {
              this.internal_addAllLink(linkP, true, true);
            },
            internal_addLink: function (linkP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddLink(linkP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_link, linkP, null));
              }
            },
            internal_addAllLink: function (linkP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = linkP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddLink(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = linkP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddLink(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_link, linkP, null));
              }
            },
            removeLink: function (linkP) {
              this.internal_removeLink(linkP, true, true);
            },
            removeAllLink: function () {
              this.internal_removeAllLink(true, true);
            },
            internal_removeLink: function (linkP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._link.size() !== 0 && this._link.containsKey((linkP != null ? linkP : Kotlin.throwNPE()).internalGetKey())) {
                this._link.remove((linkP != null ? linkP : Kotlin.throwNPE()).internalGetKey());
                ((linkP != null ? linkP : Kotlin.throwNPE()) != null ? linkP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllLinkCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_link, linkP, null));
                }
              }
            },
            internal_removeAllLink: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllLinkCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.link) != null ? tmp$0 : Kotlin.throwNPE();
              this._link.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_link, temp_els, null));
                this.removeAllLinkCurrentlyProcessing = false;
              }
            },
            target: {
              get: function () {
                return this.$target;
              },
              set: function (targetP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_target(targetP, true, true);
              }
            },
            internal_target: function (targetP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$target, targetP)) {
                var kmf_previousVal = this.$target;
                this.$target = targetP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_target, targetP, kmf_previousVal));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_link) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addLink(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllLink(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeLink(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllLink();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._link.size() !== 0 && this._link.containsKey(value)) {
                    var obj = this._link.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._link.remove(value);
                    this._link.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_initBy) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_initBy(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_initBy(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_initBy(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_target) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_target(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_target(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_target(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = this.generated_KMF_ID;
              }
              return this.key_cache;
            },
            findLinkByID: function (key) {
              return this._link.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_link) {
                return this.findLinkByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_initBy) {
                var objFound = this.initBy;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_target) {
                var objFound_0 = this.target;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_link, _.org.kevoree.util.Constants.org_kevoree_NodeLink);
                {
                  var tmp$0 = this._link.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._link.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_link);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_link);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_initBy, _.org.kevoree.util.Constants.org_kevoree_ContainerNode);
                this.internal_visit(visitor, this.initBy, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_initBy);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_initBy);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_target, _.org.kevoree.util.Constants.org_kevoree_ContainerNode);
                this.internal_visit(visitor, this.target, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_target);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_target);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_NodeNetwork;
            }
          }),
          NodeTypeImpl: Kotlin.createClass([_c.NodeType, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$name = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$version = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$factoryBean = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$bean = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$abstract = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$dictionaryType = null;
            this.$deployUnit = null;
            this._superTypes = new Kotlin.PrimitiveHashMap(0);
          }, /** @lends _.org.kevoree.impl.NodeTypeImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              this.deployUnit = null;
              this.dictionaryType = null;
              var tmp$1;
              (tmp$1 = this._superTypes) != null ? tmp$1.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name;
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path(), null));
                }
              }
            },
            version: {
              get: function () {
                return this.$version;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$version;
                this.$version = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_version, this.path(), null));
                }
              }
            },
            factoryBean: {
              get: function () {
                return this.$factoryBean;
              },
              set: function (iP) {
                this.internal_factoryBean(iP, true);
              }
            },
            internal_factoryBean: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.factoryBean)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$factoryBean;
                this.$factoryBean = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_factoryBean, this.factoryBean, kmf_previousVal));
                }
              }
            },
            bean: {
              get: function () {
                return this.$bean;
              },
              set: function (iP) {
                this.internal_bean(iP, true);
              }
            },
            internal_bean: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.bean)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$bean;
                this.$bean = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_bean, this.bean, kmf_previousVal));
                }
              }
            },
            abstract: {
              get: function () {
                return this.$abstract;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$abstract;
                this.$abstract = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract, kmf_previousVal));
                }
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType, dictionaryTypeP)) {
                if (this.$dictionaryType != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                var kmf_previousVal = this.$dictionaryType;
                this.$dictionaryType = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP, kmf_previousVal));
                }
              }
            },
            deployUnit: {
              get: function () {
                return this.$deployUnit;
              },
              set: function (deployUnitP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_deployUnit(deployUnitP, true, true);
              }
            },
            internal_deployUnit: function (deployUnitP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$deployUnit, deployUnitP)) {
                var kmf_previousVal = this.$deployUnit;
                this.$deployUnit = deployUnitP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnit, deployUnitP, kmf_previousVal));
                }
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                var kmf_previousVal = this._superTypes;
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, kmf_previousVal));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = (superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey(_key_)) {
                this._superTypes.put(_key_, superTypesP);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._superTypes.remove((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.superTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els, null));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_version) {
                this.internal_version(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_factoryBean) {
                this.internal_factoryBean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_bean) {
                this.internal_bean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnit) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_deployUnit(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_deployUnit(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_deployUnit(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_dictionaryType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllSuperTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._superTypes.size() !== 0 && this._superTypes.containsKey(value)) {
                    var obj = this._superTypes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._superTypes.remove(value);
                    this._superTypes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(this.name) + '/' + Kotlin.toString(this.version);
              }
              return this.key_cache;
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_deployUnit) {
                var objFound = this.deployUnit;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                var objFound_0 = this.dictionaryType;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                return this.findSuperTypesByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType);
                this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnit, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                this.internal_visit(visitor, this.deployUnit, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnit);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnit);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$0 = this._superTypes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._superTypes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.bean, _.org.kevoree.util.Constants.Att_bean, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.factoryBean, _.org.kevoree.util.Constants.Att_factoryBean, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_NodeType;
            }
          }),
          ParameterImpl: Kotlin.createClass([_c.Parameter, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$name = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$order = _.org.kevoree.util.Constants.INT_DEFAULTVAL;
            this.$type = null;
          }, /** @lends _.org.kevoree.impl.ParameterImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              this.type = null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name;
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path(), null));
                }
              }
            },
            order: {
              get: function () {
                return this.$order;
              },
              set: function (iP) {
                this.internal_order(iP, true);
              }
            },
            internal_order: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.order) {
                var oldPath = this.path();
                var kmf_previousVal = this.$order;
                this.$order = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_order, this.order, kmf_previousVal));
                }
              }
            },
            type: {
              get: function () {
                return this.$type;
              },
              set: function (typeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_type(typeP, true, true);
              }
            },
            internal_type: function (typeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$type, typeP)) {
                var kmf_previousVal = this.$type;
                this.$type = typeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_type, typeP, kmf_previousVal));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_order) {
                this.internal_order(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_type) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_type(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_type(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_type(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(this.name);
              }
              return this.key_cache;
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_type) {
                var objFound = this.type;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_type, _.org.kevoree.util.Constants.org_kevoree_TypedElement);
                this.internal_visit(visitor, this.type, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_type);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_type);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.order, _.org.kevoree.util.Constants.Att_order, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Parameter;
            }
          }),
          ComponentTypeImpl: Kotlin.createClass([_c.ComponentType, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$name = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$version = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$factoryBean = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$bean = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$abstract = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$dictionaryType = null;
            this._provided = new Kotlin.PrimitiveHashMap(0);
            this.removeAllProvidedCurrentlyProcessing = false;
            this.$deployUnit = null;
            this._required = new Kotlin.PrimitiveHashMap(0);
            this.removeAllRequiredCurrentlyProcessing = false;
            this._superTypes = new Kotlin.PrimitiveHashMap(0);
          }, /** @lends _.org.kevoree.impl.ComponentTypeImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              this.deployUnit = null;
              this.dictionaryType = null;
              var tmp$1, tmp$2, tmp$3;
              (tmp$1 = this._superTypes) != null ? tmp$1.clear() : null;
              (tmp$2 = this._required) != null ? tmp$2.clear() : null;
              (tmp$3 = this._provided) != null ? tmp$3.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name;
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path(), null));
                }
              }
            },
            version: {
              get: function () {
                return this.$version;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$version;
                this.$version = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_version, this.path(), null));
                }
              }
            },
            factoryBean: {
              get: function () {
                return this.$factoryBean;
              },
              set: function (iP) {
                this.internal_factoryBean(iP, true);
              }
            },
            internal_factoryBean: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.factoryBean)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$factoryBean;
                this.$factoryBean = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_factoryBean, this.factoryBean, kmf_previousVal));
                }
              }
            },
            bean: {
              get: function () {
                return this.$bean;
              },
              set: function (iP) {
                this.internal_bean(iP, true);
              }
            },
            internal_bean: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.bean)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$bean;
                this.$bean = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_bean, this.bean, kmf_previousVal));
                }
              }
            },
            abstract: {
              get: function () {
                return this.$abstract;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$abstract;
                this.$abstract = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract, kmf_previousVal));
                }
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType, dictionaryTypeP)) {
                if (this.$dictionaryType != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                var kmf_previousVal = this.$dictionaryType;
                this.$dictionaryType = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP, kmf_previousVal));
                }
              }
            },
            provided: {
              get: function () {
                return _.kotlin.toList(this._provided.values());
              },
              set: function (providedP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (providedP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_provided(providedP, true, true);
              }
            },
            internal_provided: function (providedP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._provided.values(), providedP)) {
                var kmf_previousVal = this._provided;
                this._provided.clear();
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._provided.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_provided, el), _.org.kevoree.util.Constants.Ref_provided);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP, kmf_previousVal));
                }
              }
            },
            doAddProvided: function (providedP) {
              var _key_ = (providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._provided.containsKey(_key_)) {
                this._provided.put(_key_, providedP);
                (providedP != null ? providedP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_provided, providedP), _.org.kevoree.util.Constants.Ref_provided);
              }
            },
            addProvided: function (providedP) {
              this.internal_addProvided(providedP, true, true);
            },
            addAllProvided: function (providedP) {
              this.internal_addAllProvided(providedP, true, true);
            },
            internal_addProvided: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddProvided(providedP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP, null));
              }
            },
            internal_addAllProvided: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddProvided(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = providedP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddProvided(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP, null));
              }
            },
            removeProvided: function (providedP) {
              this.internal_removeProvided(providedP, true, true);
            },
            removeAllProvided: function () {
              this.internal_removeAllProvided(true, true);
            },
            internal_removeProvided: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._provided.size() !== 0 && this._provided.containsKey((providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey())) {
                this._provided.remove((providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey());
                ((providedP != null ? providedP : Kotlin.throwNPE()) != null ? providedP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllProvidedCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP, null));
                }
              }
            },
            internal_removeAllProvided: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllProvidedCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.provided) != null ? tmp$0 : Kotlin.throwNPE();
              this._provided.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, temp_els, null));
                this.removeAllProvidedCurrentlyProcessing = false;
              }
            },
            deployUnit: {
              get: function () {
                return this.$deployUnit;
              },
              set: function (deployUnitP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_deployUnit(deployUnitP, true, true);
              }
            },
            internal_deployUnit: function (deployUnitP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$deployUnit, deployUnitP)) {
                var kmf_previousVal = this.$deployUnit;
                this.$deployUnit = deployUnitP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnit, deployUnitP, kmf_previousVal));
                }
              }
            },
            required: {
              get: function () {
                return _.kotlin.toList(this._required.values());
              },
              set: function (requiredP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (requiredP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_required(requiredP, true, true);
              }
            },
            internal_required: function (requiredP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._required.values(), requiredP)) {
                var kmf_previousVal = this._required;
                this._required.clear();
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._required.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_required, el), _.org.kevoree.util.Constants.Ref_required);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP, kmf_previousVal));
                }
              }
            },
            doAddRequired: function (requiredP) {
              var _key_ = (requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._required.containsKey(_key_)) {
                this._required.put(_key_, requiredP);
                (requiredP != null ? requiredP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_required, requiredP), _.org.kevoree.util.Constants.Ref_required);
              }
            },
            addRequired: function (requiredP) {
              this.internal_addRequired(requiredP, true, true);
            },
            addAllRequired: function (requiredP) {
              this.internal_addAllRequired(requiredP, true, true);
            },
            internal_addRequired: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddRequired(requiredP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP, null));
              }
            },
            internal_addAllRequired: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddRequired(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = requiredP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddRequired(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP, null));
              }
            },
            removeRequired: function (requiredP) {
              this.internal_removeRequired(requiredP, true, true);
            },
            removeAllRequired: function () {
              this.internal_removeAllRequired(true, true);
            },
            internal_removeRequired: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._required.size() !== 0 && this._required.containsKey((requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey())) {
                this._required.remove((requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey());
                ((requiredP != null ? requiredP : Kotlin.throwNPE()) != null ? requiredP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllRequiredCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP, null));
                }
              }
            },
            internal_removeAllRequired: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllRequiredCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.required) != null ? tmp$0 : Kotlin.throwNPE();
              this._required.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, temp_els, null));
                this.removeAllRequiredCurrentlyProcessing = false;
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                var kmf_previousVal = this._superTypes;
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, kmf_previousVal));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = (superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey(_key_)) {
                this._superTypes.put(_key_, superTypesP);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._superTypes.remove((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.superTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els, null));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_version) {
                this.internal_version(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_factoryBean) {
                this.internal_factoryBean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_bean) {
                this.internal_bean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnit) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_deployUnit(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_deployUnit(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_deployUnit(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_dictionaryType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllSuperTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._superTypes.size() !== 0 && this._superTypes.containsKey(value)) {
                    var obj = this._superTypes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._superTypes.remove(value);
                    this._superTypes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_required) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllRequired();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._required.size() !== 0 && this._required.containsKey(value)) {
                    var obj_0 = this._required.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._required.remove(value);
                    this._required.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_provided) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllProvided();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._provided.size() !== 0 && this._provided.containsKey(value)) {
                    var obj_1 = this._provided.get(value);
                    var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_1 == null) {
                      throw new Error('Key newed to null ' + obj_1);
                    }
                    this._provided.remove(value);
                    this._provided.put(objNewKey_1, obj_1);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(this.name) + '/' + Kotlin.toString(this.version);
              }
              return this.key_cache;
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get(key);
            },
            findRequiredByID: function (key) {
              return this._required.get(key);
            },
            findProvidedByID: function (key) {
              return this._provided.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_deployUnit) {
                var objFound = this.deployUnit;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                var objFound_0 = this.dictionaryType;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                return this.findSuperTypesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_required) {
                return this.findRequiredByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_provided) {
                return this.findProvidedByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType);
                this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_required, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef);
                {
                  var tmp$0 = this._required.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._required.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_required);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_required);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_provided, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef);
                {
                  var tmp$1 = this._provided.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._provided.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_provided);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_provided);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnit, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                this.internal_visit(visitor, this.deployUnit, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnit);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnit);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$2 = this._superTypes.keySet().iterator();
                  while (tmp$2.hasNext()) {
                    var KMFLoopEntryKey_1 = tmp$2.next();
                    this.internal_visit(visitor, this._superTypes.get(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.bean, _.org.kevoree.util.Constants.Att_bean, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.factoryBean, _.org.kevoree.util.Constants.Att_factoryBean, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ComponentType;
            }
          }),
          GroupImpl: Kotlin.createClass([_c.Group, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$name = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$metaData = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$started = true;
            this._subNodes = new Kotlin.PrimitiveHashMap(0);
            this._fragmentDictionary = new Kotlin.PrimitiveHashMap(0);
            this.removeAllFragmentDictionaryCurrentlyProcessing = false;
            this.$typeDefinition = null;
            this.$dictionary = null;
          }, /** @lends _.org.kevoree.impl.GroupImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              this.typeDefinition = null;
              this.dictionary = null;
              var tmp$1, tmp$2;
              (tmp$1 = this._fragmentDictionary) != null ? tmp$1.clear() : null;
              (tmp$2 = this._subNodes) != null ? tmp$2.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name;
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path(), null));
                }
              }
            },
            metaData: {
              get: function () {
                return this.$metaData;
              },
              set: function (iP) {
                this.internal_metaData(iP, true);
              }
            },
            internal_metaData: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.metaData)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$metaData;
                this.$metaData = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_metaData, this.metaData, kmf_previousVal));
                }
              }
            },
            started: {
              get: function () {
                return this.$started;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$started;
                this.$started = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started, kmf_previousVal));
                }
              }
            },
            subNodes: {
              get: function () {
                return _.kotlin.toList(this._subNodes.values());
              },
              set: function (subNodesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (subNodesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_subNodes(subNodesP, true, true);
              }
            },
            internal_subNodes: function (subNodesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._subNodes.values(), subNodesP)) {
                var kmf_previousVal = this._subNodes;
                this.internal_removeAllSubNodes(true, false);
                {
                  var tmp$0 = subNodesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._subNodes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.util.Constants.Ref_groups, this, false, fireEvents);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, subNodesP, kmf_previousVal));
                }
              }
            },
            doAddSubNodes: function (subNodesP) {
              var _key_ = (subNodesP != null ? subNodesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._subNodes.containsKey(_key_)) {
                this._subNodes.put(_key_, subNodesP);
              }
            },
            addSubNodes: function (subNodesP) {
              this.internal_addSubNodes(subNodesP, true, true);
            },
            addAllSubNodes: function (subNodesP) {
              this.internal_addAllSubNodes(subNodesP, true, true);
            },
            internal_addSubNodes: function (subNodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSubNodes(subNodesP);
              if (setOpposite) {
                (subNodesP != null ? subNodesP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.util.Constants.Ref_groups, this, false, fireEvents);
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, subNodesP, null));
              }
            },
            internal_addAllSubNodes: function (subNodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = subNodesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSubNodes(el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.util.Constants.Ref_groups, this, false, fireEvents);
                  }
                }
              }
               else {
                {
                  var tmp$1 = subNodesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSubNodes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, subNodesP, null));
              }
            },
            removeSubNodes: function (subNodesP) {
              this.internal_removeSubNodes(subNodesP, true, true);
            },
            removeAllSubNodes: function () {
              this.internal_removeAllSubNodes(true, true);
            },
            internal_removeSubNodes: function (subNodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._subNodes.size() !== 0 && this._subNodes.containsKey((subNodesP != null ? subNodesP : Kotlin.throwNPE()).internalGetKey())) {
                this._subNodes.remove((subNodesP != null ? subNodesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, subNodesP, null));
                }
                if (setOpposite) {
                  (subNodesP != null ? subNodesP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_groups, this, false, fireEvents);
                }
              }
            },
            internal_removeAllSubNodes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.subNodes) != null ? tmp$0 : Kotlin.throwNPE();
              if (setOpposite) {
                {
                  var tmp$1 = (temp_els != null ? temp_els : Kotlin.throwNPE()).iterator();
                  while (tmp$1.hasNext()) {
                    var el = tmp$1.next();
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_groups, this, false, fireEvents);
                  }
                }
              }
              this._subNodes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, temp_els, null));
              }
            },
            fragmentDictionary: {
              get: function () {
                return _.kotlin.toList(this._fragmentDictionary.values());
              },
              set: function (fragmentDictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (fragmentDictionaryP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_fragmentDictionary(fragmentDictionaryP, true, true);
              }
            },
            internal_fragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._fragmentDictionary.values(), fragmentDictionaryP)) {
                var kmf_previousVal = this._fragmentDictionary;
                this._fragmentDictionary.clear();
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._fragmentDictionary.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, el), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, kmf_previousVal));
                }
              }
            },
            doAddFragmentDictionary: function (fragmentDictionaryP) {
              var _key_ = (fragmentDictionaryP != null ? fragmentDictionaryP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._fragmentDictionary.containsKey(_key_)) {
                this._fragmentDictionary.put(_key_, fragmentDictionaryP);
                (fragmentDictionaryP != null ? fragmentDictionaryP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
              }
            },
            addFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addFragmentDictionary(fragmentDictionaryP, true, true);
            },
            addAllFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addAllFragmentDictionary(fragmentDictionaryP, true, true);
            },
            internal_addFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddFragmentDictionary(fragmentDictionaryP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null));
              }
            },
            internal_addAllFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddFragmentDictionary(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = fragmentDictionaryP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddFragmentDictionary(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null));
              }
            },
            removeFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_removeFragmentDictionary(fragmentDictionaryP, true, true);
            },
            removeAllFragmentDictionary: function () {
              this.internal_removeAllFragmentDictionary(true, true);
            },
            internal_removeFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey((fragmentDictionaryP != null ? fragmentDictionaryP : Kotlin.throwNPE()).internalGetKey())) {
                this._fragmentDictionary.remove((fragmentDictionaryP != null ? fragmentDictionaryP : Kotlin.throwNPE()).internalGetKey());
                ((fragmentDictionaryP != null ? fragmentDictionaryP : Kotlin.throwNPE()) != null ? fragmentDictionaryP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllFragmentDictionaryCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null));
                }
              }
            },
            internal_removeAllFragmentDictionary: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllFragmentDictionaryCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.fragmentDictionary) != null ? tmp$0 : Kotlin.throwNPE();
              this._fragmentDictionary.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, temp_els, null));
                this.removeAllFragmentDictionaryCurrentlyProcessing = false;
              }
            },
            typeDefinition: {
              get: function () {
                return this.$typeDefinition;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition, typeDefinitionP)) {
                var kmf_previousVal = this.$typeDefinition;
                this.$typeDefinition = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP, kmf_previousVal));
                }
              }
            },
            dictionary: {
              get: function () {
                return this.$dictionary;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary, dictionaryP)) {
                if (this.$dictionary != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionary) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                var kmf_previousVal = this.$dictionary;
                this.$dictionary = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP, kmf_previousVal));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_metaData) {
                this.internal_metaData(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_started) {
                this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_typeDefinition(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_dictionary(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllFragmentDictionary();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey(value)) {
                    var obj = this._fragmentDictionary.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._fragmentDictionary.remove(value);
                    this._fragmentDictionary.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_subNodes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addSubNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllSubNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeSubNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.internal_removeAllSubNodes(setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._subNodes.size() !== 0 && this._subNodes.containsKey(value)) {
                    var obj_0 = this._subNodes.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._subNodes.remove(value);
                    this._subNodes.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(this.name);
              }
              return this.key_cache;
            },
            findFragmentDictionaryByID: function (key) {
              return this._fragmentDictionary.get(key);
            },
            findSubNodesByID: function (key) {
              return this._subNodes.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                var objFound = this.typeDefinition;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                var objFound_0 = this.dictionary;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                return this.findFragmentDictionaryByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_subNodes) {
                return this.findSubNodesByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary);
                this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary, _.org.kevoree.util.Constants.org_kevoree_FragmentDictionary);
                {
                  var tmp$0 = this._fragmentDictionary.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._fragmentDictionary.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_subNodes, _.org.kevoree.util.Constants.org_kevoree_ContainerNode);
                {
                  var tmp$1 = this._subNodes.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._subNodes.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_subNodes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_subNodes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
              visitor.visit(this.metaData, _.org.kevoree.util.Constants.Att_metaData, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Group;
            }
          }),
          NodeLinkImpl: Kotlin.createClass([_c.NodeLink, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$networkType = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$estimatedRate = _.org.kevoree.util.Constants.INT_DEFAULTVAL;
            this.$lastCheck = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$zoneID = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$generated_KMF_ID = '' + Math.random() + (new Date()).getTime();
            this._networkProperties = new Kotlin.PrimitiveHashMap(0);
            this.removeAllNetworkPropertiesCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.NodeLinkImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              var tmp$1;
              (tmp$1 = this._networkProperties) != null ? tmp$1.clear() : null;
            },
            networkType: {
              get: function () {
                return this.$networkType;
              },
              set: function (iP) {
                this.internal_networkType(iP, true);
              }
            },
            internal_networkType: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.networkType)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$networkType;
                this.$networkType = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_networkType, this.networkType, kmf_previousVal));
                }
              }
            },
            estimatedRate: {
              get: function () {
                return this.$estimatedRate;
              },
              set: function (iP) {
                this.internal_estimatedRate(iP, true);
              }
            },
            internal_estimatedRate: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.estimatedRate) {
                var oldPath = this.path();
                var kmf_previousVal = this.$estimatedRate;
                this.$estimatedRate = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_estimatedRate, this.estimatedRate, kmf_previousVal));
                }
              }
            },
            lastCheck: {
              get: function () {
                return this.$lastCheck;
              },
              set: function (iP) {
                this.internal_lastCheck(iP, true);
              }
            },
            internal_lastCheck: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.lastCheck)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$lastCheck;
                this.$lastCheck = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_lastCheck, this.lastCheck, kmf_previousVal));
                }
              }
            },
            zoneID: {
              get: function () {
                return this.$zoneID;
              },
              set: function (iP) {
                this.internal_zoneID(iP, true);
              }
            },
            internal_zoneID: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.zoneID)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$zoneID;
                this.$zoneID = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_zoneID, this.zoneID, kmf_previousVal));
                }
              }
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$generated_KMF_ID;
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path(), null));
                }
              }
            },
            networkProperties: {
              get: function () {
                return _.kotlin.toList(this._networkProperties.values());
              },
              set: function (networkPropertiesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (networkPropertiesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_networkProperties(networkPropertiesP, true, true);
              }
            },
            internal_networkProperties: function (networkPropertiesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._networkProperties.values(), networkPropertiesP)) {
                var kmf_previousVal = this._networkProperties;
                this._networkProperties.clear();
                {
                  var tmp$0 = networkPropertiesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._networkProperties.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_networkProperties, el), _.org.kevoree.util.Constants.Ref_networkProperties);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkProperties, networkPropertiesP, kmf_previousVal));
                }
              }
            },
            doAddNetworkProperties: function (networkPropertiesP) {
              var _key_ = (networkPropertiesP != null ? networkPropertiesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._networkProperties.containsKey(_key_)) {
                this._networkProperties.put(_key_, networkPropertiesP);
                (networkPropertiesP != null ? networkPropertiesP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_networkProperties, networkPropertiesP), _.org.kevoree.util.Constants.Ref_networkProperties);
              }
            },
            addNetworkProperties: function (networkPropertiesP) {
              this.internal_addNetworkProperties(networkPropertiesP, true, true);
            },
            addAllNetworkProperties: function (networkPropertiesP) {
              this.internal_addAllNetworkProperties(networkPropertiesP, true, true);
            },
            internal_addNetworkProperties: function (networkPropertiesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddNetworkProperties(networkPropertiesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkProperties, networkPropertiesP, null));
              }
            },
            internal_addAllNetworkProperties: function (networkPropertiesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = networkPropertiesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddNetworkProperties(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = networkPropertiesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddNetworkProperties(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkProperties, networkPropertiesP, null));
              }
            },
            removeNetworkProperties: function (networkPropertiesP) {
              this.internal_removeNetworkProperties(networkPropertiesP, true, true);
            },
            removeAllNetworkProperties: function () {
              this.internal_removeAllNetworkProperties(true, true);
            },
            internal_removeNetworkProperties: function (networkPropertiesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._networkProperties.size() !== 0 && this._networkProperties.containsKey((networkPropertiesP != null ? networkPropertiesP : Kotlin.throwNPE()).internalGetKey())) {
                this._networkProperties.remove((networkPropertiesP != null ? networkPropertiesP : Kotlin.throwNPE()).internalGetKey());
                ((networkPropertiesP != null ? networkPropertiesP : Kotlin.throwNPE()) != null ? networkPropertiesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllNetworkPropertiesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkProperties, networkPropertiesP, null));
                }
              }
            },
            internal_removeAllNetworkProperties: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllNetworkPropertiesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.networkProperties) != null ? tmp$0 : Kotlin.throwNPE();
              this._networkProperties.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkProperties, temp_els, null));
                this.removeAllNetworkPropertiesCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_networkType) {
                this.internal_networkType(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_estimatedRate) {
                this.internal_estimatedRate(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_lastCheck) {
                this.internal_lastCheck(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_zoneID) {
                this.internal_zoneID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_networkProperties) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addNetworkProperties(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllNetworkProperties(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeNetworkProperties(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllNetworkProperties();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._networkProperties.size() !== 0 && this._networkProperties.containsKey(value)) {
                    var obj = this._networkProperties.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._networkProperties.remove(value);
                    this._networkProperties.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = this.generated_KMF_ID;
              }
              return this.key_cache;
            },
            findNetworkPropertiesByID: function (key) {
              return this._networkProperties.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_networkProperties) {
                return this.findNetworkPropertiesByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_networkProperties, _.org.kevoree.util.Constants.org_kevoree_NetworkProperty);
                {
                  var tmp$0 = this._networkProperties.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._networkProperties.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_networkProperties);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_networkProperties);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.estimatedRate, _.org.kevoree.util.Constants.Att_estimatedRate, this);
              visitor.visit(this.networkType, _.org.kevoree.util.Constants.Att_networkType, this);
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
              visitor.visit(this.lastCheck, _.org.kevoree.util.Constants.Att_lastCheck, this);
              visitor.visit(this.zoneID, _.org.kevoree.util.Constants.Att_zoneID, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_NodeLink;
            }
          }),
          ContainerRootImpl: Kotlin.createClass([_c.ContainerRoot, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$generated_KMF_ID = '' + Math.random() + (new Date()).getTime();
            this._libraries = new Kotlin.PrimitiveHashMap(0);
            this.removeAllLibrariesCurrentlyProcessing = false;
            this._mBindings = new Kotlin.PrimitiveHashMap(0);
            this.removeAllMBindingsCurrentlyProcessing = false;
            this._repositories = new Kotlin.PrimitiveHashMap(0);
            this.removeAllRepositoriesCurrentlyProcessing = false;
            this._nodeNetworks = new Kotlin.PrimitiveHashMap(0);
            this.removeAllNodeNetworksCurrentlyProcessing = false;
            this._typeDefinitions = new Kotlin.PrimitiveHashMap(0);
            this.removeAllTypeDefinitionsCurrentlyProcessing = false;
            this._nodes = new Kotlin.PrimitiveHashMap(0);
            this.removeAllNodesCurrentlyProcessing = false;
            this._dataTypes = new Kotlin.PrimitiveHashMap(0);
            this.removeAllDataTypesCurrentlyProcessing = false;
            this._deployUnits = new Kotlin.PrimitiveHashMap(0);
            this.removeAllDeployUnitsCurrentlyProcessing = false;
            this._groups = new Kotlin.PrimitiveHashMap(0);
            this.removeAllGroupsCurrentlyProcessing = false;
            this._hubs = new Kotlin.PrimitiveHashMap(0);
            this.removeAllHubsCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.ContainerRootImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              var tmp$1, tmp$2, tmp$3, tmp$4, tmp$5, tmp$6, tmp$7, tmp$8, tmp$9, tmp$10;
              (tmp$1 = this._nodes) != null ? tmp$1.clear() : null;
              (tmp$2 = this._typeDefinitions) != null ? tmp$2.clear() : null;
              (tmp$3 = this._repositories) != null ? tmp$3.clear() : null;
              (tmp$4 = this._dataTypes) != null ? tmp$4.clear() : null;
              (tmp$5 = this._libraries) != null ? tmp$5.clear() : null;
              (tmp$6 = this._hubs) != null ? tmp$6.clear() : null;
              (tmp$7 = this._mBindings) != null ? tmp$7.clear() : null;
              (tmp$8 = this._deployUnits) != null ? tmp$8.clear() : null;
              (tmp$9 = this._nodeNetworks) != null ? tmp$9.clear() : null;
              (tmp$10 = this._groups) != null ? tmp$10.clear() : null;
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$generated_KMF_ID;
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path(), null));
                }
              }
            },
            libraries: {
              get: function () {
                return _.kotlin.toList(this._libraries.values());
              },
              set: function (librariesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (librariesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_libraries(librariesP, true, true);
              }
            },
            internal_libraries: function (librariesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._libraries.values(), librariesP)) {
                var kmf_previousVal = this._libraries;
                this._libraries.clear();
                {
                  var tmp$0 = librariesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._libraries.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_libraries, el), _.org.kevoree.util.Constants.Ref_libraries);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_libraries, librariesP, kmf_previousVal));
                }
              }
            },
            doAddLibraries: function (librariesP) {
              var _key_ = (librariesP != null ? librariesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._libraries.containsKey(_key_)) {
                this._libraries.put(_key_, librariesP);
                (librariesP != null ? librariesP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_libraries, librariesP), _.org.kevoree.util.Constants.Ref_libraries);
              }
            },
            addLibraries: function (librariesP) {
              this.internal_addLibraries(librariesP, true, true);
            },
            addAllLibraries: function (librariesP) {
              this.internal_addAllLibraries(librariesP, true, true);
            },
            internal_addLibraries: function (librariesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddLibraries(librariesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_libraries, librariesP, null));
              }
            },
            internal_addAllLibraries: function (librariesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = librariesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddLibraries(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = librariesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddLibraries(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_libraries, librariesP, null));
              }
            },
            removeLibraries: function (librariesP) {
              this.internal_removeLibraries(librariesP, true, true);
            },
            removeAllLibraries: function () {
              this.internal_removeAllLibraries(true, true);
            },
            internal_removeLibraries: function (librariesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._libraries.size() !== 0 && this._libraries.containsKey((librariesP != null ? librariesP : Kotlin.throwNPE()).internalGetKey())) {
                this._libraries.remove((librariesP != null ? librariesP : Kotlin.throwNPE()).internalGetKey());
                ((librariesP != null ? librariesP : Kotlin.throwNPE()) != null ? librariesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllLibrariesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_libraries, librariesP, null));
                }
              }
            },
            internal_removeAllLibraries: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllLibrariesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.libraries) != null ? tmp$0 : Kotlin.throwNPE();
              this._libraries.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_libraries, temp_els, null));
                this.removeAllLibrariesCurrentlyProcessing = false;
              }
            },
            mBindings: {
              get: function () {
                return _.kotlin.toList(this._mBindings.values());
              },
              set: function (mBindingsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (mBindingsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_mBindings(mBindingsP, true, true);
              }
            },
            internal_mBindings: function (mBindingsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._mBindings.values(), mBindingsP)) {
                var kmf_previousVal = this._mBindings;
                this._mBindings.clear();
                {
                  var tmp$0 = mBindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._mBindings.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_mBindings, el), _.org.kevoree.util.Constants.Ref_mBindings);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP, kmf_previousVal));
                }
              }
            },
            doAddMBindings: function (mBindingsP) {
              var _key_ = (mBindingsP != null ? mBindingsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._mBindings.containsKey(_key_)) {
                this._mBindings.put(_key_, mBindingsP);
                (mBindingsP != null ? mBindingsP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP), _.org.kevoree.util.Constants.Ref_mBindings);
              }
            },
            addMBindings: function (mBindingsP) {
              this.internal_addMBindings(mBindingsP, true, true);
            },
            addAllMBindings: function (mBindingsP) {
              this.internal_addAllMBindings(mBindingsP, true, true);
            },
            internal_addMBindings: function (mBindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMBindings(mBindingsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP, null));
              }
            },
            internal_addAllMBindings: function (mBindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = mBindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMBindings(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = mBindingsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMBindings(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP, null));
              }
            },
            removeMBindings: function (mBindingsP) {
              this.internal_removeMBindings(mBindingsP, true, true);
            },
            removeAllMBindings: function () {
              this.internal_removeAllMBindings(true, true);
            },
            internal_removeMBindings: function (mBindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._mBindings.size() !== 0 && this._mBindings.containsKey((mBindingsP != null ? mBindingsP : Kotlin.throwNPE()).internalGetKey())) {
                this._mBindings.remove((mBindingsP != null ? mBindingsP : Kotlin.throwNPE()).internalGetKey());
                ((mBindingsP != null ? mBindingsP : Kotlin.throwNPE()) != null ? mBindingsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllMBindingsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP, null));
                }
              }
            },
            internal_removeAllMBindings: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMBindingsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.mBindings) != null ? tmp$0 : Kotlin.throwNPE();
              this._mBindings.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, temp_els, null));
                this.removeAllMBindingsCurrentlyProcessing = false;
              }
            },
            repositories: {
              get: function () {
                return _.kotlin.toList(this._repositories.values());
              },
              set: function (repositoriesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (repositoriesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_repositories(repositoriesP, true, true);
              }
            },
            internal_repositories: function (repositoriesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._repositories.values(), repositoriesP)) {
                var kmf_previousVal = this._repositories;
                this._repositories.clear();
                {
                  var tmp$0 = repositoriesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._repositories.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_repositories, el), _.org.kevoree.util.Constants.Ref_repositories);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP, kmf_previousVal));
                }
              }
            },
            doAddRepositories: function (repositoriesP) {
              var _key_ = (repositoriesP != null ? repositoriesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._repositories.containsKey(_key_)) {
                this._repositories.put(_key_, repositoriesP);
                (repositoriesP != null ? repositoriesP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP), _.org.kevoree.util.Constants.Ref_repositories);
              }
            },
            addRepositories: function (repositoriesP) {
              this.internal_addRepositories(repositoriesP, true, true);
            },
            addAllRepositories: function (repositoriesP) {
              this.internal_addAllRepositories(repositoriesP, true, true);
            },
            internal_addRepositories: function (repositoriesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddRepositories(repositoriesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP, null));
              }
            },
            internal_addAllRepositories: function (repositoriesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = repositoriesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddRepositories(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = repositoriesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddRepositories(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP, null));
              }
            },
            removeRepositories: function (repositoriesP) {
              this.internal_removeRepositories(repositoriesP, true, true);
            },
            removeAllRepositories: function () {
              this.internal_removeAllRepositories(true, true);
            },
            internal_removeRepositories: function (repositoriesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._repositories.size() !== 0 && this._repositories.containsKey((repositoriesP != null ? repositoriesP : Kotlin.throwNPE()).internalGetKey())) {
                this._repositories.remove((repositoriesP != null ? repositoriesP : Kotlin.throwNPE()).internalGetKey());
                ((repositoriesP != null ? repositoriesP : Kotlin.throwNPE()) != null ? repositoriesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllRepositoriesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP, null));
                }
              }
            },
            internal_removeAllRepositories: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllRepositoriesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.repositories) != null ? tmp$0 : Kotlin.throwNPE();
              this._repositories.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, temp_els, null));
                this.removeAllRepositoriesCurrentlyProcessing = false;
              }
            },
            nodeNetworks: {
              get: function () {
                return _.kotlin.toList(this._nodeNetworks.values());
              },
              set: function (nodeNetworksP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (nodeNetworksP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_nodeNetworks(nodeNetworksP, true, true);
              }
            },
            internal_nodeNetworks: function (nodeNetworksP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._nodeNetworks.values(), nodeNetworksP)) {
                var kmf_previousVal = this._nodeNetworks;
                this._nodeNetworks.clear();
                {
                  var tmp$0 = nodeNetworksP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._nodeNetworks.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_nodeNetworks, el), _.org.kevoree.util.Constants.Ref_nodeNetworks);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodeNetworks, nodeNetworksP, kmf_previousVal));
                }
              }
            },
            doAddNodeNetworks: function (nodeNetworksP) {
              var _key_ = (nodeNetworksP != null ? nodeNetworksP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._nodeNetworks.containsKey(_key_)) {
                this._nodeNetworks.put(_key_, nodeNetworksP);
                (nodeNetworksP != null ? nodeNetworksP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_nodeNetworks, nodeNetworksP), _.org.kevoree.util.Constants.Ref_nodeNetworks);
              }
            },
            addNodeNetworks: function (nodeNetworksP) {
              this.internal_addNodeNetworks(nodeNetworksP, true, true);
            },
            addAllNodeNetworks: function (nodeNetworksP) {
              this.internal_addAllNodeNetworks(nodeNetworksP, true, true);
            },
            internal_addNodeNetworks: function (nodeNetworksP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddNodeNetworks(nodeNetworksP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodeNetworks, nodeNetworksP, null));
              }
            },
            internal_addAllNodeNetworks: function (nodeNetworksP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = nodeNetworksP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddNodeNetworks(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = nodeNetworksP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddNodeNetworks(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodeNetworks, nodeNetworksP, null));
              }
            },
            removeNodeNetworks: function (nodeNetworksP) {
              this.internal_removeNodeNetworks(nodeNetworksP, true, true);
            },
            removeAllNodeNetworks: function () {
              this.internal_removeAllNodeNetworks(true, true);
            },
            internal_removeNodeNetworks: function (nodeNetworksP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._nodeNetworks.size() !== 0 && this._nodeNetworks.containsKey((nodeNetworksP != null ? nodeNetworksP : Kotlin.throwNPE()).internalGetKey())) {
                this._nodeNetworks.remove((nodeNetworksP != null ? nodeNetworksP : Kotlin.throwNPE()).internalGetKey());
                ((nodeNetworksP != null ? nodeNetworksP : Kotlin.throwNPE()) != null ? nodeNetworksP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllNodeNetworksCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodeNetworks, nodeNetworksP, null));
                }
              }
            },
            internal_removeAllNodeNetworks: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllNodeNetworksCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.nodeNetworks) != null ? tmp$0 : Kotlin.throwNPE();
              this._nodeNetworks.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodeNetworks, temp_els, null));
                this.removeAllNodeNetworksCurrentlyProcessing = false;
              }
            },
            typeDefinitions: {
              get: function () {
                return _.kotlin.toList(this._typeDefinitions.values());
              },
              set: function (typeDefinitionsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (typeDefinitionsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_typeDefinitions(typeDefinitionsP, true, true);
              }
            },
            internal_typeDefinitions: function (typeDefinitionsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._typeDefinitions.values(), typeDefinitionsP)) {
                var kmf_previousVal = this._typeDefinitions;
                this._typeDefinitions.clear();
                {
                  var tmp$0 = typeDefinitionsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._typeDefinitions.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_typeDefinitions, el), _.org.kevoree.util.Constants.Ref_typeDefinitions);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP, kmf_previousVal));
                }
              }
            },
            doAddTypeDefinitions: function (typeDefinitionsP) {
              var _key_ = (typeDefinitionsP != null ? typeDefinitionsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._typeDefinitions.containsKey(_key_)) {
                this._typeDefinitions.put(_key_, typeDefinitionsP);
                (typeDefinitionsP != null ? typeDefinitionsP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP), _.org.kevoree.util.Constants.Ref_typeDefinitions);
              }
            },
            addTypeDefinitions: function (typeDefinitionsP) {
              this.internal_addTypeDefinitions(typeDefinitionsP, true, true);
            },
            addAllTypeDefinitions: function (typeDefinitionsP) {
              this.internal_addAllTypeDefinitions(typeDefinitionsP, true, true);
            },
            internal_addTypeDefinitions: function (typeDefinitionsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddTypeDefinitions(typeDefinitionsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP, null));
              }
            },
            internal_addAllTypeDefinitions: function (typeDefinitionsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = typeDefinitionsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddTypeDefinitions(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = typeDefinitionsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddTypeDefinitions(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP, null));
              }
            },
            removeTypeDefinitions: function (typeDefinitionsP) {
              this.internal_removeTypeDefinitions(typeDefinitionsP, true, true);
            },
            removeAllTypeDefinitions: function () {
              this.internal_removeAllTypeDefinitions(true, true);
            },
            internal_removeTypeDefinitions: function (typeDefinitionsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._typeDefinitions.size() !== 0 && this._typeDefinitions.containsKey((typeDefinitionsP != null ? typeDefinitionsP : Kotlin.throwNPE()).internalGetKey())) {
                this._typeDefinitions.remove((typeDefinitionsP != null ? typeDefinitionsP : Kotlin.throwNPE()).internalGetKey());
                ((typeDefinitionsP != null ? typeDefinitionsP : Kotlin.throwNPE()) != null ? typeDefinitionsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllTypeDefinitionsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP, null));
                }
              }
            },
            internal_removeAllTypeDefinitions: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllTypeDefinitionsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.typeDefinitions) != null ? tmp$0 : Kotlin.throwNPE();
              this._typeDefinitions.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, temp_els, null));
                this.removeAllTypeDefinitionsCurrentlyProcessing = false;
              }
            },
            nodes: {
              get: function () {
                return _.kotlin.toList(this._nodes.values());
              },
              set: function (nodesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (nodesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_nodes(nodesP, true, true);
              }
            },
            internal_nodes: function (nodesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._nodes.values(), nodesP)) {
                var kmf_previousVal = this._nodes;
                this._nodes.clear();
                {
                  var tmp$0 = nodesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._nodes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_nodes, el), _.org.kevoree.util.Constants.Ref_nodes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, nodesP, kmf_previousVal));
                }
              }
            },
            doAddNodes: function (nodesP) {
              var _key_ = (nodesP != null ? nodesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._nodes.containsKey(_key_)) {
                this._nodes.put(_key_, nodesP);
                (nodesP != null ? nodesP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_nodes, nodesP), _.org.kevoree.util.Constants.Ref_nodes);
              }
            },
            addNodes: function (nodesP) {
              this.internal_addNodes(nodesP, true, true);
            },
            addAllNodes: function (nodesP) {
              this.internal_addAllNodes(nodesP, true, true);
            },
            internal_addNodes: function (nodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddNodes(nodesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, nodesP, null));
              }
            },
            internal_addAllNodes: function (nodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = nodesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddNodes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = nodesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddNodes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, nodesP, null));
              }
            },
            removeNodes: function (nodesP) {
              this.internal_removeNodes(nodesP, true, true);
            },
            removeAllNodes: function () {
              this.internal_removeAllNodes(true, true);
            },
            internal_removeNodes: function (nodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._nodes.size() !== 0 && this._nodes.containsKey((nodesP != null ? nodesP : Kotlin.throwNPE()).internalGetKey())) {
                this._nodes.remove((nodesP != null ? nodesP : Kotlin.throwNPE()).internalGetKey());
                ((nodesP != null ? nodesP : Kotlin.throwNPE()) != null ? nodesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllNodesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, nodesP, null));
                }
              }
            },
            internal_removeAllNodes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllNodesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.nodes) != null ? tmp$0 : Kotlin.throwNPE();
              this._nodes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, temp_els, null));
                this.removeAllNodesCurrentlyProcessing = false;
              }
            },
            dataTypes: {
              get: function () {
                return _.kotlin.toList(this._dataTypes.values());
              },
              set: function (dataTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (dataTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_dataTypes(dataTypesP, true, true);
              }
            },
            internal_dataTypes: function (dataTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._dataTypes.values(), dataTypesP)) {
                var kmf_previousVal = this._dataTypes;
                this._dataTypes.clear();
                {
                  var tmp$0 = dataTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._dataTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_dataTypes, el), _.org.kevoree.util.Constants.Ref_dataTypes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dataTypes, dataTypesP, kmf_previousVal));
                }
              }
            },
            doAddDataTypes: function (dataTypesP) {
              var _key_ = (dataTypesP != null ? dataTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._dataTypes.containsKey(_key_)) {
                this._dataTypes.put(_key_, dataTypesP);
                (dataTypesP != null ? dataTypesP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_dataTypes, dataTypesP), _.org.kevoree.util.Constants.Ref_dataTypes);
              }
            },
            addDataTypes: function (dataTypesP) {
              this.internal_addDataTypes(dataTypesP, true, true);
            },
            addAllDataTypes: function (dataTypesP) {
              this.internal_addAllDataTypes(dataTypesP, true, true);
            },
            internal_addDataTypes: function (dataTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDataTypes(dataTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dataTypes, dataTypesP, null));
              }
            },
            internal_addAllDataTypes: function (dataTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = dataTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDataTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = dataTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDataTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dataTypes, dataTypesP, null));
              }
            },
            removeDataTypes: function (dataTypesP) {
              this.internal_removeDataTypes(dataTypesP, true, true);
            },
            removeAllDataTypes: function () {
              this.internal_removeAllDataTypes(true, true);
            },
            internal_removeDataTypes: function (dataTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._dataTypes.size() !== 0 && this._dataTypes.containsKey((dataTypesP != null ? dataTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._dataTypes.remove((dataTypesP != null ? dataTypesP : Kotlin.throwNPE()).internalGetKey());
                ((dataTypesP != null ? dataTypesP : Kotlin.throwNPE()) != null ? dataTypesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllDataTypesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dataTypes, dataTypesP, null));
                }
              }
            },
            internal_removeAllDataTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllDataTypesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.dataTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._dataTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dataTypes, temp_els, null));
                this.removeAllDataTypesCurrentlyProcessing = false;
              }
            },
            deployUnits: {
              get: function () {
                return _.kotlin.toList(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                var kmf_previousVal = this._deployUnits;
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_deployUnits, el), _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, kmf_previousVal));
                }
              }
            },
            doAddDeployUnits: function (deployUnitsP) {
              var _key_ = (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey(_key_)) {
                this._deployUnits.put(_key_, deployUnitsP);
                (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP), _.org.kevoree.util.Constants.Ref_deployUnits);
              }
            },
            addDeployUnits: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
            },
            addAllDeployUnits: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
            },
            internal_addDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null));
              }
            },
            internal_addAllDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null));
              }
            },
            removeDeployUnits: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
            },
            removeAllDeployUnits: function () {
              this.internal_removeAllDeployUnits(true, true);
            },
            internal_removeDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey())) {
                this._deployUnits.remove((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey());
                ((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()) != null ? deployUnitsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllDeployUnitsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null));
                }
              }
            },
            internal_removeAllDeployUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllDeployUnitsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.deployUnits) != null ? tmp$0 : Kotlin.throwNPE();
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els, null));
                this.removeAllDeployUnitsCurrentlyProcessing = false;
              }
            },
            groups: {
              get: function () {
                return _.kotlin.toList(this._groups.values());
              },
              set: function (groupsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (groupsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_groups(groupsP, true, true);
              }
            },
            internal_groups: function (groupsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._groups.values(), groupsP)) {
                var kmf_previousVal = this._groups;
                this._groups.clear();
                {
                  var tmp$0 = groupsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._groups.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_groups, el), _.org.kevoree.util.Constants.Ref_groups);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, groupsP, kmf_previousVal));
                }
              }
            },
            doAddGroups: function (groupsP) {
              var _key_ = (groupsP != null ? groupsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._groups.containsKey(_key_)) {
                this._groups.put(_key_, groupsP);
                (groupsP != null ? groupsP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_groups, groupsP), _.org.kevoree.util.Constants.Ref_groups);
              }
            },
            addGroups: function (groupsP) {
              this.internal_addGroups(groupsP, true, true);
            },
            addAllGroups: function (groupsP) {
              this.internal_addAllGroups(groupsP, true, true);
            },
            internal_addGroups: function (groupsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddGroups(groupsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, groupsP, null));
              }
            },
            internal_addAllGroups: function (groupsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = groupsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddGroups(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = groupsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddGroups(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, groupsP, null));
              }
            },
            removeGroups: function (groupsP) {
              this.internal_removeGroups(groupsP, true, true);
            },
            removeAllGroups: function () {
              this.internal_removeAllGroups(true, true);
            },
            internal_removeGroups: function (groupsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._groups.size() !== 0 && this._groups.containsKey((groupsP != null ? groupsP : Kotlin.throwNPE()).internalGetKey())) {
                this._groups.remove((groupsP != null ? groupsP : Kotlin.throwNPE()).internalGetKey());
                ((groupsP != null ? groupsP : Kotlin.throwNPE()) != null ? groupsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllGroupsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, groupsP, null));
                }
              }
            },
            internal_removeAllGroups: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllGroupsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.groups) != null ? tmp$0 : Kotlin.throwNPE();
              this._groups.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, temp_els, null));
                this.removeAllGroupsCurrentlyProcessing = false;
              }
            },
            hubs: {
              get: function () {
                return _.kotlin.toList(this._hubs.values());
              },
              set: function (hubsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (hubsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_hubs(hubsP, true, true);
              }
            },
            internal_hubs: function (hubsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._hubs.values(), hubsP)) {
                var kmf_previousVal = this._hubs;
                this._hubs.clear();
                {
                  var tmp$0 = hubsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._hubs.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_hubs, el), _.org.kevoree.util.Constants.Ref_hubs);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, hubsP, kmf_previousVal));
                }
              }
            },
            doAddHubs: function (hubsP) {
              var _key_ = (hubsP != null ? hubsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._hubs.containsKey(_key_)) {
                this._hubs.put(_key_, hubsP);
                (hubsP != null ? hubsP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_hubs, hubsP), _.org.kevoree.util.Constants.Ref_hubs);
              }
            },
            addHubs: function (hubsP) {
              this.internal_addHubs(hubsP, true, true);
            },
            addAllHubs: function (hubsP) {
              this.internal_addAllHubs(hubsP, true, true);
            },
            internal_addHubs: function (hubsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddHubs(hubsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, hubsP, null));
              }
            },
            internal_addAllHubs: function (hubsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = hubsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddHubs(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = hubsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddHubs(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, hubsP, null));
              }
            },
            removeHubs: function (hubsP) {
              this.internal_removeHubs(hubsP, true, true);
            },
            removeAllHubs: function () {
              this.internal_removeAllHubs(true, true);
            },
            internal_removeHubs: function (hubsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._hubs.size() !== 0 && this._hubs.containsKey((hubsP != null ? hubsP : Kotlin.throwNPE()).internalGetKey())) {
                this._hubs.remove((hubsP != null ? hubsP : Kotlin.throwNPE()).internalGetKey());
                ((hubsP != null ? hubsP : Kotlin.throwNPE()) != null ? hubsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllHubsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, hubsP, null));
                }
              }
            },
            internal_removeAllHubs: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllHubsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.hubs) != null ? tmp$0 : Kotlin.throwNPE();
              this._hubs.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, temp_els, null));
                this.removeAllHubsCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_nodes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllNodes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._nodes.size() !== 0 && this._nodes.containsKey(value)) {
                    var obj = this._nodes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._nodes.remove(value);
                    this._nodes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinitions) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addTypeDefinitions(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllTypeDefinitions(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeTypeDefinitions(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllTypeDefinitions();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._typeDefinitions.size() !== 0 && this._typeDefinitions.containsKey(value)) {
                    var obj_0 = this._typeDefinitions.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._typeDefinitions.remove(value);
                    this._typeDefinitions.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_repositories) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addRepositories(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllRepositories(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeRepositories(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllRepositories();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._repositories.size() !== 0 && this._repositories.containsKey(value)) {
                    var obj_1 = this._repositories.get(value);
                    var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_1 == null) {
                      throw new Error('Key newed to null ' + obj_1);
                    }
                    this._repositories.remove(value);
                    this._repositories.put(objNewKey_1, obj_1);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dataTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addDataTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllDataTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeDataTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllDataTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._dataTypes.size() !== 0 && this._dataTypes.containsKey(value)) {
                    var obj_2 = this._dataTypes.get(value);
                    var objNewKey_2 = (obj_2 != null ? obj_2 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_2 == null) {
                      throw new Error('Key newed to null ' + obj_2);
                    }
                    this._dataTypes.remove(value);
                    this._dataTypes.put(objNewKey_2, obj_2);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_libraries) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addLibraries(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllLibraries(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeLibraries(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllLibraries();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._libraries.size() !== 0 && this._libraries.containsKey(value)) {
                    var obj_3 = this._libraries.get(value);
                    var objNewKey_3 = (obj_3 != null ? obj_3 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_3 == null) {
                      throw new Error('Key newed to null ' + obj_3);
                    }
                    this._libraries.remove(value);
                    this._libraries.put(objNewKey_3, obj_3);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_hubs) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addHubs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllHubs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeHubs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllHubs();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._hubs.size() !== 0 && this._hubs.containsKey(value)) {
                    var obj_4 = this._hubs.get(value);
                    var objNewKey_4 = (obj_4 != null ? obj_4 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_4 == null) {
                      throw new Error('Key newed to null ' + obj_4);
                    }
                    this._hubs.remove(value);
                    this._hubs.put(objNewKey_4, obj_4);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_mBindings) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addMBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllMBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeMBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllMBindings();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._mBindings.size() !== 0 && this._mBindings.containsKey(value)) {
                    var obj_5 = this._mBindings.get(value);
                    var objNewKey_5 = (obj_5 != null ? obj_5 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_5 == null) {
                      throw new Error('Key newed to null ' + obj_5);
                    }
                    this._mBindings.remove(value);
                    this._mBindings.put(objNewKey_5, obj_5);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllDeployUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey(value)) {
                    var obj_6 = this._deployUnits.get(value);
                    var objNewKey_6 = (obj_6 != null ? obj_6 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_6 == null) {
                      throw new Error('Key newed to null ' + obj_6);
                    }
                    this._deployUnits.remove(value);
                    this._deployUnits.put(objNewKey_6, obj_6);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_nodeNetworks) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addNodeNetworks(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllNodeNetworks(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeNodeNetworks(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllNodeNetworks();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._nodeNetworks.size() !== 0 && this._nodeNetworks.containsKey(value)) {
                    var obj_7 = this._nodeNetworks.get(value);
                    var objNewKey_7 = (obj_7 != null ? obj_7 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_7 == null) {
                      throw new Error('Key newed to null ' + obj_7);
                    }
                    this._nodeNetworks.remove(value);
                    this._nodeNetworks.put(objNewKey_7, obj_7);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_groups) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addGroups(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllGroups(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeGroups(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllGroups();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._groups.size() !== 0 && this._groups.containsKey(value)) {
                    var obj_8 = this._groups.get(value);
                    var objNewKey_8 = (obj_8 != null ? obj_8 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_8 == null) {
                      throw new Error('Key newed to null ' + obj_8);
                    }
                    this._groups.remove(value);
                    this._groups.put(objNewKey_8, obj_8);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = this.generated_KMF_ID;
              }
              return this.key_cache;
            },
            findNodesByID: function (key) {
              return this._nodes.get(key);
            },
            findTypeDefinitionsByID: function (key) {
              return this._typeDefinitions.get(key);
            },
            findRepositoriesByID: function (key) {
              return this._repositories.get(key);
            },
            findDataTypesByID: function (key) {
              return this._dataTypes.get(key);
            },
            findLibrariesByID: function (key) {
              return this._libraries.get(key);
            },
            findHubsByID: function (key) {
              return this._hubs.get(key);
            },
            findMBindingsByID: function (key) {
              return this._mBindings.get(key);
            },
            findDeployUnitsByID: function (key) {
              return this._deployUnits.get(key);
            },
            findNodeNetworksByID: function (key) {
              return this._nodeNetworks.get(key);
            },
            findGroupsByID: function (key) {
              return this._groups.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_nodes) {
                return this.findNodesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinitions) {
                return this.findTypeDefinitionsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_repositories) {
                return this.findRepositoriesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dataTypes) {
                return this.findDataTypesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_libraries) {
                return this.findLibrariesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_hubs) {
                return this.findHubsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_mBindings) {
                return this.findMBindingsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                return this.findDeployUnitsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_nodeNetworks) {
                return this.findNodeNetworksByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_groups) {
                return this.findGroupsByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_nodes, _.org.kevoree.util.Constants.org_kevoree_ContainerNode);
                {
                  var tmp$0 = this._nodes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._nodes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_nodes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_nodes);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinitions, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$1 = this._typeDefinitions.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._typeDefinitions.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinitions);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinitions);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_repositories, _.org.kevoree.util.Constants.org_kevoree_Repository);
                {
                  var tmp$2 = this._repositories.keySet().iterator();
                  while (tmp$2.hasNext()) {
                    var KMFLoopEntryKey_1 = tmp$2.next();
                    this.internal_visit(visitor, this._repositories.get(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_repositories);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_repositories);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dataTypes, _.org.kevoree.util.Constants.org_kevoree_TypedElement);
                {
                  var tmp$3 = this._dataTypes.keySet().iterator();
                  while (tmp$3.hasNext()) {
                    var KMFLoopEntryKey_2 = tmp$3.next();
                    this.internal_visit(visitor, this._dataTypes.get(KMFLoopEntryKey_2), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dataTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dataTypes);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_libraries, _.org.kevoree.util.Constants.org_kevoree_TypeLibrary);
                {
                  var tmp$4 = this._libraries.keySet().iterator();
                  while (tmp$4.hasNext()) {
                    var KMFLoopEntryKey_3 = tmp$4.next();
                    this.internal_visit(visitor, this._libraries.get(KMFLoopEntryKey_3), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_libraries);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_libraries);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_hubs, _.org.kevoree.util.Constants.org_kevoree_Channel);
                {
                  var tmp$5 = this._hubs.keySet().iterator();
                  while (tmp$5.hasNext()) {
                    var KMFLoopEntryKey_4 = tmp$5.next();
                    this.internal_visit(visitor, this._hubs.get(KMFLoopEntryKey_4), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_hubs);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_hubs);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_mBindings, _.org.kevoree.util.Constants.org_kevoree_MBinding);
                {
                  var tmp$6 = this._mBindings.keySet().iterator();
                  while (tmp$6.hasNext()) {
                    var KMFLoopEntryKey_5 = tmp$6.next();
                    this.internal_visit(visitor, this._mBindings.get(KMFLoopEntryKey_5), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_mBindings);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_mBindings);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$7 = this._deployUnits.keySet().iterator();
                  while (tmp$7.hasNext()) {
                    var KMFLoopEntryKey_6 = tmp$7.next();
                    this.internal_visit(visitor, this._deployUnits.get(KMFLoopEntryKey_6), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_nodeNetworks, _.org.kevoree.util.Constants.org_kevoree_NodeNetwork);
                {
                  var tmp$8 = this._nodeNetworks.keySet().iterator();
                  while (tmp$8.hasNext()) {
                    var KMFLoopEntryKey_7 = tmp$8.next();
                    this.internal_visit(visitor, this._nodeNetworks.get(KMFLoopEntryKey_7), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_nodeNetworks);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_nodeNetworks);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_groups, _.org.kevoree.util.Constants.org_kevoree_Group);
                {
                  var tmp$9 = this._groups.keySet().iterator();
                  while (tmp$9.hasNext()) {
                    var KMFLoopEntryKey_8 = tmp$9.next();
                    this.internal_visit(visitor, this._groups.get(KMFLoopEntryKey_8), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_groups);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_groups);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ContainerRoot;
            }
          }),
          NamespaceImpl: Kotlin.createClass([_c.Namespace, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$name = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this._elements = new Kotlin.PrimitiveHashMap(0);
          }, /** @lends _.org.kevoree.impl.NamespaceImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              var tmp$1;
              (tmp$1 = this._elements) != null ? tmp$1.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name;
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path(), null));
                }
              }
            },
            elements: {
              get: function () {
                return _.kotlin.toList(this._elements.values());
              },
              set: function (elementsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (elementsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_elements(elementsP, true, true);
              }
            },
            internal_elements: function (elementsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._elements.values(), elementsP)) {
                var kmf_previousVal = this._elements;
                this._elements.clear();
                {
                  var tmp$0 = elementsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._elements.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_elements, elementsP, kmf_previousVal));
                }
              }
            },
            doAddElements: function (elementsP) {
              var _key_ = (elementsP != null ? elementsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._elements.containsKey(_key_)) {
                this._elements.put(_key_, elementsP);
              }
            },
            addElements: function (elementsP) {
              this.internal_addElements(elementsP, true, true);
            },
            addAllElements: function (elementsP) {
              this.internal_addAllElements(elementsP, true, true);
            },
            internal_addElements: function (elementsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddElements(elementsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_elements, elementsP, null));
              }
            },
            internal_addAllElements: function (elementsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = elementsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddElements(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = elementsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddElements(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_elements, elementsP, null));
              }
            },
            removeElements: function (elementsP) {
              this.internal_removeElements(elementsP, true, true);
            },
            removeAllElements: function () {
              this.internal_removeAllElements(true, true);
            },
            internal_removeElements: function (elementsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._elements.size() !== 0 && this._elements.containsKey((elementsP != null ? elementsP : Kotlin.throwNPE()).internalGetKey())) {
                this._elements.remove((elementsP != null ? elementsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_elements, elementsP, null));
                }
              }
            },
            internal_removeAllElements: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.elements) != null ? tmp$0 : Kotlin.throwNPE();
              this._elements.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_elements, temp_els, null));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_elements) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addElements(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllElements(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeElements(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllElements();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._elements.size() !== 0 && this._elements.containsKey(value)) {
                    var obj = this._elements.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._elements.remove(value);
                    this._elements.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(this.name);
              }
              return this.key_cache;
            },
            findElementsByID: function (key) {
              return this._elements.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_elements) {
                return this.findElementsByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_elements, _.org.kevoree.util.Constants.org_kevoree_Instance);
                {
                  var tmp$0 = this._elements.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._elements.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_elements);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_elements);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Namespace;
            }
          }),
          MessagePortTypeImpl: Kotlin.createClass([_c.MessagePortType, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$name = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$version = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$factoryBean = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$bean = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$abstract = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$synchrone = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$dictionaryType = null;
            this.$deployUnit = null;
            this._superTypes = new Kotlin.PrimitiveHashMap(0);
            this._filters = new Kotlin.PrimitiveHashMap(0);
          }, /** @lends _.org.kevoree.impl.MessagePortTypeImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              this.deployUnit = null;
              this.dictionaryType = null;
              var tmp$1, tmp$2;
              (tmp$1 = this._superTypes) != null ? tmp$1.clear() : null;
              (tmp$2 = this._filters) != null ? tmp$2.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name;
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path(), null));
                }
              }
            },
            version: {
              get: function () {
                return this.$version;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$version;
                this.$version = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_version, this.path(), null));
                }
              }
            },
            factoryBean: {
              get: function () {
                return this.$factoryBean;
              },
              set: function (iP) {
                this.internal_factoryBean(iP, true);
              }
            },
            internal_factoryBean: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.factoryBean)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$factoryBean;
                this.$factoryBean = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_factoryBean, this.factoryBean, kmf_previousVal));
                }
              }
            },
            bean: {
              get: function () {
                return this.$bean;
              },
              set: function (iP) {
                this.internal_bean(iP, true);
              }
            },
            internal_bean: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.bean)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$bean;
                this.$bean = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_bean, this.bean, kmf_previousVal));
                }
              }
            },
            abstract: {
              get: function () {
                return this.$abstract;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$abstract;
                this.$abstract = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract, kmf_previousVal));
                }
              }
            },
            synchrone: {
              get: function () {
                return this.$synchrone;
              },
              set: function (iP) {
                this.internal_synchrone(iP, true);
              }
            },
            internal_synchrone: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.synchrone)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$synchrone;
                this.$synchrone = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_synchrone, this.synchrone, kmf_previousVal));
                }
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType, dictionaryTypeP)) {
                if (this.$dictionaryType != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                var kmf_previousVal = this.$dictionaryType;
                this.$dictionaryType = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP, kmf_previousVal));
                }
              }
            },
            deployUnit: {
              get: function () {
                return this.$deployUnit;
              },
              set: function (deployUnitP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_deployUnit(deployUnitP, true, true);
              }
            },
            internal_deployUnit: function (deployUnitP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$deployUnit, deployUnitP)) {
                var kmf_previousVal = this.$deployUnit;
                this.$deployUnit = deployUnitP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnit, deployUnitP, kmf_previousVal));
                }
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                var kmf_previousVal = this._superTypes;
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, kmf_previousVal));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = (superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey(_key_)) {
                this._superTypes.put(_key_, superTypesP);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._superTypes.remove((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.superTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els, null));
              }
            },
            filters: {
              get: function () {
                return _.kotlin.toList(this._filters.values());
              },
              set: function (filtersP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (filtersP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_filters(filtersP, true, true);
              }
            },
            internal_filters: function (filtersP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._filters.values(), filtersP)) {
                var kmf_previousVal = this._filters;
                this._filters.clear();
                {
                  var tmp$0 = filtersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._filters.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, filtersP, kmf_previousVal));
                }
              }
            },
            doAddFilters: function (filtersP) {
              var _key_ = (filtersP != null ? filtersP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._filters.containsKey(_key_)) {
                this._filters.put(_key_, filtersP);
              }
            },
            addFilters: function (filtersP) {
              this.internal_addFilters(filtersP, true, true);
            },
            addAllFilters: function (filtersP) {
              this.internal_addAllFilters(filtersP, true, true);
            },
            internal_addFilters: function (filtersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddFilters(filtersP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, filtersP, null));
              }
            },
            internal_addAllFilters: function (filtersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = filtersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddFilters(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = filtersP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddFilters(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, filtersP, null));
              }
            },
            removeFilters: function (filtersP) {
              this.internal_removeFilters(filtersP, true, true);
            },
            removeAllFilters: function () {
              this.internal_removeAllFilters(true, true);
            },
            internal_removeFilters: function (filtersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._filters.size() !== 0 && this._filters.containsKey((filtersP != null ? filtersP : Kotlin.throwNPE()).internalGetKey())) {
                this._filters.remove((filtersP != null ? filtersP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, filtersP, null));
                }
              }
            },
            internal_removeAllFilters: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.filters) != null ? tmp$0 : Kotlin.throwNPE();
              this._filters.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, temp_els, null));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_version) {
                this.internal_version(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_factoryBean) {
                this.internal_factoryBean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_bean) {
                this.internal_bean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_synchrone) {
                this.internal_synchrone(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnit) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_deployUnit(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_deployUnit(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_deployUnit(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_dictionaryType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllSuperTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._superTypes.size() !== 0 && this._superTypes.containsKey(value)) {
                    var obj = this._superTypes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._superTypes.remove(value);
                    this._superTypes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_filters) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addFilters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllFilters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeFilters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllFilters();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._filters.size() !== 0 && this._filters.containsKey(value)) {
                    var obj_0 = this._filters.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._filters.remove(value);
                    this._filters.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(this.name) + '/' + Kotlin.toString(this.version);
              }
              return this.key_cache;
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get(key);
            },
            findFiltersByID: function (key) {
              return this._filters.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_deployUnit) {
                var objFound = this.deployUnit;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                var objFound_0 = this.dictionaryType;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                return this.findSuperTypesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_filters) {
                return this.findFiltersByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType);
                this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnit, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                this.internal_visit(visitor, this.deployUnit, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnit);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnit);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$0 = this._superTypes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._superTypes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_filters, _.org.kevoree.util.Constants.org_kevoree_TypedElement);
                {
                  var tmp$1 = this._filters.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._filters.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_filters);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_filters);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.synchrone, _.org.kevoree.util.Constants.Att_synchrone, this);
              visitor.visit(this.bean, _.org.kevoree.util.Constants.Att_bean, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.factoryBean, _.org.kevoree.util.Constants.Att_factoryBean, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_MessagePortType;
            }
          }),
          OperationImpl: Kotlin.createClass([_c.Operation, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$name = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this._parameters = new Kotlin.PrimitiveHashMap(0);
            this.removeAllParametersCurrentlyProcessing = false;
            this.$returnType = null;
          }, /** @lends _.org.kevoree.impl.OperationImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              var tmp$1;
              (tmp$1 = this._parameters) != null ? tmp$1.clear() : null;
              this.returnType = null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name;
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path(), null));
                }
              }
            },
            parameters: {
              get: function () {
                return _.kotlin.toList(this._parameters.values());
              },
              set: function (parametersP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (parametersP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_parameters(parametersP, true, true);
              }
            },
            internal_parameters: function (parametersP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._parameters.values(), parametersP)) {
                var kmf_previousVal = this._parameters;
                this._parameters.clear();
                {
                  var tmp$0 = parametersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._parameters.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_parameters, el), _.org.kevoree.util.Constants.Ref_parameters);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, parametersP, kmf_previousVal));
                }
              }
            },
            doAddParameters: function (parametersP) {
              var _key_ = (parametersP != null ? parametersP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._parameters.containsKey(_key_)) {
                this._parameters.put(_key_, parametersP);
                (parametersP != null ? parametersP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_parameters, parametersP), _.org.kevoree.util.Constants.Ref_parameters);
              }
            },
            addParameters: function (parametersP) {
              this.internal_addParameters(parametersP, true, true);
            },
            addAllParameters: function (parametersP) {
              this.internal_addAllParameters(parametersP, true, true);
            },
            internal_addParameters: function (parametersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddParameters(parametersP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, parametersP, null));
              }
            },
            internal_addAllParameters: function (parametersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = parametersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddParameters(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = parametersP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddParameters(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, parametersP, null));
              }
            },
            removeParameters: function (parametersP) {
              this.internal_removeParameters(parametersP, true, true);
            },
            removeAllParameters: function () {
              this.internal_removeAllParameters(true, true);
            },
            internal_removeParameters: function (parametersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._parameters.size() !== 0 && this._parameters.containsKey((parametersP != null ? parametersP : Kotlin.throwNPE()).internalGetKey())) {
                this._parameters.remove((parametersP != null ? parametersP : Kotlin.throwNPE()).internalGetKey());
                ((parametersP != null ? parametersP : Kotlin.throwNPE()) != null ? parametersP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllParametersCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, parametersP, null));
                }
              }
            },
            internal_removeAllParameters: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllParametersCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.parameters) != null ? tmp$0 : Kotlin.throwNPE();
              this._parameters.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, temp_els, null));
                this.removeAllParametersCurrentlyProcessing = false;
              }
            },
            returnType: {
              get: function () {
                return this.$returnType;
              },
              set: function (returnTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_returnType(returnTypeP, true, true);
              }
            },
            internal_returnType: function (returnTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$returnType, returnTypeP)) {
                var kmf_previousVal = this.$returnType;
                this.$returnType = returnTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_returnType, returnTypeP, kmf_previousVal));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_parameters) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addParameters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllParameters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeParameters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllParameters();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._parameters.size() !== 0 && this._parameters.containsKey(value)) {
                    var obj = this._parameters.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._parameters.remove(value);
                    this._parameters.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_returnType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_returnType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_returnType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_returnType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(this.name);
              }
              return this.key_cache;
            },
            findParametersByID: function (key) {
              return this._parameters.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_parameters) {
                return this.findParametersByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_returnType) {
                var objFound = this.returnType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_parameters, _.org.kevoree.util.Constants.org_kevoree_Parameter);
                {
                  var tmp$0 = this._parameters.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._parameters.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_parameters);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_parameters);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_returnType, _.org.kevoree.util.Constants.org_kevoree_TypedElement);
                this.internal_visit(visitor, this.returnType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_returnType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_returnType);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Operation;
            }
          }),
          ChannelImpl: Kotlin.createClass([_c.Channel, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$name = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$metaData = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$started = true;
            this._bindings = new Kotlin.PrimitiveHashMap(0);
            this._fragmentDictionary = new Kotlin.PrimitiveHashMap(0);
            this.removeAllFragmentDictionaryCurrentlyProcessing = false;
            this.$typeDefinition = null;
            this.$dictionary = null;
          }, /** @lends _.org.kevoree.impl.ChannelImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              this.typeDefinition = null;
              this.dictionary = null;
              var tmp$1, tmp$2;
              (tmp$1 = this._fragmentDictionary) != null ? tmp$1.clear() : null;
              (tmp$2 = this._bindings) != null ? tmp$2.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name;
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path(), null));
                }
              }
            },
            metaData: {
              get: function () {
                return this.$metaData;
              },
              set: function (iP) {
                this.internal_metaData(iP, true);
              }
            },
            internal_metaData: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.metaData)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$metaData;
                this.$metaData = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_metaData, this.metaData, kmf_previousVal));
                }
              }
            },
            started: {
              get: function () {
                return this.$started;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$started;
                this.$started = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started, kmf_previousVal));
                }
              }
            },
            bindings: {
              get: function () {
                return _.kotlin.toList(this._bindings.values());
              },
              set: function (bindingsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (bindingsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_bindings(bindingsP, true, true);
              }
            },
            internal_bindings: function (bindingsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._bindings.values(), bindingsP)) {
                var kmf_previousVal = this._bindings;
                this.internal_removeAllBindings(true, false);
                {
                  var tmp$0 = bindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._bindings.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_hub, this, false, fireEvents);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP, kmf_previousVal));
                }
              }
            },
            doAddBindings: function (bindingsP) {
              var _key_ = (bindingsP != null ? bindingsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._bindings.containsKey(_key_)) {
                this._bindings.put(_key_, bindingsP);
              }
            },
            addBindings: function (bindingsP) {
              this.internal_addBindings(bindingsP, true, true);
            },
            addAllBindings: function (bindingsP) {
              this.internal_addAllBindings(bindingsP, true, true);
            },
            internal_addBindings: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddBindings(bindingsP);
              if (setOpposite) {
                (bindingsP != null ? bindingsP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_hub, this, false, fireEvents);
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP, null));
              }
            },
            internal_addAllBindings: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = bindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddBindings(el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_hub, this, false, fireEvents);
                  }
                }
              }
               else {
                {
                  var tmp$1 = bindingsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddBindings(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP, null));
              }
            },
            removeBindings: function (bindingsP) {
              this.internal_removeBindings(bindingsP, true, true);
            },
            removeAllBindings: function () {
              this.internal_removeAllBindings(true, true);
            },
            internal_removeBindings: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._bindings.size() !== 0 && this._bindings.containsKey((bindingsP != null ? bindingsP : Kotlin.throwNPE()).internalGetKey())) {
                this._bindings.remove((bindingsP != null ? bindingsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP, null));
                }
                if (setOpposite) {
                  (bindingsP != null ? bindingsP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_hub, null, false, fireEvents);
                }
              }
            },
            internal_removeAllBindings: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.bindings) != null ? tmp$0 : Kotlin.throwNPE();
              if (setOpposite) {
                {
                  var tmp$1 = (temp_els != null ? temp_els : Kotlin.throwNPE()).iterator();
                  while (tmp$1.hasNext()) {
                    var el = tmp$1.next();
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_hub, null, false, fireEvents);
                  }
                }
              }
              this._bindings.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, temp_els, null));
              }
            },
            fragmentDictionary: {
              get: function () {
                return _.kotlin.toList(this._fragmentDictionary.values());
              },
              set: function (fragmentDictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (fragmentDictionaryP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_fragmentDictionary(fragmentDictionaryP, true, true);
              }
            },
            internal_fragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._fragmentDictionary.values(), fragmentDictionaryP)) {
                var kmf_previousVal = this._fragmentDictionary;
                this._fragmentDictionary.clear();
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._fragmentDictionary.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, el), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, kmf_previousVal));
                }
              }
            },
            doAddFragmentDictionary: function (fragmentDictionaryP) {
              var _key_ = (fragmentDictionaryP != null ? fragmentDictionaryP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._fragmentDictionary.containsKey(_key_)) {
                this._fragmentDictionary.put(_key_, fragmentDictionaryP);
                (fragmentDictionaryP != null ? fragmentDictionaryP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
              }
            },
            addFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addFragmentDictionary(fragmentDictionaryP, true, true);
            },
            addAllFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addAllFragmentDictionary(fragmentDictionaryP, true, true);
            },
            internal_addFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddFragmentDictionary(fragmentDictionaryP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null));
              }
            },
            internal_addAllFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddFragmentDictionary(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = fragmentDictionaryP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddFragmentDictionary(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null));
              }
            },
            removeFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_removeFragmentDictionary(fragmentDictionaryP, true, true);
            },
            removeAllFragmentDictionary: function () {
              this.internal_removeAllFragmentDictionary(true, true);
            },
            internal_removeFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey((fragmentDictionaryP != null ? fragmentDictionaryP : Kotlin.throwNPE()).internalGetKey())) {
                this._fragmentDictionary.remove((fragmentDictionaryP != null ? fragmentDictionaryP : Kotlin.throwNPE()).internalGetKey());
                ((fragmentDictionaryP != null ? fragmentDictionaryP : Kotlin.throwNPE()) != null ? fragmentDictionaryP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllFragmentDictionaryCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null));
                }
              }
            },
            internal_removeAllFragmentDictionary: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllFragmentDictionaryCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.fragmentDictionary) != null ? tmp$0 : Kotlin.throwNPE();
              this._fragmentDictionary.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, temp_els, null));
                this.removeAllFragmentDictionaryCurrentlyProcessing = false;
              }
            },
            typeDefinition: {
              get: function () {
                return this.$typeDefinition;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition, typeDefinitionP)) {
                var kmf_previousVal = this.$typeDefinition;
                this.$typeDefinition = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP, kmf_previousVal));
                }
              }
            },
            dictionary: {
              get: function () {
                return this.$dictionary;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary, dictionaryP)) {
                if (this.$dictionary != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionary) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                var kmf_previousVal = this.$dictionary;
                this.$dictionary = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP, kmf_previousVal));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_metaData) {
                this.internal_metaData(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_started) {
                this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_typeDefinition(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_dictionary(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllFragmentDictionary();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey(value)) {
                    var obj = this._fragmentDictionary.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._fragmentDictionary.remove(value);
                    this._fragmentDictionary.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_bindings) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.internal_removeAllBindings(setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._bindings.size() !== 0 && this._bindings.containsKey(value)) {
                    var obj_0 = this._bindings.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._bindings.remove(value);
                    this._bindings.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(this.name);
              }
              return this.key_cache;
            },
            findFragmentDictionaryByID: function (key) {
              return this._fragmentDictionary.get(key);
            },
            findBindingsByID: function (key) {
              return this._bindings.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                var objFound = this.typeDefinition;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                var objFound_0 = this.dictionary;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                return this.findFragmentDictionaryByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_bindings) {
                return this.findBindingsByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary);
                this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary, _.org.kevoree.util.Constants.org_kevoree_FragmentDictionary);
                {
                  var tmp$0 = this._fragmentDictionary.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._fragmentDictionary.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_bindings, _.org.kevoree.util.Constants.org_kevoree_MBinding);
                {
                  var tmp$1 = this._bindings.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._bindings.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_bindings);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_bindings);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
              visitor.visit(this.metaData, _.org.kevoree.util.Constants.Att_metaData, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Channel;
            }
          }),
          DefaultKevoreeFactory: Kotlin.createClass(_c.KevoreeFactory, null, /** @lends _.org.kevoree.impl.DefaultKevoreeFactory.prototype */ {
            getVersion: function () {
              return '2.0.12-SNAPSHOT';
            },
            createComponentInstance: function () {
              return new _.org.kevoree.impl.ComponentInstanceImpl();
            },
            createComponentType: function () {
              return new _.org.kevoree.impl.ComponentTypeImpl();
            },
            createContainerNode: function () {
              return new _.org.kevoree.impl.ContainerNodeImpl();
            },
            createContainerRoot: function () {
              return new _.org.kevoree.impl.ContainerRootImpl();
            },
            createPort: function () {
              return new _.org.kevoree.impl.PortImpl();
            },
            createNamespace: function () {
              return new _.org.kevoree.impl.NamespaceImpl();
            },
            createDictionary: function () {
              return new _.org.kevoree.impl.DictionaryImpl();
            },
            createFragmentDictionary: function () {
              return new _.org.kevoree.impl.FragmentDictionaryImpl();
            },
            createDictionaryType: function () {
              return new _.org.kevoree.impl.DictionaryTypeImpl();
            },
            createDictionaryAttribute: function () {
              return new _.org.kevoree.impl.DictionaryAttributeImpl();
            },
            createDictionaryValue: function () {
              return new _.org.kevoree.impl.DictionaryValueImpl();
            },
            createPortTypeRef: function () {
              return new _.org.kevoree.impl.PortTypeRefImpl();
            },
            createServicePortType: function () {
              return new _.org.kevoree.impl.ServicePortTypeImpl();
            },
            createOperation: function () {
              return new _.org.kevoree.impl.OperationImpl();
            },
            createParameter: function () {
              return new _.org.kevoree.impl.ParameterImpl();
            },
            createTypedElement: function () {
              return new _.org.kevoree.impl.TypedElementImpl();
            },
            createMessagePortType: function () {
              return new _.org.kevoree.impl.MessagePortTypeImpl();
            },
            createRepository: function () {
              return new _.org.kevoree.impl.RepositoryImpl();
            },
            createDeployUnit: function () {
              return new _.org.kevoree.impl.DeployUnitImpl();
            },
            createTypeLibrary: function () {
              return new _.org.kevoree.impl.TypeLibraryImpl();
            },
            createPortTypeMapping: function () {
              return new _.org.kevoree.impl.PortTypeMappingImpl();
            },
            createChannel: function () {
              return new _.org.kevoree.impl.ChannelImpl();
            },
            createMBinding: function () {
              return new _.org.kevoree.impl.MBindingImpl();
            },
            createNodeNetwork: function () {
              return new _.org.kevoree.impl.NodeNetworkImpl();
            },
            createNodeLink: function () {
              return new _.org.kevoree.impl.NodeLinkImpl();
            },
            createNetworkInfo: function () {
              return new _.org.kevoree.impl.NetworkInfoImpl();
            },
            createNetworkProperty: function () {
              return new _.org.kevoree.impl.NetworkPropertyImpl();
            },
            createChannelType: function () {
              return new _.org.kevoree.impl.ChannelTypeImpl();
            },
            createInstance: function () {
              return new _.org.kevoree.impl.InstanceImpl();
            },
            createGroup: function () {
              return new _.org.kevoree.impl.GroupImpl();
            },
            createGroupType: function () {
              return new _.org.kevoree.impl.GroupTypeImpl();
            },
            createNodeType: function () {
              return new _.org.kevoree.impl.NodeTypeImpl();
            },
            create: function (metaClassName) {
              if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ComponentInstance) {
                return this.createComponentInstance();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_ComponentInstance) {
                return this.createComponentInstance();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ComponentType) {
                return this.createComponentType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_ComponentType) {
                return this.createComponentType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ContainerNode) {
                return this.createContainerNode();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_ContainerNode) {
                return this.createContainerNode();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ContainerRoot) {
                return this.createContainerRoot();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_ContainerRoot) {
                return this.createContainerRoot();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Port) {
                return this.createPort();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Port) {
                return this.createPort();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Namespace) {
                return this.createNamespace();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Namespace) {
                return this.createNamespace();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Dictionary) {
                return this.createDictionary();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Dictionary) {
                return this.createDictionary();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_FragmentDictionary) {
                return this.createFragmentDictionary();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_FragmentDictionary) {
                return this.createFragmentDictionary();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_DictionaryType) {
                return this.createDictionaryType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_DictionaryType) {
                return this.createDictionaryType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_DictionaryAttribute) {
                return this.createDictionaryAttribute();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_DictionaryAttribute) {
                return this.createDictionaryAttribute();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_DictionaryValue) {
                return this.createDictionaryValue();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_DictionaryValue) {
                return this.createDictionaryValue();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_PortTypeRef) {
                return this.createPortTypeRef();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_PortTypeRef) {
                return this.createPortTypeRef();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ServicePortType) {
                return this.createServicePortType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_ServicePortType) {
                return this.createServicePortType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Operation) {
                return this.createOperation();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Operation) {
                return this.createOperation();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Parameter) {
                return this.createParameter();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Parameter) {
                return this.createParameter();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_TypedElement) {
                return this.createTypedElement();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_TypedElement) {
                return this.createTypedElement();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_MessagePortType) {
                return this.createMessagePortType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_MessagePortType) {
                return this.createMessagePortType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Repository) {
                return this.createRepository();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Repository) {
                return this.createRepository();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_DeployUnit) {
                return this.createDeployUnit();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_DeployUnit) {
                return this.createDeployUnit();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_TypeLibrary) {
                return this.createTypeLibrary();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_TypeLibrary) {
                return this.createTypeLibrary();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_PortTypeMapping) {
                return this.createPortTypeMapping();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_PortTypeMapping) {
                return this.createPortTypeMapping();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Channel) {
                return this.createChannel();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Channel) {
                return this.createChannel();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_MBinding) {
                return this.createMBinding();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_MBinding) {
                return this.createMBinding();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_NodeNetwork) {
                return this.createNodeNetwork();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_NodeNetwork) {
                return this.createNodeNetwork();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_NodeLink) {
                return this.createNodeLink();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_NodeLink) {
                return this.createNodeLink();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_NetworkInfo) {
                return this.createNetworkInfo();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_NetworkInfo) {
                return this.createNetworkInfo();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_NetworkProperty) {
                return this.createNetworkProperty();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_NetworkProperty) {
                return this.createNetworkProperty();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ChannelType) {
                return this.createChannelType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_ChannelType) {
                return this.createChannelType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Instance) {
                return this.createInstance();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Instance) {
                return this.createInstance();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Group) {
                return this.createGroup();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Group) {
                return this.createGroup();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_GroupType) {
                return this.createGroupType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_GroupType) {
                return this.createGroupType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_NodeType) {
                return this.createNodeType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_NodeType) {
                return this.createNodeType();
              }
               else {
                return null;
              }
            }
          }),
          DictionaryImpl: Kotlin.createClass([_c.Dictionary, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$generated_KMF_ID = '' + Math.random() + (new Date()).getTime();
            this._values = new Kotlin.PrimitiveHashMap(0);
            this.removeAllValuesCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.DictionaryImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              var tmp$1;
              (tmp$1 = this._values) != null ? tmp$1.clear() : null;
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$generated_KMF_ID;
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path(), null));
                }
              }
            },
            values: {
              get: function () {
                return _.kotlin.toList(this._values.values());
              },
              set: function (valuesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (valuesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_values(valuesP, true, true);
              }
            },
            internal_values: function (valuesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._values.values(), valuesP)) {
                var kmf_previousVal = this._values;
                this._values.clear();
                {
                  var tmp$0 = valuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._values.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_values, el), _.org.kevoree.util.Constants.Ref_values);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, kmf_previousVal));
                }
              }
            },
            doAddValues: function (valuesP) {
              var _key_ = (valuesP != null ? valuesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._values.containsKey(_key_)) {
                this._values.put(_key_, valuesP);
                (valuesP != null ? valuesP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_values, valuesP), _.org.kevoree.util.Constants.Ref_values);
              }
            },
            addValues: function (valuesP) {
              this.internal_addValues(valuesP, true, true);
            },
            addAllValues: function (valuesP) {
              this.internal_addAllValues(valuesP, true, true);
            },
            internal_addValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddValues(valuesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, null));
              }
            },
            internal_addAllValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = valuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddValues(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = valuesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddValues(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, null));
              }
            },
            removeValues: function (valuesP) {
              this.internal_removeValues(valuesP, true, true);
            },
            removeAllValues: function () {
              this.internal_removeAllValues(true, true);
            },
            internal_removeValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._values.size() !== 0 && this._values.containsKey((valuesP != null ? valuesP : Kotlin.throwNPE()).internalGetKey())) {
                this._values.remove((valuesP != null ? valuesP : Kotlin.throwNPE()).internalGetKey());
                ((valuesP != null ? valuesP : Kotlin.throwNPE()) != null ? valuesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllValuesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, null));
                }
              }
            },
            internal_removeAllValues: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllValuesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.values) != null ? tmp$0 : Kotlin.throwNPE();
              this._values.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, temp_els, null));
                this.removeAllValuesCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_values) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllValues();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._values.size() !== 0 && this._values.containsKey(value)) {
                    var obj = this._values.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._values.remove(value);
                    this._values.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = this.generated_KMF_ID;
              }
              return this.key_cache;
            },
            findValuesByID: function (key) {
              return this._values.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_values) {
                return this.findValuesByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_values, _.org.kevoree.util.Constants.org_kevoree_DictionaryValue);
                {
                  var tmp$0 = this._values.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._values.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_values);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_values);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Dictionary;
            }
          }),
          DictionaryTypeImpl: Kotlin.createClass([_c.DictionaryType, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$generated_KMF_ID = '' + Math.random() + (new Date()).getTime();
            this._attributes = new Kotlin.PrimitiveHashMap(0);
            this.removeAllAttributesCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.DictionaryTypeImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              var tmp$1;
              (tmp$1 = this._attributes) != null ? tmp$1.clear() : null;
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$generated_KMF_ID;
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path(), null));
                }
              }
            },
            attributes: {
              get: function () {
                return _.kotlin.toList(this._attributes.values());
              },
              set: function (attributesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (attributesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_attributes(attributesP, true, true);
              }
            },
            internal_attributes: function (attributesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._attributes.values(), attributesP)) {
                var kmf_previousVal = this._attributes;
                this._attributes.clear();
                {
                  var tmp$0 = attributesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._attributes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_attributes, el), _.org.kevoree.util.Constants.Ref_attributes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, attributesP, kmf_previousVal));
                }
              }
            },
            doAddAttributes: function (attributesP) {
              var _key_ = (attributesP != null ? attributesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._attributes.containsKey(_key_)) {
                this._attributes.put(_key_, attributesP);
                (attributesP != null ? attributesP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_attributes, attributesP), _.org.kevoree.util.Constants.Ref_attributes);
              }
            },
            addAttributes: function (attributesP) {
              this.internal_addAttributes(attributesP, true, true);
            },
            addAllAttributes: function (attributesP) {
              this.internal_addAllAttributes(attributesP, true, true);
            },
            internal_addAttributes: function (attributesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddAttributes(attributesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, attributesP, null));
              }
            },
            internal_addAllAttributes: function (attributesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = attributesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddAttributes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = attributesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddAttributes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, attributesP, null));
              }
            },
            removeAttributes: function (attributesP) {
              this.internal_removeAttributes(attributesP, true, true);
            },
            removeAllAttributes: function () {
              this.internal_removeAllAttributes(true, true);
            },
            internal_removeAttributes: function (attributesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._attributes.size() !== 0 && this._attributes.containsKey((attributesP != null ? attributesP : Kotlin.throwNPE()).internalGetKey())) {
                this._attributes.remove((attributesP != null ? attributesP : Kotlin.throwNPE()).internalGetKey());
                ((attributesP != null ? attributesP : Kotlin.throwNPE()) != null ? attributesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllAttributesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, attributesP, null));
                }
              }
            },
            internal_removeAllAttributes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllAttributesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.attributes) != null ? tmp$0 : Kotlin.throwNPE();
              this._attributes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, temp_els, null));
                this.removeAllAttributesCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_attributes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addAttributes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllAttributes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeAttributes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllAttributes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._attributes.size() !== 0 && this._attributes.containsKey(value)) {
                    var obj = this._attributes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._attributes.remove(value);
                    this._attributes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = this.generated_KMF_ID;
              }
              return this.key_cache;
            },
            findAttributesByID: function (key) {
              return this._attributes.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_attributes) {
                return this.findAttributesByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_attributes, _.org.kevoree.util.Constants.org_kevoree_DictionaryAttribute);
                {
                  var tmp$0 = this._attributes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._attributes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_attributes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_attributes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_DictionaryType;
            }
          }),
          MBindingImpl: Kotlin.createClass([_c.MBinding, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$generated_KMF_ID = '' + Math.random() + (new Date()).getTime();
            this.$port = null;
            this.$hub = null;
          }, /** @lends _.org.kevoree.impl.MBindingImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              this.port = null;
              this.hub = null;
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$generated_KMF_ID;
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path(), null));
                }
              }
            },
            port: {
              get: function () {
                return this.$port;
              },
              set: function (portP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_port(portP, true, true);
              }
            },
            internal_port: function (portP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$port, portP)) {
                if (setOpposite) {
                  if (this.$port != null) {
                    var tmp$0;
                    ((tmp$0 = this.$port) != null ? tmp$0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_bindings, this, false, fireEvents);
                  }
                  if (portP != null) {
                    portP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.util.Constants.Ref_bindings, this, false, fireEvents);
                  }
                }
                var kmf_previousVal = this.$port;
                this.$port = portP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_port, portP, kmf_previousVal));
                }
              }
            },
            hub: {
              get: function () {
                return this.$hub;
              },
              set: function (hubP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_hub(hubP, true, true);
              }
            },
            internal_hub: function (hubP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$hub, hubP)) {
                if (setOpposite) {
                  if (this.$hub != null) {
                    var tmp$0;
                    ((tmp$0 = this.$hub) != null ? tmp$0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_bindings, this, false, fireEvents);
                  }
                  if (hubP != null) {
                    hubP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.util.Constants.Ref_bindings, this, false, fireEvents);
                  }
                }
                var kmf_previousVal = this.$hub;
                this.$hub = hubP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_hub, hubP, kmf_previousVal));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_port) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_port(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_port(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_port(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_hub) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_hub(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_hub(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_hub(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = this.generated_KMF_ID;
              }
              return this.key_cache;
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_port) {
                var objFound = this.port;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_hub) {
                var objFound_0 = this.hub;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_port, _.org.kevoree.util.Constants.org_kevoree_Port);
                this.internal_visit(visitor, this.port, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_port);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_port);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_hub, _.org.kevoree.util.Constants.org_kevoree_Channel);
                this.internal_visit(visitor, this.hub, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_hub);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_hub);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_MBinding;
            }
          }),
          ServicePortTypeImpl: Kotlin.createClass([_c.ServicePortType, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$name = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$version = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$factoryBean = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$bean = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$abstract = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$synchrone = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$interface = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$dictionaryType = null;
            this.$deployUnit = null;
            this._operations = new Kotlin.PrimitiveHashMap(0);
            this.removeAllOperationsCurrentlyProcessing = false;
            this._superTypes = new Kotlin.PrimitiveHashMap(0);
          }, /** @lends _.org.kevoree.impl.ServicePortTypeImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              this.deployUnit = null;
              this.dictionaryType = null;
              var tmp$1, tmp$2;
              (tmp$1 = this._superTypes) != null ? tmp$1.clear() : null;
              (tmp$2 = this._operations) != null ? tmp$2.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name;
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path(), null));
                }
              }
            },
            version: {
              get: function () {
                return this.$version;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$version;
                this.$version = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_version, this.path(), null));
                }
              }
            },
            factoryBean: {
              get: function () {
                return this.$factoryBean;
              },
              set: function (iP) {
                this.internal_factoryBean(iP, true);
              }
            },
            internal_factoryBean: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.factoryBean)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$factoryBean;
                this.$factoryBean = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_factoryBean, this.factoryBean, kmf_previousVal));
                }
              }
            },
            bean: {
              get: function () {
                return this.$bean;
              },
              set: function (iP) {
                this.internal_bean(iP, true);
              }
            },
            internal_bean: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.bean)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$bean;
                this.$bean = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_bean, this.bean, kmf_previousVal));
                }
              }
            },
            abstract: {
              get: function () {
                return this.$abstract;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$abstract;
                this.$abstract = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract, kmf_previousVal));
                }
              }
            },
            synchrone: {
              get: function () {
                return this.$synchrone;
              },
              set: function (iP) {
                this.internal_synchrone(iP, true);
              }
            },
            internal_synchrone: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.synchrone)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$synchrone;
                this.$synchrone = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_synchrone, this.synchrone, kmf_previousVal));
                }
              }
            },
            interface: {
              get: function () {
                return this.$interface;
              },
              set: function (iP) {
                this.internal_interface(iP, true);
              }
            },
            internal_interface: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.interface)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$interface;
                this.$interface = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_interface, this.interface, kmf_previousVal));
                }
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType, dictionaryTypeP)) {
                if (this.$dictionaryType != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                var kmf_previousVal = this.$dictionaryType;
                this.$dictionaryType = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP, kmf_previousVal));
                }
              }
            },
            deployUnit: {
              get: function () {
                return this.$deployUnit;
              },
              set: function (deployUnitP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_deployUnit(deployUnitP, true, true);
              }
            },
            internal_deployUnit: function (deployUnitP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$deployUnit, deployUnitP)) {
                var kmf_previousVal = this.$deployUnit;
                this.$deployUnit = deployUnitP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnit, deployUnitP, kmf_previousVal));
                }
              }
            },
            operations: {
              get: function () {
                return _.kotlin.toList(this._operations.values());
              },
              set: function (operationsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (operationsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_operations(operationsP, true, true);
              }
            },
            internal_operations: function (operationsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._operations.values(), operationsP)) {
                var kmf_previousVal = this._operations;
                this._operations.clear();
                {
                  var tmp$0 = operationsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._operations.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_operations, el), _.org.kevoree.util.Constants.Ref_operations);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, operationsP, kmf_previousVal));
                }
              }
            },
            doAddOperations: function (operationsP) {
              var _key_ = (operationsP != null ? operationsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._operations.containsKey(_key_)) {
                this._operations.put(_key_, operationsP);
                (operationsP != null ? operationsP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_operations, operationsP), _.org.kevoree.util.Constants.Ref_operations);
              }
            },
            addOperations: function (operationsP) {
              this.internal_addOperations(operationsP, true, true);
            },
            addAllOperations: function (operationsP) {
              this.internal_addAllOperations(operationsP, true, true);
            },
            internal_addOperations: function (operationsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddOperations(operationsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, operationsP, null));
              }
            },
            internal_addAllOperations: function (operationsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = operationsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddOperations(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = operationsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddOperations(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, operationsP, null));
              }
            },
            removeOperations: function (operationsP) {
              this.internal_removeOperations(operationsP, true, true);
            },
            removeAllOperations: function () {
              this.internal_removeAllOperations(true, true);
            },
            internal_removeOperations: function (operationsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._operations.size() !== 0 && this._operations.containsKey((operationsP != null ? operationsP : Kotlin.throwNPE()).internalGetKey())) {
                this._operations.remove((operationsP != null ? operationsP : Kotlin.throwNPE()).internalGetKey());
                ((operationsP != null ? operationsP : Kotlin.throwNPE()) != null ? operationsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllOperationsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, operationsP, null));
                }
              }
            },
            internal_removeAllOperations: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllOperationsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.operations) != null ? tmp$0 : Kotlin.throwNPE();
              this._operations.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, temp_els, null));
                this.removeAllOperationsCurrentlyProcessing = false;
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                var kmf_previousVal = this._superTypes;
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, kmf_previousVal));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = (superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey(_key_)) {
                this._superTypes.put(_key_, superTypesP);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._superTypes.remove((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.superTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els, null));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_version) {
                this.internal_version(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_factoryBean) {
                this.internal_factoryBean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_bean) {
                this.internal_bean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_synchrone) {
                this.internal_synchrone(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_interface) {
                this.internal_interface(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnit) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_deployUnit(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_deployUnit(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_deployUnit(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_dictionaryType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllSuperTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._superTypes.size() !== 0 && this._superTypes.containsKey(value)) {
                    var obj = this._superTypes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._superTypes.remove(value);
                    this._superTypes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_operations) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                  this.internal_addOperations(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                  this.internal_addAllOperations(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                  this.internal_removeOperations(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                  this.removeAllOperations();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                  if (this._operations.size() !== 0 && this._operations.containsKey(value)) {
                    var obj_0 = this._operations.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._operations.remove(value);
                    this._operations.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(this.name) + '/' + Kotlin.toString(this.version);
              }
              return this.key_cache;
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get(key);
            },
            findOperationsByID: function (key) {
              return this._operations.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_deployUnit) {
                var objFound = this.deployUnit;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                var objFound_0 = this.dictionaryType;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                return this.findSuperTypesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_operations) {
                return this.findOperationsByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType);
                this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_operations, _.org.kevoree.util.Constants.org_kevoree_Operation);
                {
                  var tmp$0 = this._operations.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._operations.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_operations);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_operations);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnit, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                this.internal_visit(visitor, this.deployUnit, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnit);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnit);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$1 = this._superTypes.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._superTypes.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.synchrone, _.org.kevoree.util.Constants.Att_synchrone, this);
              visitor.visit(this.bean, _.org.kevoree.util.Constants.Att_bean, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.factoryBean, _.org.kevoree.util.Constants.Att_factoryBean, this);
              visitor.visit(this.interface, _.org.kevoree.util.Constants.Att_interface, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ServicePortType;
            }
          }),
          DictionaryValueImpl: Kotlin.createClass([_c.DictionaryValue, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$name = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$value = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
          }, /** @lends _.org.kevoree.impl.DictionaryValueImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name;
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path(), null));
                }
              }
            },
            value: {
              get: function () {
                return this.$value;
              },
              set: function (iP) {
                this.internal_value(iP, true);
              }
            },
            internal_value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.value)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$value;
                this.$value = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_value, this.value, kmf_previousVal));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_value) {
                this.internal_value(value, fireEvents);
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(this.name);
              }
              return this.key_cache;
            },
            findByID: function (relationName, idP) {
              {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.value, _.org.kevoree.util.Constants.Att_value, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_DictionaryValue;
            }
          }),
          PortTypeMappingImpl: Kotlin.createClass([_c.PortTypeMapping, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.key_cache = null;
            this.$beanMethodName = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$serviceMethodName = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$paramTypes = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$generated_KMF_ID = '' + Math.random() + (new Date()).getTime();
          }, /** @lends _.org.kevoree.impl.PortTypeMappingImpl.prototype */ {
            delete: function () {
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
            },
            beanMethodName: {
              get: function () {
                return this.$beanMethodName;
              },
              set: function (iP) {
                this.internal_beanMethodName(iP, true);
              }
            },
            internal_beanMethodName: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.beanMethodName)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$beanMethodName;
                this.$beanMethodName = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_beanMethodName, this.beanMethodName, kmf_previousVal));
                }
              }
            },
            serviceMethodName: {
              get: function () {
                return this.$serviceMethodName;
              },
              set: function (iP) {
                this.internal_serviceMethodName(iP, true);
              }
            },
            internal_serviceMethodName: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.serviceMethodName)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$serviceMethodName;
                this.$serviceMethodName = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_serviceMethodName, this.serviceMethodName, kmf_previousVal));
                }
              }
            },
            paramTypes: {
              get: function () {
                return this.$paramTypes;
              },
              set: function (iP) {
                this.internal_paramTypes(iP, true);
              }
            },
            internal_paramTypes: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.paramTypes)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$paramTypes;
                this.$paramTypes = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_paramTypes, this.paramTypes, kmf_previousVal));
                }
              }
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$generated_KMF_ID;
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID, kmf_previousVal));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path(), null));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_beanMethodName) {
                this.internal_beanMethodName(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_serviceMethodName) {
                this.internal_serviceMethodName(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_paramTypes) {
                this.internal_paramTypes(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = this.generated_KMF_ID;
              }
              return this.key_cache;
            },
            findByID: function (relationName, idP) {
              {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
              visitor.visit(this.paramTypes, _.org.kevoree.util.Constants.Att_paramTypes, this);
              visitor.visit(this.serviceMethodName, _.org.kevoree.util.Constants.Att_serviceMethodName, this);
              visitor.visit(this.beanMethodName, _.org.kevoree.util.Constants.Att_beanMethodName, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_PortTypeMapping;
            }
          })
        }),
        loader: Kotlin.definePackage(null, /** @lends _.org.kevoree.loader */ {
          JSONModelLoader: Kotlin.createClass(_c.JSONModelLoader, function $fun() {
            $fun.baseInitializer.call(this);
            this.factory = new _.org.kevoree.factory.MainFactory();
          }),
          XMIModelLoader: Kotlin.createClass(_c.XMIModelLoader, function $fun() {
            $fun.baseInitializer.call(this);
            this.factory = new _.org.kevoree.factory.MainFactory();
          })
        }),
        trace: Kotlin.definePackage(null, /** @lends _.org.kevoree.trace */ {
          DefaultTraceSequence: Kotlin.createClass(_c.TraceSequence, function () {
            this.traces = new Kotlin.ArrayList(0);
            this.factory = new _.org.kevoree.factory.MainFactory();
          })
        }),
        container: Kotlin.definePackage(function () {
          this.cleanCacheVisitor = Kotlin.createObject(_c.ModelVisitor, function $fun() {
            $fun.baseInitializer.call(this);
          }, {
            visit: function (elem, refNameInParent, parent) {
              (elem != null ? elem : Kotlin.throwNPE()).path_cache = null;
            }
          });
        }, /** @lends _.org.kevoree.container */ {
          RemoveFromContainerCommand: Kotlin.createClass(null, function (target, mutatorType, refName, element) {
            this.target = target;
            this.mutatorType = mutatorType;
            this.refName = refName;
            this.element = element;
          }, /** @lends _.org.kevoree.container.RemoveFromContainerCommand.prototype */ {
            run: function () {
              this.target.reflexiveMutator(this.mutatorType, this.refName, this.element, true, true);
            }
          })
        }),
        log: Kotlin.definePackage(function () {
          this.Log = Kotlin.createObject(null, function () {
            this.LEVEL_NONE = 6;
            this.LEVEL_ERROR = 5;
            this.LEVEL_WARN = 4;
            this.LEVEL_INFO = 3;
            this.LEVEL_DEBUG = 2;
            this.LEVEL_TRACE = 1;
            this.$level = this.LEVEL_INFO;
            this._ERROR = this.level <= this.LEVEL_ERROR;
            this._WARN = this.level <= this.LEVEL_WARN;
            this._INFO = this.level <= this.LEVEL_INFO;
            this._DEBUG = this.level <= this.LEVEL_DEBUG;
            this._TRACE = this.level <= this.LEVEL_TRACE;
            this.logger = new _.org.kevoree.log.Logger();
            this.beginParam = '{';
            this.endParam = '}';
          }, {
            level: {
              get: function () {
                return this.$level;
              },
              set: function (newLevel) {
                this.$level = newLevel;
                this._ERROR = newLevel <= this.LEVEL_ERROR;
                this._WARN = newLevel <= this.LEVEL_WARN;
                this._INFO = newLevel <= this.LEVEL_INFO;
                this._DEBUG = newLevel <= this.LEVEL_DEBUG;
                this._TRACE = newLevel <= this.LEVEL_TRACE;
              }
            },
            NONE: function () {
              this.level = this.LEVEL_NONE;
            },
            ERROR: function () {
              this.level = this.LEVEL_ERROR;
            },
            WARN: function () {
              this.level = this.LEVEL_WARN;
            },
            INFO: function () {
              this.level = this.LEVEL_INFO;
            },
            DEBUG: function () {
              this.level = this.LEVEL_DEBUG;
            },
            TRACE: function () {
              this.level = this.LEVEL_TRACE;
            },
            processMessage: function (message, p1, p2, p3, p4, p5) {
              if (p1 == null) {
                return message;
              }
              var buffer = new _.java.lang.StringBuilder();
              var previousCharfound = false;
              var param = 0;
              var i = 0;
              while (i < message.length) {
                var currentChar = message.charAt(i);
                if (previousCharfound) {
                  if (currentChar === this.endParam) {
                    param++;
                    if (param === 1) {
                      buffer = new _.java.lang.StringBuilder();
                      buffer.append(message.substring(0, i - 1));
                      buffer.append(Kotlin.toString(p1 != null ? p1 : Kotlin.throwNPE()));
                    }
                     else if (param === 2) {
                      buffer.append(Kotlin.toString(p2 != null ? p2 : Kotlin.throwNPE()));
                    }
                     else if (param === 3) {
                      buffer.append(Kotlin.toString(p3 != null ? p3 : Kotlin.throwNPE()));
                    }
                     else if (param === 4) {
                      buffer.append(Kotlin.toString(p4 != null ? p4 : Kotlin.throwNPE()));
                    }
                     else if (param === 5) {
                      buffer.append(Kotlin.toString(p5 != null ? p5 : Kotlin.throwNPE()));
                    }
                     else {
                    }
                    previousCharfound = false;
                  }
                   else {
                    if (buffer != null) {
                      message.charAt(i - 1);
                      buffer.append_0(currentChar);
                    }
                    previousCharfound = false;
                  }
                }
                 else {
                  if (currentChar === this.beginParam) {
                    previousCharfound = true;
                  }
                   else {
                    if (buffer != null) {
                      buffer.append_0(currentChar);
                    }
                  }
                }
                i = i + 1;
              }
              if (buffer != null) {
                return buffer.toString();
              }
               else {
                return message;
              }
            },
            error: function (message, ex, p1, p2, p3, p4, p5) {
              if (this._ERROR) {
                this.internal_error(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            },
            error_0: function (message, p1, p2, p3, p4, p5) {
              if (this._ERROR) {
                this.internal_error(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            },
            internal_error: function (message, ex) {
              this.logger.log(this.LEVEL_ERROR, message, ex);
            },
            warn: function (message, ex, p1, p2, p3, p4, p5) {
              if (this._WARN) {
                this.internal_warn(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            },
            warn_0: function (message, p1, p2, p3, p4, p5) {
              if (this._WARN) {
                this.internal_warn(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            },
            internal_warn: function (message, ex) {
              this.logger.log(this.LEVEL_WARN, message, ex);
            },
            info: function (message, ex, p1, p2, p3, p4, p5) {
              if (this._INFO) {
                this.internal_info(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            },
            info_0: function (message, p1, p2, p3, p4, p5) {
              if (this._INFO) {
                this.internal_info(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            },
            internal_info: function (message, ex) {
              this.logger.log(this.LEVEL_INFO, message, ex);
            },
            debug: function (message, ex, p1, p2, p3, p4, p5) {
              if (this._DEBUG) {
                this.internal_debug(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            },
            debug_0: function (message, p1, p2, p3, p4, p5) {
              if (this._DEBUG) {
                this.internal_debug(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            },
            internal_debug: function (message, ex) {
              this.logger.log(this.LEVEL_DEBUG, message, ex);
            },
            trace: function (message, ex, p1, p2, p3, p4, p5) {
              if (this._TRACE) {
                this.internal_trace(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            },
            trace_0: function (message, p1, p2, p3, p4, p5) {
              if (this._TRACE) {
                this.internal_trace(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            },
            internal_trace: function (message, ex) {
              this.logger.log(this.LEVEL_TRACE, message, ex);
            }
          });
        }, /** @lends _.org.kevoree.log */ {
          Logger: Kotlin.createClass(null, function () {
            this.firstLogTime = (new Date()).getTime();
            this.error_msg = ' ERROR: ';
            this.warn_msg = ' WARN: ';
            this.info_msg = ' INFO: ';
            this.debug_msg = ' DEBUG: ';
            this.trace_msg = ' TRACE: ';
            this.category = null;
          }, /** @lends _.org.kevoree.log.Logger.prototype */ {
            setCategory: function (category) {
              this.category = category;
            },
            log: function (level, message, ex) {
              var builder = new _.java.lang.StringBuilder();
              var time = (new Date()).getTime() - this.firstLogTime;
              var minutes = time / (1000 * 60) | 0;
              var seconds = (time / 1000 | 0) % 60;
              if (minutes <= 9)
                builder.append_0('0');
              builder.append(Kotlin.toString(minutes));
              builder.append_0(':');
              if (seconds <= 9)
                builder.append_0('0');
              builder.append(Kotlin.toString(seconds));
              if (level === _.org.kevoree.log.Log.LEVEL_ERROR) {
                builder.append(this.error_msg);
              }
               else if (level === _.org.kevoree.log.Log.LEVEL_WARN) {
                builder.append(this.warn_msg);
              }
               else if (level === _.org.kevoree.log.Log.LEVEL_INFO) {
                builder.append(this.info_msg);
              }
               else if (level === _.org.kevoree.log.Log.LEVEL_DEBUG) {
                builder.append(this.debug_msg);
              }
               else if (level === _.org.kevoree.log.Log.LEVEL_TRACE) {
                builder.append(this.trace_msg);
              }
               else {
              }
              if (this.category != null) {
                builder.append_0('[');
                var tmp$0;
                builder.append(((tmp$0 = this.category) != null ? tmp$0 : Kotlin.throwNPE()).toString());
                builder.append('] ');
              }
              builder.append(message);
              if (ex != null) {
                builder.append(Kotlin.toString(ex.getMessage()));
              }
              if (level === _.org.kevoree.log.Log.LEVEL_ERROR) {
                console.error(builder.toString());
              }
               else if (level === _.org.kevoree.log.Log.LEVEL_WARN) {
                console.warn(builder.toString());
              }
               else if (level === _.org.kevoree.log.Log.LEVEL_INFO) {
                console.info(builder.toString());
              }
               else if (level === _.org.kevoree.log.Log.LEVEL_DEBUG) {
                console.log(builder.toString());
              }
               else if (level === _.org.kevoree.log.Log.LEVEL_TRACE) {
                console.log(builder.toString());
              }
               else {
              }
            }
          })
        })
      }),
      w3c: Kotlin.definePackage(null, /** @lends _.org.w3c */ {
        dom: Kotlin.definePackage(null, /** @lends _.org.w3c.dom */ {
          events: Kotlin.definePackage(null, /** @lends _.org.w3c.dom.events */ {
            EventListener: _c.EventListener
          })
        })
      })
    }),
    js: Kotlin.definePackage(null, /** @lends _.js */ {
      toChar: function ($receiver) {
        return $receiver != null ? $receiver : Kotlin.throwNPE();
      },
      lastIndexOf_0: function ($receiver, ch, fromIndex) {
        return $receiver.lastIndexOf(Kotlin.toString(ch), fromIndex);
      },
      lastIndexOf: function ($receiver, ch) {
        return $receiver.lastIndexOf(Kotlin.toString(ch));
      },
      indexOf: function ($receiver, ch) {
        return $receiver.indexOf(Kotlin.toString(ch));
      },
      indexOf_0: function ($receiver, ch, fromIndex) {
        return $receiver.indexOf(Kotlin.toString(ch), fromIndex);
      },
      matches: function ($receiver, regex) {
        var result = $receiver.match(regex);
        return result != null && result.length > 0;
      },
      capitalize: function ($receiver) {
        return _.kotlin.isNotEmpty($receiver) ? $receiver.substring(0, 1).toUpperCase() + $receiver.substring(1) : $receiver;
      },
      decapitalize: function ($receiver) {
        return _.kotlin.isNotEmpty($receiver) ? $receiver.substring(0, 1).toLowerCase() + $receiver.substring(1) : $receiver;
      }
    }),
    java: Kotlin.definePackage(null, /** @lends _.java */ {
      lang: Kotlin.definePackage(null, /** @lends _.java.lang */ {
        StringBuilder: Kotlin.createClass(null, function () {
          this.content = '';
        }, /** @lends _.java.lang.StringBuilder.prototype */ {
          append: function (sub) {
            this.content = this.content + sub;
          },
          append_0: function (sub) {
            this.content = this.content + sub;
          },
          delete: function (startIndex, endIndex) {
            this.content = '';
          },
          length: function () {
            return this.content.length;
          },
          toString: function () {
            return this.content;
          }
        })
      }),
      io: Kotlin.definePackage(null, /** @lends _.java.io */ {
        OutputStream: _c.OutputStream,
        BufferedOutputStream: Kotlin.createClass(_c.OutputStream, function (oo) {
          this.oo = oo;
        }, /** @lends _.java.io.BufferedOutputStream.prototype */ {
          write: function (s) {
            var tmp$0;
            ((tmp$0 = this.oo) != null ? tmp$0 : Kotlin.throwNPE()).result = s;
          }
        }),
        ByteArrayInputStream: Kotlin.createClass(_c.InputStream, function (inputBytes) {
          this.inputBytes = inputBytes;
        }, /** @lends _.java.io.ByteArrayInputStream.prototype */ {
          readBytes: function () {
            return this.inputBytes;
          }
        }),
        ByteArrayOutputStream: Kotlin.createClass(_c.OutputStream, function () {
          this.result = '';
        }, /** @lends _.java.io.ByteArrayOutputStream.prototype */ {
          flush: function () {
          },
          close: function () {
          },
          toString: function () {
            return this.result;
          }
        }),
        PrintStream: Kotlin.createClass(null, function (oo, autoflush) {
          this.oo = oo;
          this.result = '';
        }, /** @lends _.java.io.PrintStream.prototype */ {
          println: function () {
            this.result = this.result + '\n';
          },
          print: function (s) {
            this.result = this.result + s;
          },
          println_0: function (s) {
            this.print(s);
            this.println();
          },
          print_0: function (s) {
            this.result = this.result + s;
          },
          print_1: function (s) {
            this.result = this.result + s;
          },
          print_2: function (s) {
            this.result = this.result + s;
          },
          print_3: function (s) {
            if (s) {
              this.result = this.result + 'true';
            }
             else {
              this.result = this.result + 'false';
            }
          },
          println_1: function (s) {
            this.print_0(s);
            this.println();
          },
          flush: function () {
            var tmp$0;
            ((tmp$0 = this.oo) != null ? tmp$0 : Kotlin.throwNPE()).write(this.result);
          },
          close: function () {
          }
        })
      })
    })
  });
  Kotlin.defineModule('org.kevoree.model.js', _);
}());

module.exports = Kotlin.modules['org.kevoree.model.js'];
},{"kevoree-kotlin":33}],36:[function(require,module,exports){
/*
	Class - JavaScript inheritance

	Construction:
		Setup and construction should happen in the construct() method.
		The construct() method is automatically chained, so all construct() methods defined by superclass methods will be called first.

	Initialization:
		Initialziation that needs to happen after all construct() methods have been called should be done in the init() method.
		The init() method is not automatically chained, so you must call _super() if you intend to call the superclass' init method.
		init() is not passed any arguments

	Destruction:
		Teardown and destruction should happen in the destruct() method. The destruct() method is also chained.

	Mixins:
		An array of mixins can be provided with the mixins[] property. An object or the prototype of a class should be provided, not a constructor.
		Mixins can be added at any time by calling this.mixin(properties)

	Usage:
		var MyClass = Class(properties);
		var MyClass = new Class(properties);
		var MyClass = Class.extend(properties);

	Credits:
		Inspired by Simple JavaScript Inheritance by John Resig http://ejohn.org/

	Usage differences:
		construct() is used to setup instances and is automatically chained so superclass construct() methods run automatically
		destruct() is used  to tear down instances. destruct() is also chained
		init(), if defined, is called after construction is complete and is not chained
		toString() can be defined as a string or a function
		mixin() is provided to mix properties into an instance
		properties.mixins as an array results in each of the provided objects being mixed in (last object wins)
		_super is passed as an argument (not as this._super) and can be used asynchronously
*/
(function(global) {
	// Used for default initialization methods
	var noop = function() {};

	// Given a function, the superTest RE will match if _super is the first argument to a function
	// The function will be serialized, then the serialized string will be searched for _super
	// If the environment isn't capable of function serialization, make it so superTest.test always returns true
	var superTest = /xyz/.test(function(){return 'xyz';}) ? /\(\s*_super\b/ : { test: function() { return true; } };

	// Remove the _super function from the passed arguments array
	var removeSuper = function(args, _super) {
		// For performance, first check if at least one argument was passed
		if (args && args.length && args[0] === _super)
			args = Array.prototype.slice.call(args, 1);
		return args;
	};

	// Bind an overriding method such that it gets the overridden method as its first argument
	var superify = function(name, func, superPrototype, isStatic) {
		var _super;

		// We redefine _super.apply so _super is stripped from the passed arguments array
		// This allows implementors to call _super.apply(this, arguments) without manually stripping off _super
		if (isStatic) {
			// Static binding: If the passed superPrototype is modified, the bound function will still call the ORIGINAL method
			// This comes into play when functions are mixed into an object that already has a function by that name (i.e. two mixins are used)
			var superFunc = superPrototype[name];
			_super = function _superStatic() {
				return superFunc.apply(this, arguments);
			};

			_super.apply = function _applier(context, args) {
				return Function.prototype.apply.call(superFunc, context, removeSuper(args, _super));
			};
		}
		else {
			// Dynamic binding: If the passed superPrototype is modified, the bound function will call the NEW method
			// This comes into play when functions are mixed into a class at declaration time
			_super = function _superDynamic() {
				return superPrototype[name].apply(this, arguments);
			};

			_super.apply = function _applier(context, args) {
				return Function.prototype.apply.call(superPrototype[name], context, removeSuper(args, _super));
			};
		}

		// Name the function for better stack traces
		return function _passSuper() {
			// Add the super function to the start of the arguments array
			var args = Array.prototype.slice.call(arguments);
			args.unshift(_super);

			// Call the function with the modified arguments
			return func.apply(this, args);
		};
	};

	// Mix the provided properties into the current context with the ability to call overridden methods with _super()
	var mixin = function(properties, superPrototype) {
		// Use this instance
		superPrototype = superPrototype || this.constructor && this.constructor.prototype;
		
		// Copy the properties onto the new prototype
		for (var name in properties) {
			// Never mix construct or destruct
			if (name === 'construct' || name === 'destruct')
				continue;

			// Check if the function uses _super
			// It should be a function, the super prototype should have a function by the same name
			// And finally, the function should take _super as its first argument
			var usesSuper = superPrototype && typeof properties[name] === 'function' && typeof superPrototype[name] === 'function' && superTest.test(properties[name]);

			if (usesSuper) {
				// Wrap the function such that _super will be passed accordingly
				if (this.hasOwnProperty(name))
					this[name] = superify(name, properties[name], this, true);
				else
					this[name] = superify(name, properties[name], superPrototype, false);
			}
			else {
				// Directly assign the property
				this[name] = properties[name];
			}
		}
	};

	// The base Class implementation acts as extend alias, with the exception that it can take properties.extend as the Class to extend
	var Class = function(properties) {
		// If a class-like object is passed as properties.extend, just call extend on it
		if (properties && properties.extend)
			return properties.extend.extend(properties);

		// Otherwise, just create a new class with the passed properties
		return Class.extend(properties);
	};
	
	// Add the mixin method to all classes created with Class
	Class.prototype.mixin = mixin;
	
	// Creates a new Class that inherits from this class
	// Give the function a name so it can refer to itself without arguments.callee
	Class.extend = function extend(properties) {
		var superPrototype = this.prototype;
		
		// Create an object with the prototype of the superclass
		var prototype = Object.create(superPrototype);
		
		if (properties) {
			// Mix the new properties into the class prototype
			// This does not copy construct and destruct
			mixin.call(prototype, properties, superPrototype);
			
			// Mix in all the mixins
			// This also does not copy construct and destruct
			if (Array.isArray(properties.mixins)) {
				for (var i = 0, ni = properties.mixins.length; i < ni; i++) {
					// Mixins should be _super enabled, with the methods defined in the prototype as the superclass methods
					mixin.call(prototype, properties.mixins[i], prototype);
				}
			}
			
			// Chain the construct() method (supermost executes first) if necessary
			if (properties.construct && superPrototype.construct) {
				prototype.construct = function() {
					superPrototype.construct.apply(this, arguments);
					properties.construct.apply(this, arguments);
				};
			}
			else if (properties.construct)
				prototype.construct = properties.construct;
			
			// Chain the destruct() method in reverse order (supermost executes last) if necessary
			if (properties.destruct && superPrototype.destruct) {
				prototype.destruct = function() {
					properties.destruct.apply(this, arguments);
					superPrototype.destruct.apply(this, arguments);
				};
			}
			else if (properties.destruct)
				prototype.destruct = properties.destruct;
			
			// Allow definition of toString as a string (turn it into a function)
			if (typeof properties.toString === 'string') {
				var className = properties.toString;
				prototype.toString = function() { return className; };
			}
		}

		// Define construct and init as noops if undefined
		// This serves to avoid conditionals inside of the constructor
		if (typeof prototype.construct !== 'function')
			prototype.construct = noop;
		if (typeof prototype.init !== 'function')
			prototype.init = noop;

		// The constructor handles creating an instance of the class, applying mixins, and calling construct() and init() methods
		function Class() {
			// Optimization: Requiring the new keyword and avoiding usage of Object.create() increases performance by 5x
			if (this instanceof Class === false) {
				throw new Error('Cannot create instance without new operator');
			}
			
			// Optimization: Avoiding conditionals in constructor increases performance of instantiation by 2x
			this.construct.apply(this, arguments);
			this.init();
		}

		// Assign prototype.constructor to the constructor itself
		// This allows instances to refer to this.constructor.prototype
		// This also allows creation of new instances using instance.constructor()
		prototype.constructor = Class;

		// Store the superPrototype
		// It will be accessible on an instance as follows:
		//	instance.superPrototype
		//	instance.constructor.prototype.superPrototype
		prototype.superPrototype = superPrototype;

		// Store the extended class' prototype as the prototype of the constructor
		Class.prototype = prototype;

		// Add extend() as a static method on the constructor
		Class.extend = extend;

		return Class;
	};
	
	if (typeof module !== 'undefined' && module.exports) {
		// Node.js Support
		module.exports = Class;
	}
	else if (typeof global.define === 'function') {
		(function(define) {
			// AMD Support
			define(function() { return Class; });
		}(global.define));
	}
	else {
		// Browser support
		global.Class = Class;
	}
}(this));

},{}]},{},[1])
(1)
});
;